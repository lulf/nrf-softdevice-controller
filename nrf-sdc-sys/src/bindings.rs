/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const NRF_EPERM: u32 = 1;
pub const NRF_ENOENT: u32 = 2;
pub const NRF_EIO: u32 = 5;
pub const NRF_EBADF: u32 = 9;
pub const NRF_ENOMEM: u32 = 12;
pub const NRF_EACCES: u32 = 13;
pub const NRF_EFAULT: u32 = 14;
pub const NRF_EINVAL: u32 = 22;
pub const NRF_EMFILE: u32 = 24;
pub const NRF_EAGAIN: u32 = 35;
pub const NRF_EPROTOTYPE: u32 = 41;
pub const NRF_ENOPROTOOPT: u32 = 42;
pub const NRF_EPROTONOSUPPORT: u32 = 43;
pub const NRF_ESOCKTNOSUPPORT: u32 = 44;
pub const NRF_EOPNOTSUPP: u32 = 45;
pub const NRF_EAFNOSUPPORT: u32 = 47;
pub const NRF_EADDRINUSE: u32 = 48;
pub const NRF_ENETDOWN: u32 = 50;
pub const NRF_ENETUNREACH: u32 = 51;
pub const NRF_ECONNRESET: u32 = 54;
pub const NRF_EISCONN: u32 = 56;
pub const NRF_ENOTCONN: u32 = 57;
pub const NRF_ETIMEDOUT: u32 = 60;
pub const NRF_ENOBUFS: u32 = 105;
pub const NRF_EHOSTDOWN: u32 = 112;
pub const NRF_EINPROGRESS: u32 = 115;
pub const NRF_ECANCELED: u32 = 125;
pub const NRF_ENOKEY: u32 = 126;
pub const NRF_EKEYEXPIRED: u32 = 127;
pub const NRF_EKEYREVOKED: u32 = 128;
pub const NRF_EKEYREJECTED: u32 = 129;
pub const INT32_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const SDC_DEFAULT_RESOURCE_CFG_TAG: u32 = 0;
pub const SDC_DEFAULT_ADV_COUNT: u32 = 1;
pub const SDC_DEFAULT_PERIODIC_ADV_COUNT: u32 = 0;
pub const SDC_DEFAULT_PERIODIC_SYNC_COUNT: u32 = 0;
pub const SDC_DEFAULT_PERIPHERAL_COUNT: u32 = 1;
pub const SDC_DEFAULT_CENTRAL_COUNT: u32 = 1;
pub const SDC_DEFAULT_TX_PACKET_SIZE: u32 = 27;
pub const SDC_DEFAULT_RX_PACKET_SIZE: u32 = 27;
pub const SDC_DEFAULT_TX_PACKET_COUNT: u32 = 3;
pub const SDC_DEFAULT_RX_PACKET_COUNT: u32 = 2;
pub const SDC_DEFAULT_SCAN_BUFFER_COUNT: u32 = 3;
pub const SDC_DEFAULT_PERIODIC_SYNC_BUFFER_COUNT: u32 = 2;
pub const SDC_DEFAULT_ADV_BUF_SIZE: u32 = 31;
pub const SDC_DEFAULT_PERIODIC_ADV_LIST_SIZE: u32 = 0;
pub const SDC_DEFAULT_EVENT_LENGTH_US: u32 = 7500;
pub const SDC_BUILD_REVISION_SIZE: u32 = 20;
pub const __MEM_MINIMAL_CENTRAL_LINK_SIZE: u32 = 1040;
pub const __MEM_MINIMAL_PERIPHERAL_LINK_SIZE: u32 = 1152;
pub const __MEM_TX_BUFFER_OVERHEAD_SIZE: u32 = 15;
pub const __MEM_RX_BUFFER_OVERHEAD_SIZE: u32 = 14;
pub const SDC_MEM_CENTRAL_LINKS_SHARED: u32 = 24;
pub const SDC_MEM_PERIPHERAL_LINKS_SHARED: u32 = 24;
pub const HCI_CMD_HEADER_SIZE: u32 = 3;
pub const HCI_DATA_HEADER_SIZE: u32 = 4;
pub const HCI_EVENT_HEADER_SIZE: u32 = 2;
pub const HCI_CMD_MAX_SIZE: u32 = 255;
pub const HCI_DATA_MAX_SIZE: u32 = 251;
pub const HCI_EVENT_MAX_SIZE: u32 = 255;
pub const HCI_CMD_PACKET_MAX_SIZE: u32 = 258;
pub const HCI_DATA_PACKET_MAX_SIZE: u32 = 255;
pub const HCI_EVENT_PACKET_MAX_SIZE: u32 = 257;
pub const HCI_MSG_BUFFER_MAX_SIZE: u32 = 258;
pub const MPSL_RECOMMENDED_RC_CTIV: u32 = 16;
pub const MPSL_RECOMMENDED_RC_TEMP_CTIV: u32 = 2;
pub const MPSL_DEFAULT_CLOCK_ACCURACY_PPM: u32 = 250;
pub const MPSL_DEFAULT_SKIP_WAIT_LFCLK_STARTED: u32 = 0;
pub const MPSL_HIGH_IRQ_PRIORITY: u32 = 0;
pub const MPSL_BUILD_REVISION_SIZE: u32 = 20;
pub const MPSL_RESERVED_PPI_CHANNELS: u32 = 3221749760;
pub const MPSL_TIMESLOT_LENGTH_MIN_US: u32 = 100;
pub const MPSL_TIMESLOT_LENGTH_MAX_US: u32 = 100000;
pub const MPSL_TIMESLOT_DISTANCE_MAX_US: u32 = 255999999;
pub const MPSL_TIMESLOT_EARLIEST_TIMEOUT_MAX_US: u32 = 255999999;
pub const MPSL_TIMESLOT_START_JITTER_US: u32 = 1;
pub const MPSL_TIMESLOT_EXTENSION_TIME_MIN_US: u32 = 200;
pub const MPSL_TIMESLOT_EXTENSION_PROCESSING_TIME_MAX_US: u32 = 25;
pub const MPSL_TIMESLOT_EXTENSION_MARGIN_MIN_US: u32 = 87;
pub const MPSL_TIMESLOT_CONTEXT_SIZE: u32 = 48;
pub const MPSL_TIMESLOT_CONTEXT_COUNT_MAX: u32 = 8;
pub const MPSL_TOTAL_NUM_OF_BLE_CHANNELS: u32 = 40;
pub const MPSL_TOTAL_NUM_OF_802154_CHANNELS: u32 = 16;
pub type bool_ = bool;
#[doc = "  Function prototype for the fault handler.\n\n @note The SoftDevice Controller will disable all interrupts prior to calling the\n       fault handler. The SoftDevice Controller will reset the chip if the\n       application returns from this function.\n\n * `file` - The filename where the assertion occurred.\n * `line` - The line number where the assertion occurred."]
pub type sdc_fault_handler_t =
    ::core::option::Option<unsafe extern "C" fn(file: *const crate::ctypes::c_char, line: u32)>;
#[doc = "  Function prototype for the SoftDevice Controller callback.\n\n  See also @ref sdc_enable()."]
pub type sdc_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
#[doc = " No configuration update."]
pub const sdc_cfg_type_SDC_CFG_TYPE_NONE: sdc_cfg_type = 0;
#[doc = " See @ref sdc_cfg_t::central_count."]
pub const sdc_cfg_type_SDC_CFG_TYPE_CENTRAL_COUNT: sdc_cfg_type = 1;
#[doc = " See @ref sdc_cfg_t::peripheral_count."]
pub const sdc_cfg_type_SDC_CFG_TYPE_PERIPHERAL_COUNT: sdc_cfg_type = 2;
#[doc = " See @ref sdc_cfg_t::buffer_cfg."]
pub const sdc_cfg_type_SDC_CFG_TYPE_BUFFER_CFG: sdc_cfg_type = 3;
#[doc = " See @ref sdc_cfg_t::event_length."]
pub const sdc_cfg_type_SDC_CFG_TYPE_EVENT_LENGTH: sdc_cfg_type = 4;
#[doc = " See @ref sdc_cfg_t::adv_count."]
pub const sdc_cfg_type_SDC_CFG_TYPE_ADV_COUNT: sdc_cfg_type = 5;
#[doc = " See @ref sdc_cfg_t::scan_buffer_cfg."]
pub const sdc_cfg_type_SDC_CFG_TYPE_SCAN_BUFFER_CFG: sdc_cfg_type = 6;
#[doc = " See @ref sdc_cfg_t::adv_buffer_cfg."]
pub const sdc_cfg_type_SDC_CFG_TYPE_ADV_BUFFER_CFG: sdc_cfg_type = 7;
#[doc = " See @ref sdc_cfg_t::periodic_adv_count."]
pub const sdc_cfg_type_SDC_CFG_TYPE_PERIODIC_ADV_COUNT: sdc_cfg_type = 8;
#[doc = " See @ref sdc_cfg_t::periodic_sync_count."]
pub const sdc_cfg_type_SDC_CFG_TYPE_PERIODIC_SYNC_COUNT: sdc_cfg_type = 9;
#[doc = " See @ref sdc_cfg_t::periodic_sync_buffer_cfg."]
pub const sdc_cfg_type_SDC_CFG_TYPE_PERIODIC_SYNC_BUFFER_CFG: sdc_cfg_type = 10;
#[doc = " See @ref sdc_cfg_t::periodic_adv_list_size."]
pub const sdc_cfg_type_SDC_CFG_TYPE_PERIODIC_ADV_LIST_SIZE: sdc_cfg_type = 11;
pub type sdc_cfg_type = crate::ctypes::c_uint;
#[doc = "  Role count."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_role_count_t {
    #[doc = "< Max number of concurrent roles."]
    pub count: u8,
}
#[test]
fn bindgen_test_layout_sdc_cfg_role_count_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_cfg_role_count_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_cfg_role_count_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_cfg_role_count_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_cfg_role_count_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_cfg_role_count_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_role_count_t),
            "::",
            stringify!(count)
        )
    );
}
#[doc = "  Buffer configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_buffer_cfg_t {
    #[doc = "< Link Layer TX packet size. Valid range: 27-251.\nDefault: @ref SDC_DEFAULT_TX_PACKET_SIZE."]
    pub tx_packet_size: u8,
    #[doc = "< Link Layer RX packet size. Valid range: 27-251.\nDefault: @ref SDC_DEFAULT_RX_PACKET_SIZE."]
    pub rx_packet_size: u8,
    #[doc = "< Link Layer TX packet count per link. Minimum of 1.\nDefault: @ref SDC_DEFAULT_TX_PACKET_COUNT."]
    pub tx_packet_count: u8,
    #[doc = "< Link Layer RX packet count per link. Minimum of 1.\nDefault: @ref SDC_DEFAULT_RX_PACKET_COUNT."]
    pub rx_packet_count: u8,
}
#[test]
fn bindgen_test_layout_sdc_cfg_buffer_cfg_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_cfg_buffer_cfg_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_cfg_buffer_cfg_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_cfg_buffer_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_cfg_buffer_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_cfg_buffer_cfg_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_buffer_cfg_t),
            "::",
            stringify!(tx_packet_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_size) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_buffer_cfg_t),
            "::",
            stringify!(rx_packet_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_packet_count) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_buffer_cfg_t),
            "::",
            stringify!(tx_packet_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_packet_count) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_buffer_cfg_t),
            "::",
            stringify!(rx_packet_count)
        )
    );
}
#[doc = "  Connection event length configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_event_length_t {
    #[doc = "< Maximum connection event length"]
    pub event_length_us: u32,
}
#[test]
fn bindgen_test_layout_sdc_cfg_event_length_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_cfg_event_length_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_cfg_event_length_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_cfg_event_length_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_cfg_event_length_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sdc_cfg_event_length_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_length_us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_event_length_t),
            "::",
            stringify!(event_length_us)
        )
    );
}
#[doc = "  Buffer count configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_buffer_count_t {
    #[doc = "< Number of buffers."]
    pub count: u8,
}
#[test]
fn bindgen_test_layout_sdc_cfg_buffer_count_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_cfg_buffer_count_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_cfg_buffer_count_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_cfg_buffer_count_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_cfg_buffer_count_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_cfg_buffer_count_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_buffer_count_t),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_cfg_adv_buffer_cfg_t {
    #[doc = " The maximum advertising data length that can be used by an advertiser\n\n If set to 31, the controller will support 31 bytes of advertising data and scan response data.\n Setting a value larger than 31 bytes is only useful when supporting extended advertising.\n\n Default: @ref SDC_DEFAULT_ADV_BUF_SIZE."]
    pub max_adv_data: u16,
}
#[test]
fn bindgen_test_layout_sdc_cfg_adv_buffer_cfg_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_cfg_adv_buffer_cfg_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_cfg_adv_buffer_cfg_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_cfg_adv_buffer_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_cfg_adv_buffer_cfg_t>(),
        2usize,
        concat!("Alignment of ", stringify!(sdc_cfg_adv_buffer_cfg_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_adv_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_adv_buffer_cfg_t),
            "::",
            stringify!(max_adv_data)
        )
    );
}
#[doc = "  SoftDevice Controller configuration."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union sdc_cfg_t {
    #[doc = " Max number of concurrent central connections.\n  Default: @ref SDC_DEFAULT_CENTRAL_COUNT."]
    pub central_count: sdc_cfg_role_count_t,
    #[doc = " Max number of concurrent peripheral connections.\n  Default: @ref SDC_DEFAULT_PERIPHERAL_COUNT."]
    pub peripheral_count: sdc_cfg_role_count_t,
    #[doc = " Configures the number and size of the data buffers available per link.\n  Default: See @ref sdc_cfg_buffer_cfg_t."]
    pub buffer_cfg: sdc_cfg_buffer_cfg_t,
    #[doc = " Max connection event length.\n   Default: @ref SDC_DEFAULT_EVENT_LENGTH_US."]
    pub event_length: sdc_cfg_event_length_t,
    #[doc = " Max number of concurrent advertisers.\n  Must be more than or equal to @ref sdc_cfg_t::periodic_adv_count.\n  Default: @ref SDC_DEFAULT_ADV_COUNT."]
    pub adv_count: sdc_cfg_role_count_t,
    #[doc = " Configures the maximum number of advertising reports available in the scanner.\n\n  The minimum allowed number of buffers is 2.\n\n  It is recommended to support at least three buffers,\n  otherwise the scan response report will likely not be generated.\n\n  Default: @ref SDC_DEFAULT_SCAN_BUFFER_COUNT."]
    pub scan_buffer_cfg: sdc_cfg_buffer_count_t,
    #[doc = " Configures the maximum advertising data per advertising set.\n  Default: See @ref sdc_cfg_adv_buffer_cfg_t."]
    pub adv_buffer_cfg: sdc_cfg_adv_buffer_cfg_t,
    #[doc = " Configures the maximum number of concurrent periodic advertisers.\n  Must be less than or equal to @ref sdc_cfg_t::adv_count.\n  Default: @ref SDC_DEFAULT_PERIODIC_ADV_COUNT."]
    pub periodic_adv_count: sdc_cfg_role_count_t,
    #[doc = " Configures the maximum number of concurrent synchronizations\n  to periodic advertisers.\n  Default: @ref SDC_DEFAULT_PERIODIC_SYNC_COUNT."]
    pub periodic_sync_count: sdc_cfg_role_count_t,
    #[doc = " Configures the maximum number of periodic advertising reports available\n  for each synchronization to a periodic advertiser.\n\n  Each synchronization to a periodic advertiser allocates its own buffer\n  pool.\n\n  The minimum allowed number of buffers is 2.\n\n  No reports for a new advertising event containing chained PDUs will be\n  enqueued until the host has emptied the previous event's buffers.\n\n  Default: @ref SDC_DEFAULT_PERIODIC_SYNC_BUFFER_COUNT."]
    pub periodic_sync_buffer_cfg: sdc_cfg_buffer_count_t,
    #[doc = " Configures the size of the periodic advertiser list.\n\n The maximum number of supported devices is 8.\n\n Default: @ref SDC_DEFAULT_PERIODIC_ADV_LIST_SIZE."]
    pub periodic_adv_list_size: u8,
}
#[test]
fn bindgen_test_layout_sdc_cfg_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_cfg_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_cfg_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_cfg_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sdc_cfg_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).central_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(central_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peripheral_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(peripheral_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer_cfg) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(sdc_cfg_t), "::", stringify!(buffer_cfg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(event_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_count) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(sdc_cfg_t), "::", stringify!(adv_count))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_buffer_cfg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(scan_buffer_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_buffer_cfg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(adv_buffer_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic_adv_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(periodic_adv_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic_sync_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(periodic_sync_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic_sync_buffer_cfg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(periodic_sync_buffer_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic_adv_list_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_cfg_t),
            "::",
            stringify!(periodic_adv_list_size)
        )
    );
}
extern "C" {
    #[doc = "  Initialize the SoftDevice Controller\n\n After this function is called, the application may use SoC APIs.\n\n * `fault_handler` - The fault handler will be executed when there is an\n                            internal error in the SoftDevice Controller.\n\n Returns 0            Success\n Returns -NRF_EINVAL  Invalid argument provided\n Returns -NRF_EPERM   Unable to initialize because\n                        - MPSL is not initialized\n                        - MPSL needs to be configured with a LFCLK accuracy\n                          of 500 ppm or better."]
    pub fn sdc_init(fault_handler: sdc_fault_handler_t) -> i32;
}
extern "C" {
    #[doc = "  Change or add a SoftDevice Controller configuration\n\n To change the default configuration, update @ref\n SDC_DEFAULT_RESOURCE_CFG_TAG. To create or update a new\n configuration, provide another resource_cfg_tag.\n\n @note The application can set config_type to @ref\n       SDC_CFG_TYPE_NONE to obtain the required memory size for the\n       current configuration in bytes.\n\n @note Resource configuration can only be performed prior to calling @ref\n       sdc_enable(). However, the current configuration may be\n       changed after enabling the SoftDevice Controller.\n\n * `config_tag` - Configuration tag.\n * `config_type` - Configuration type. See also @ref sdc_cfg_type.\n * `p_resource_cfg` - Configuration to be changed.\n\n @returns Required memory size for the current configuration in bytes.\n Returns -NRF_EOPNOTSUPP    Unsupported configuration.\n Returns -NRF_ENOMEM        Configuration required over 64 kB of RAM that is\nnot supported currently.\n Returns -NRF_EINVAL        Invalid argument provided.\n Returns -NRF_EPERM         This API was called after @ref sdc_enable()."]
    pub fn sdc_cfg_set(config_tag: u8, config_type: u8, p_resource_cfg: *const sdc_cfg_t) -> i32;
}
extern "C" {
    #[doc = "  Enable the SoftDevice Controller\n\n After this function is called, the application may utilize HCI APIs.\n\n * `callback` - The callback will be executed when HCI data or and HCI\n                      event is available. The callback will be executed in\n                      the same context as @ref mpsl_low_priority_process.\n                      See also @ref sdc_hci_get().\n * `p_mem` - Provide memory for the current resource configuration. If\n                      custom resource configurations are used, use the value\n                      returned from @ref sdc_cfg_set().\n\n Returns 0            Success\n Returns -NRF_EINVAL  Invalid argument provided\n Returns -NRF_EPERM   The entropy source is not configured. Call @ref sdc_rand_source_register() first."]
    pub fn sdc_enable(callback: sdc_callback_t, p_mem: *mut u8) -> i32;
}
extern "C" {
    #[doc = "  Disable the SoftDevice Controller\n\n This call is synchronous. After the SoftDevice Controller is disabled, Bluetooth LE\n functionality is no longer available.\n\n Returns 0 Success"]
    pub fn sdc_disable() -> i32;
}
extern "C" {
    #[doc = "  Obtain build revision string\n\n The application must provide a buffer that is at least @ref SDC_BUILD_REVISION_SIZE\n bytes long. The SoftDevice Controller will copy the build revision string to the provided buffer.\n\n * `p_build_revision` - Build revision.\n\n Returns 0            Success\n Returns -NRF_EINVAL  Invalid argument provided"]
    pub fn sdc_build_revision_get(p_build_revision: *mut u8) -> i32;
}
extern "C" {
    #[doc = "  Support Advertising State\n\n After this API is called, the controller will support the HCI commands\n and events related to the Advertising State.\n Only non-connectable advertising is supported. To support connectable\n advertising, call @ref sdc_support_peripheral().\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  Advertising state is not supported."]
    pub fn sdc_support_adv() -> i32;
}
extern "C" {
    #[doc = "  Support extended advertising\n\n After this API is called, the controller will support the HCI commands\n and events related to both legacy and extended advertising.\n\n To reduce the size of the final linked image, the application should\n call either @ref sdc_support_adv() or @ref sdc_support_ext_adv().\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  Extended advertising state is not supported."]
    pub fn sdc_support_ext_adv() -> i32;
}
extern "C" {
    #[doc = "  Support Peripheral role\n\n After this API is called, the controller will support the HCI commands\n and events related to the peripheral role.\n\n The application shall call either @ref sdc_support_adv() or\n @ref sdc_support_ext_adv() to be able to support connection\n establishment.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  Peripheral role is not supported."]
    pub fn sdc_support_peripheral() -> i32;
}
extern "C" {
    #[doc = "  Support Scanning state\n\n After this API is called, the controller will support the HCI commands\n and events related to the scanning state.\n\n To reduce the size of the final linked image, the application should\n not call both @ref sdc_support_scan() and @ref sdc_support_ext_scan().\n\n This API shall not be called together with\n @ref sdc_support_central() or @ref sdc_support_ext_central().\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  Scanning state is not supported."]
    pub fn sdc_support_scan() -> i32;
}
extern "C" {
    #[doc = "  Support scanning for extended advertising PDUs\n\n After this API is called, the controller will support the HCI commands\n and events related to both legacy and extended scanning.\n\n To reduce the size of the final linked image, the application should\n not call both @ref sdc_support_scan() and @ref sdc_support_ext_scan().\n\n This API shall not be called together with\n @ref sdc_support_central() or @ref sdc_support_ext_central().\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  Extended scanning state is not supported."]
    pub fn sdc_support_ext_scan() -> i32;
}
extern "C" {
    #[doc = "  Support Scanner, Initiator, and Central role\n\n After this API is called, the controller will support the HCI commands\n and events related to the scanner, initiator, and central role.\n\n To reduce the size of the final linked image, the application should\n not call both @ref sdc_support_central() and @ref sdc_support_ext_central().\n\n This API shall not be called together with\n @ref sdc_support_scan() or @ref sdc_support_ext_scan().\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  These features are not supported."]
    pub fn sdc_support_central() -> i32;
}
extern "C" {
    #[doc = "  Support Extended Scanner, Extended Initiator, and Central role\n\n After this API is called, the controller will support the HCI commands\n and events related to the extended scanner, initiator, and central role.\n\n To reduce the size of the final linked image, the application should\n not call both @ref sdc_support_central() and @ref sdc_support_ext_central().\n\n This API shall not be called together with\n @ref sdc_support_scan() or @ref sdc_support_ext_scan().\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  These features are not supported."]
    pub fn sdc_support_ext_central() -> i32;
}
extern "C" {
    #[doc = "  Support Data Length Extensions for a central device\n\n After this API is called, the controller will support data length extension in the central role.\n That is:\n  - DLE is marked supported in the LL Feature Exchange procedure.\n  - All DLE HCI APIs are supported. The controller replies with LL_LENGTH_RSP\n    when a LL_LENGTH_REQ is received.\n\n @note The application is required to call both @ref sdc_support_dle_central() and @ref sdc_support_dle_peripheral()\n       if both central and peripheral roles are supported.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  Data Length Extension or Central Role is not supported."]
    pub fn sdc_support_dle_central() -> i32;
}
extern "C" {
    #[doc = "  Support Data Length Extensions for a peripheral device\n\n After this API is called, the controller will support data length extension in the peripheral role.\n That is:\n  - DLE is marked supported in the LL Feature Exchange procedure.\n  - All DLE HCI APIs are supported. The controller replies with LL_LENGTH_RSP\n    when a LL_LENGTH_REQ is received.\n\n @note The application is required to call both @ref sdc_support_dle_central() and @ref sdc_support_dle_peripheral()\n       if both central and peripheral roles are supported.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  Data Length Extension or Peripheral Role is not supported."]
    pub fn sdc_support_dle_peripheral() -> i32;
}
extern "C" {
    #[doc = "  Support LE 2M PHY\n\n After this API is called, the controller will support LE 2M PHY. That is:\n  - The controller can use 2M PHY in both the connected and non-connected state.\n  - LE 2M PHY is marked supported in the LL Feature Exchange procedure.\n\n @note The application is required to call @ref sdc_support_phy_update_central() and/or @ref sdc_support_phy_update_peripheral()\n       to enable the PHY update procedure.\n\n Returns 0           Success\n Returns -NRF_EPERM  This API must be called before @ref sdc_cfg_set() or @ref sdc_enable()."]
    pub fn sdc_support_le_2m_phy() -> i32;
}
extern "C" {
    #[doc = "  Support LE Coded PHY\n\n After this API is called, the controller will support LE Coded PHY. That is:\n  - The controller can use LE Coded PHY in both the connected and non-connected state.\n  - LE Coded PHY is marked supported in the LL Feature Exchange procedure.\n\n @note The application is required to call @ref sdc_support_phy_update_central() and/or @ref sdc_support_phy_update_peripheral()\n       to enable the PHY update procedure.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Coded PHY is not supported."]
    pub fn sdc_support_le_coded_phy() -> i32;
}
extern "C" {
    #[doc = "  Support PHY Update Procedure for central role\n\n After this API is called, the controller will support PHY update procedure in central role. That is:\n  - All HCI APIs for obtaining or changing PHYs are supported for central role.\n\n @note The application is required to call both @ref sdc_support_phy_update_central() and @ref sdc_support_phy_update_peripheral()\n       if both central and peripheral roles are supported.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Coded PHY is not supported."]
    pub fn sdc_support_phy_update_central() -> i32;
}
extern "C" {
    #[doc = "  Support LE Coded PHY for peripheral role\n\n After this API is called, the controller will support PHY update procedure in peripheral role. That is:\n  - All HCI APIs for obtaining or changing PHYs are supported for peripheral role.\n\n @note The application is required to call both @ref sdc_support_phy_update_central() and @ref sdc_support_phy_update_peripheral()\n       if both central and peripheral roles are supported.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Coded PHY is not supported."]
    pub fn sdc_support_phy_update_peripheral() -> i32;
}
extern "C" {
    #[doc = "  Support LE Periodic Advertising in the Advertising state\n\n After this API is called, the controller will support the HCI commands\n related to the Periodic Advertising State.\n\n The application shall also call @ref sdc_support_ext_adv() to enable\n support for extended advertising before enabling support for periodic advertising.\n\n @note This API also enables support for ADI in periodic advertising packets.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Periodic advertising is not supported."]
    pub fn sdc_support_le_periodic_adv() -> i32;
}
extern "C" {
    #[doc = "  Support LE Periodic Advertising in the Synchronization state\n\n After this API is called, the controller will support the HCI commands\n related to the Synchronization State.\n\n The application shall also call @ref sdc_support_ext_scan() to enable\n support for scanning for periodic advertisers before enabling support for\n this feature.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Periodic advertising is not supported."]
    pub fn sdc_support_le_periodic_sync() -> i32;
}
extern "C" {
    #[doc = "  Support LE Power Control for central role\n\n After this API is called, the controller will support the HCI commands\n related to the LE Power Control.\n\n @note The application is required to call both @ref sdc_support_le_power_control_central() and @ref sdc_support_le_power_control_peripheral()\n       if both central and peripheral roles are supported.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Power Control is not supported."]
    pub fn sdc_support_le_power_control_central() -> i32;
}
extern "C" {
    #[doc = "  Support LE Power Control for peripheral role\n\n After this API is called, the controller will support the HCI commands\n related to the LE Power Control.\n\n @note The application is required to call both @ref sdc_support_le_power_control_central() and @ref sdc_support_le_power_control_peripheral()\n       if both central and peripheral roles are supported.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Power Control is not supported."]
    pub fn sdc_support_le_power_control_peripheral() -> i32;
}
extern "C" {
    #[doc = "  Support LE Connection CTE response for central role\n\n After this API is called, the controller will support the HCI commands\n related to the LE Connection CTE Response.\n\n @note The application is required to call both @ref sdc_support_le_conn_cte_rsp_central() and @ref sdc_support_le_conn_cte_rsp_peripheral()\n       if both central and peripheral roles are supported.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Connection CTE Response is not supported."]
    pub fn sdc_support_le_conn_cte_rsp_central() -> i32;
}
extern "C" {
    #[doc = "  Support LE Connection CTE response for peripheral role\n\n After this API is called, the controller will support the HCI commands\n related to the LE Connection CTE Response.\n\n @note The application is required to call both @ref sdc_support_le_conn_cte_rsp_central() and @ref sdc_support_le_conn_cte_rsp_peripheral()\n       if both central and peripheral roles are supported.\n\n Returns 0                Success\n Returns -NRF_EPERM       This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP  LE Connection CTE Response is not supported."]
    pub fn sdc_support_le_conn_cte_rsp_peripheral() -> i32;
}
extern "C" {
    #[doc = "  Support for sending periodic advertising sync transfers as central role\n\n @note The application is required to call both @ref sdc_support_periodic_adv_sync_transfer_sender_central()\n       and @ref sdc_support_periodic_adv_sync_transfer_sender_peripheral() if both central and peripheral roles are supported.\n\n Returns 0               Success\n Returns -NRF_EPERM      This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP Sending periodic advertising sync transfers is not supported."]
    pub fn sdc_support_periodic_adv_sync_transfer_sender_central() -> i32;
}
extern "C" {
    #[doc = "  Support for sending periodic advertising sync transfers as peripheral role\n\n @note The application is required to call both @ref sdc_support_periodic_adv_sync_transfer_sender_central()\n       and @ref sdc_support_periodic_adv_sync_transfer_sender_peripheral() if both central and peripheral roles are supported.\n\n Returns 0               Success\n Returns -NRF_EPERM      This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP Sending periodic advertising sync transfers is not supported."]
    pub fn sdc_support_periodic_adv_sync_transfer_sender_peripheral() -> i32;
}
extern "C" {
    #[doc = "  Support for receiving periodic advertising sync transfers as central role\n\n @note The application is required to call both @ref sdc_support_periodic_adv_sync_transfer_receiver_central()\n       and @ref sdc_support_periodic_adv_sync_transfer_receiver_peripheral() if both central and peripheral roles are supported.\n\n Returns 0               Success\n Returns -NRF_EPERM      This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP Receiving periodic advertising sync transfers is not supported."]
    pub fn sdc_support_periodic_adv_sync_transfer_receiver_central() -> i32;
}
extern "C" {
    #[doc = "  Support for receiving periodic advertising sync transfers as peripheral role\n\n @note The application is required to call both @ref sdc_support_periodic_adv_sync_transfer_receiver_central()\n       and @ref sdc_support_periodic_adv_sync_transfer_receiver_peripheral() if both central and peripheral roles are supported.\n\n Returns 0               Success\n Returns -NRF_EPERM      This API must be called before @ref sdc_cfg_set() or @ref sdc_enable().\n Returns -NRF_EOPNOTSUPP Receiving periodic advertising sync transfers is not supported."]
    pub fn sdc_support_periodic_adv_sync_transfer_receiver_peripheral() -> i32;
}
extern "C" {
    #[doc = "  Configure the coex advertising mode\n\n Configure how the advertiser behaves on denial of an advertising packet.\n The advertiser can be configured to carry on with the advertisement after the denial or\n to abort the advertising event, once an advertising packet gets denied.\n\n The default behavior is that the advertiser tries to carry on with the advertising event\n after the denial.\n\n @note Setting  * `adv_cont_on_denial` -  to True is not supported for the\n       @ref MPSL_COEX_1WIRE_GPIOTE_ID coex interface type.\n       Using the @ref MPSL_COEX_1WIRE_GPIOTE_ID coex interface without using this\n       API call with  * `adv_cont_on_denial` -  set to False will result in unexpected behavior.\n\n Returns 0                Success\n Returns -NRF_EOPNOTSUPP  The coexistence feature is not supported."]
    pub fn sdc_coex_adv_mode_configure(adv_cont_on_denial: bool_) -> i32;
}
extern "C" {
    #[doc = "  Support for setting the default radio TX power level\n\n This API sets the default power level for radio TX activity in the controller.\n\n The power level set will be equal to or less than the one requested, based on the values\n supported by the hardware used. Values outside the suported range will be set to the nearest\n supported value.\n\n  * `requested_power_level` -  represents the actual power level fed to the antenna.\n When a Front-End Module is used, gain values for the SoC and FEM are calculated\n automatically to guarantee the closest possible match to the value requested by the user\n at the RF output.\n\n * `requested_power_level` - The power level in dBm to use.\n\n Returns 0           Success\n Returns -NRF_EPERM  This API must be called before @ref sdc_enable()."]
    pub fn sdc_default_tx_power_set(requested_power_level: i8) -> i32;
}
#[doc = "  See @ref sdc_hci_cmd_cb_set_event_mask()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_SET_EVENT_MASK: sdc_hci_opcode_cb = 3073;
#[doc = "  See @ref sdc_hci_cmd_cb_reset()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_RESET: sdc_hci_opcode_cb = 3075;
#[doc = "  See @ref sdc_hci_cmd_cb_read_transmit_power_level()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_READ_TRANSMIT_POWER_LEVEL: sdc_hci_opcode_cb = 3117;
#[doc = "  See @ref sdc_hci_cmd_cb_set_controller_to_host_flow_control()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_SET_CONTROLLER_TO_HOST_FLOW_CONTROL: sdc_hci_opcode_cb = 3121;
#[doc = "  See @ref sdc_hci_cmd_cb_host_buffer_size()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_HOST_BUFFER_SIZE: sdc_hci_opcode_cb = 3123;
#[doc = "  See @ref sdc_hci_cmd_cb_host_number_of_completed_packets()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_HOST_NUMBER_OF_COMPLETED_PACKETS: sdc_hci_opcode_cb = 3125;
#[doc = "  See @ref sdc_hci_cmd_cb_set_event_mask_page_2()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_SET_EVENT_MASK_PAGE_2: sdc_hci_opcode_cb = 3171;
#[doc = "  See @ref sdc_hci_cmd_cb_read_authenticated_payload_timeout()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_READ_AUTHENTICATED_PAYLOAD_TIMEOUT: sdc_hci_opcode_cb = 3195;
#[doc = "  See @ref sdc_hci_cmd_cb_write_authenticated_payload_timeout()."]
pub const sdc_hci_opcode_cb_SDC_HCI_OPCODE_CMD_CB_WRITE_AUTHENTICATED_PAYLOAD_TIMEOUT: sdc_hci_opcode_cb = 3196;
#[doc = "  HCI CB OpCode Field values."]
pub type sdc_hci_opcode_cb = crate::ctypes::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cb_event_mask_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cb_event_mask_t() {
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cb_event_mask_t>(),
        7usize,
        concat!("Size of: ", stringify!(sdc_hci_cb_event_mask_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cb_event_mask_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cb_event_mask_t))
    );
}
impl sdc_hci_cb_event_mask_t {
    #[inline]
    pub fn inquiry_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inquiry_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inquiry_result_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inquiry_result_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disconnection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_disconnection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authentication_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_authentication_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_name_request_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_name_request_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encryption_change_event_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encryption_change_event_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn change_connection_link_key_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_change_connection_link_key_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_key_type_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_key_type_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_remote_supported_features_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_remote_supported_features_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_remote_version_information_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_remote_version_information_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qos_setup_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qos_setup_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hardware_error_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hardware_error_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flush_occurred_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flush_occurred_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn role_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_role_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mode_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_mode_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn return_link_keys_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_return_link_keys_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pin_code_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pin_code_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_key_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_key_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_key_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_key_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn loopback_command_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_loopback_command_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn data_buffer_overflow_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_data_buffer_overflow_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn max_slots_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_max_slots_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_clock_offset_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_clock_offset_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_packet_type_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_packet_type_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qos_violation_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qos_violation_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used30(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used30(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn page_scan_repetition_mode_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_page_scan_repetition_mode_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flow_specification_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_flow_specification_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inquiry_result_with_rssi_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inquiry_result_with_rssi_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_remote_extended_features_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_remote_extended_features_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn synchronous_connection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronous_connection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn synchronous_connection_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronous_connection_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sniff_subrating_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sniff_subrating_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_inquiry_result_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended_inquiry_result_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encryption_key_refresh_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encryption_key_refresh_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io_capability_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_io_capability_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn io_capability_response_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_io_capability_response_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user_confirmation_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_user_confirmation_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user_passkey_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_user_passkey_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_oob_data_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_oob_data_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn simple_pairing_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_simple_pairing_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn link_supervision_timeout_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_link_supervision_timeout_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_flush_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_flush_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn user_passkey_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_user_passkey_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn keypress_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_keypress_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_host_supported_features_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_host_supported_features_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_meta_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_meta_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inquiry_complete_event: u8,
        inquiry_result_event: u8,
        connection_complete_event: u8,
        connection_request_event: u8,
        disconnection_complete_event: u8,
        authentication_complete_event: u8,
        remote_name_request_complete_event: u8,
        encryption_change_event_v1: u8,
        change_connection_link_key_complete_event: u8,
        link_key_type_changed_event: u8,
        read_remote_supported_features_complete_event: u8,
        read_remote_version_information_complete_event: u8,
        qos_setup_complete_event: u8,
        hardware_error_event: u8,
        flush_occurred_event: u8,
        role_change_event: u8,
        mode_change_event: u8,
        return_link_keys_event: u8,
        pin_code_request_event: u8,
        link_key_request_event: u8,
        link_key_notification_event: u8,
        loopback_command_event: u8,
        data_buffer_overflow_event: u8,
        max_slots_change_event: u8,
        read_clock_offset_complete_event: u8,
        connection_packet_type_changed_event: u8,
        qos_violation_event: u8,
        previously_used30: u8,
        page_scan_repetition_mode_change_event: u8,
        flow_specification_complete_event: u8,
        inquiry_result_with_rssi_event: u8,
        read_remote_extended_features_complete_event: u8,
        synchronous_connection_complete_event: u8,
        synchronous_connection_changed_event: u8,
        sniff_subrating_event: u8,
        extended_inquiry_result_event: u8,
        encryption_key_refresh_complete_event: u8,
        io_capability_request_event: u8,
        io_capability_response_event: u8,
        user_confirmation_request_event: u8,
        user_passkey_request_event: u8,
        remote_oob_data_request_event: u8,
        simple_pairing_complete_event: u8,
        link_supervision_timeout_changed_event: u8,
        enhanced_flush_complete_event: u8,
        user_passkey_notification_event: u8,
        keypress_notification_event: u8,
        remote_host_supported_features_notification_event: u8,
        le_meta_event: u8,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inquiry_complete_event: u8 = unsafe { ::core::mem::transmute(inquiry_complete_event) };
            inquiry_complete_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let inquiry_result_event: u8 = unsafe { ::core::mem::transmute(inquiry_result_event) };
            inquiry_result_event as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let connection_complete_event: u8 = unsafe { ::core::mem::transmute(connection_complete_event) };
            connection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let connection_request_event: u8 = unsafe { ::core::mem::transmute(connection_request_event) };
            connection_request_event as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let disconnection_complete_event: u8 = unsafe { ::core::mem::transmute(disconnection_complete_event) };
            disconnection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let authentication_complete_event: u8 = unsafe { ::core::mem::transmute(authentication_complete_event) };
            authentication_complete_event as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let remote_name_request_complete_event: u8 =
                unsafe { ::core::mem::transmute(remote_name_request_complete_event) };
            remote_name_request_complete_event as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let encryption_change_event_v1: u8 = unsafe { ::core::mem::transmute(encryption_change_event_v1) };
            encryption_change_event_v1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let change_connection_link_key_complete_event: u8 =
                unsafe { ::core::mem::transmute(change_connection_link_key_complete_event) };
            change_connection_link_key_complete_event as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let link_key_type_changed_event: u8 = unsafe { ::core::mem::transmute(link_key_type_changed_event) };
            link_key_type_changed_event as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let read_remote_supported_features_complete_event: u8 =
                unsafe { ::core::mem::transmute(read_remote_supported_features_complete_event) };
            read_remote_supported_features_complete_event as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let read_remote_version_information_complete_event: u8 =
                unsafe { ::core::mem::transmute(read_remote_version_information_complete_event) };
            read_remote_version_information_complete_event as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let qos_setup_complete_event: u8 = unsafe { ::core::mem::transmute(qos_setup_complete_event) };
            qos_setup_complete_event as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hardware_error_event: u8 = unsafe { ::core::mem::transmute(hardware_error_event) };
            hardware_error_event as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let flush_occurred_event: u8 = unsafe { ::core::mem::transmute(flush_occurred_event) };
            flush_occurred_event as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let role_change_event: u8 = unsafe { ::core::mem::transmute(role_change_event) };
            role_change_event as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let mode_change_event: u8 = unsafe { ::core::mem::transmute(mode_change_event) };
            mode_change_event as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let return_link_keys_event: u8 = unsafe { ::core::mem::transmute(return_link_keys_event) };
            return_link_keys_event as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let pin_code_request_event: u8 = unsafe { ::core::mem::transmute(pin_code_request_event) };
            pin_code_request_event as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let link_key_request_event: u8 = unsafe { ::core::mem::transmute(link_key_request_event) };
            link_key_request_event as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let link_key_notification_event: u8 = unsafe { ::core::mem::transmute(link_key_notification_event) };
            link_key_notification_event as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let loopback_command_event: u8 = unsafe { ::core::mem::transmute(loopback_command_event) };
            loopback_command_event as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let data_buffer_overflow_event: u8 = unsafe { ::core::mem::transmute(data_buffer_overflow_event) };
            data_buffer_overflow_event as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let max_slots_change_event: u8 = unsafe { ::core::mem::transmute(max_slots_change_event) };
            max_slots_change_event as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let read_clock_offset_complete_event: u8 =
                unsafe { ::core::mem::transmute(read_clock_offset_complete_event) };
            read_clock_offset_complete_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let connection_packet_type_changed_event: u8 =
                unsafe { ::core::mem::transmute(connection_packet_type_changed_event) };
            connection_packet_type_changed_event as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let qos_violation_event: u8 = unsafe { ::core::mem::transmute(qos_violation_event) };
            qos_violation_event as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let previously_used30: u8 = unsafe { ::core::mem::transmute(previously_used30) };
            previously_used30 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let page_scan_repetition_mode_change_event: u8 =
                unsafe { ::core::mem::transmute(page_scan_repetition_mode_change_event) };
            page_scan_repetition_mode_change_event as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let flow_specification_complete_event: u8 =
                unsafe { ::core::mem::transmute(flow_specification_complete_event) };
            flow_specification_complete_event as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let inquiry_result_with_rssi_event: u8 = unsafe { ::core::mem::transmute(inquiry_result_with_rssi_event) };
            inquiry_result_with_rssi_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let read_remote_extended_features_complete_event: u8 =
                unsafe { ::core::mem::transmute(read_remote_extended_features_complete_event) };
            read_remote_extended_features_complete_event as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let synchronous_connection_complete_event: u8 =
                unsafe { ::core::mem::transmute(synchronous_connection_complete_event) };
            synchronous_connection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let synchronous_connection_changed_event: u8 =
                unsafe { ::core::mem::transmute(synchronous_connection_changed_event) };
            synchronous_connection_changed_event as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let sniff_subrating_event: u8 = unsafe { ::core::mem::transmute(sniff_subrating_event) };
            sniff_subrating_event as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let extended_inquiry_result_event: u8 = unsafe { ::core::mem::transmute(extended_inquiry_result_event) };
            extended_inquiry_result_event as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let encryption_key_refresh_complete_event: u8 =
                unsafe { ::core::mem::transmute(encryption_key_refresh_complete_event) };
            encryption_key_refresh_complete_event as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let io_capability_request_event: u8 = unsafe { ::core::mem::transmute(io_capability_request_event) };
            io_capability_request_event as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let io_capability_response_event: u8 = unsafe { ::core::mem::transmute(io_capability_response_event) };
            io_capability_response_event as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let user_confirmation_request_event: u8 =
                unsafe { ::core::mem::transmute(user_confirmation_request_event) };
            user_confirmation_request_event as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let user_passkey_request_event: u8 = unsafe { ::core::mem::transmute(user_passkey_request_event) };
            user_passkey_request_event as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let remote_oob_data_request_event: u8 = unsafe { ::core::mem::transmute(remote_oob_data_request_event) };
            remote_oob_data_request_event as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let simple_pairing_complete_event: u8 = unsafe { ::core::mem::transmute(simple_pairing_complete_event) };
            simple_pairing_complete_event as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let link_supervision_timeout_changed_event: u8 =
                unsafe { ::core::mem::transmute(link_supervision_timeout_changed_event) };
            link_supervision_timeout_changed_event as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let enhanced_flush_complete_event: u8 = unsafe { ::core::mem::transmute(enhanced_flush_complete_event) };
            enhanced_flush_complete_event as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let user_passkey_notification_event: u8 =
                unsafe { ::core::mem::transmute(user_passkey_notification_event) };
            user_passkey_notification_event as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let keypress_notification_event: u8 = unsafe { ::core::mem::transmute(keypress_notification_event) };
            keypress_notification_event as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let remote_host_supported_features_notification_event: u8 =
                unsafe { ::core::mem::transmute(remote_host_supported_features_notification_event) };
            remote_host_supported_features_notification_event as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let le_meta_event: u8 = unsafe { ::core::mem::transmute(le_meta_event) };
            le_meta_event as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cb_event_mask_page_2_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cb_event_mask_page_2_t() {
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cb_event_mask_page_2_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cb_event_mask_page_2_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cb_event_mask_page_2_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cb_event_mask_page_2_t))
    );
}
impl sdc_hci_cb_event_mask_page_2_t {
    #[inline]
    pub fn previously_used0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn number_of_completed_data_blocks_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_number_of_completed_data_blocks_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used9(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used9(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used10(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used10(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used11(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used11(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used12(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used12(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used13(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used13(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn triggered_clock_capture_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_triggered_clock_capture_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn synchronization_train_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronization_train_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn synchronization_train_received_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronization_train_received_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connectionless_peripheral_broadcast_receive_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_peripheral_broadcast_receive_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connectionless_peripheral_broadcast_timeout_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_peripheral_broadcast_timeout_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn truncated_page_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_truncated_page_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn peripheral_page_response_timeout_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peripheral_page_response_timeout_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connectionless_peripheral_broadcast_channel_map_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_peripheral_broadcast_channel_map_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn inquiry_response_notification_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_inquiry_response_notification_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authenticated_payload_timeout_expired_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_authenticated_payload_timeout_expired_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sam_status_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sam_status_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encryption_change_event_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encryption_change_event_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        previously_used0: u8,
        previously_used1: u8,
        previously_used2: u8,
        previously_used3: u8,
        previously_used4: u8,
        previously_used5: u8,
        previously_used6: u8,
        previously_used7: u8,
        number_of_completed_data_blocks_event: u8,
        previously_used9: u8,
        previously_used10: u8,
        previously_used11: u8,
        previously_used12: u8,
        previously_used13: u8,
        triggered_clock_capture_event: u8,
        synchronization_train_complete_event: u8,
        synchronization_train_received_event: u8,
        connectionless_peripheral_broadcast_receive_event: u8,
        connectionless_peripheral_broadcast_timeout_event: u8,
        truncated_page_complete_event: u8,
        peripheral_page_response_timeout_event: u8,
        connectionless_peripheral_broadcast_channel_map_change_event: u8,
        inquiry_response_notification_event: u8,
        authenticated_payload_timeout_expired_event: u8,
        sam_status_change_event: u8,
        encryption_change_event_v2: u8,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let previously_used0: u8 = unsafe { ::core::mem::transmute(previously_used0) };
            previously_used0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let previously_used1: u8 = unsafe { ::core::mem::transmute(previously_used1) };
            previously_used1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let previously_used2: u8 = unsafe { ::core::mem::transmute(previously_used2) };
            previously_used2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let previously_used3: u8 = unsafe { ::core::mem::transmute(previously_used3) };
            previously_used3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let previously_used4: u8 = unsafe { ::core::mem::transmute(previously_used4) };
            previously_used4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let previously_used5: u8 = unsafe { ::core::mem::transmute(previously_used5) };
            previously_used5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let previously_used6: u8 = unsafe { ::core::mem::transmute(previously_used6) };
            previously_used6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let previously_used7: u8 = unsafe { ::core::mem::transmute(previously_used7) };
            previously_used7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let number_of_completed_data_blocks_event: u8 =
                unsafe { ::core::mem::transmute(number_of_completed_data_blocks_event) };
            number_of_completed_data_blocks_event as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let previously_used9: u8 = unsafe { ::core::mem::transmute(previously_used9) };
            previously_used9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let previously_used10: u8 = unsafe { ::core::mem::transmute(previously_used10) };
            previously_used10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let previously_used11: u8 = unsafe { ::core::mem::transmute(previously_used11) };
            previously_used11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let previously_used12: u8 = unsafe { ::core::mem::transmute(previously_used12) };
            previously_used12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let previously_used13: u8 = unsafe { ::core::mem::transmute(previously_used13) };
            previously_used13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let triggered_clock_capture_event: u8 = unsafe { ::core::mem::transmute(triggered_clock_capture_event) };
            triggered_clock_capture_event as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let synchronization_train_complete_event: u8 =
                unsafe { ::core::mem::transmute(synchronization_train_complete_event) };
            synchronization_train_complete_event as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let synchronization_train_received_event: u8 =
                unsafe { ::core::mem::transmute(synchronization_train_received_event) };
            synchronization_train_received_event as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let connectionless_peripheral_broadcast_receive_event: u8 =
                unsafe { ::core::mem::transmute(connectionless_peripheral_broadcast_receive_event) };
            connectionless_peripheral_broadcast_receive_event as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let connectionless_peripheral_broadcast_timeout_event: u8 =
                unsafe { ::core::mem::transmute(connectionless_peripheral_broadcast_timeout_event) };
            connectionless_peripheral_broadcast_timeout_event as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let truncated_page_complete_event: u8 = unsafe { ::core::mem::transmute(truncated_page_complete_event) };
            truncated_page_complete_event as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let peripheral_page_response_timeout_event: u8 =
                unsafe { ::core::mem::transmute(peripheral_page_response_timeout_event) };
            peripheral_page_response_timeout_event as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let connectionless_peripheral_broadcast_channel_map_change_event: u8 =
                unsafe { ::core::mem::transmute(connectionless_peripheral_broadcast_channel_map_change_event) };
            connectionless_peripheral_broadcast_channel_map_change_event as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let inquiry_response_notification_event: u8 =
                unsafe { ::core::mem::transmute(inquiry_response_notification_event) };
            inquiry_response_notification_event as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let authenticated_payload_timeout_expired_event: u8 =
                unsafe { ::core::mem::transmute(authenticated_payload_timeout_expired_event) };
            authenticated_payload_timeout_expired_event as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let sam_status_change_event: u8 = unsafe { ::core::mem::transmute(sam_status_change_event) };
            sam_status_change_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let encryption_change_event_v2: u8 = unsafe { ::core::mem::transmute(encryption_change_event_v2) };
            encryption_change_event_v2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cb_host_number_of_completed_packets_array_params_t {
    pub conn_handle: u16,
    pub host_num_completed_packets: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cb_host_number_of_completed_packets_array_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cb_host_number_of_completed_packets_array_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cb_host_number_of_completed_packets_array_params_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cb_host_number_of_completed_packets_array_params_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cb_host_number_of_completed_packets_array_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cb_host_number_of_completed_packets_array_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cb_host_number_of_completed_packets_array_params_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_num_completed_packets) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cb_host_number_of_completed_packets_array_params_t),
            "::",
            stringify!(host_num_completed_packets)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_cb_set_event_mask_t {
    pub params: sdc_hci_cb_event_mask_t,
    pub raw: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_set_event_mask_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_set_event_mask_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_set_event_mask_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_cb_set_event_mask_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_set_event_mask_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_cb_set_event_mask_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_set_event_mask_t),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_set_event_mask_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_transmit_power_level_t {
    pub conn_handle: u16,
    pub type_: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_read_transmit_power_level_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_read_transmit_power_level_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_read_transmit_power_level_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_cb_read_transmit_power_level_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_read_transmit_power_level_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_cb_read_transmit_power_level_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_read_transmit_power_level_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_read_transmit_power_level_t),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_transmit_power_level_return_t {
    pub conn_handle: u16,
    pub tx_power_level: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_read_transmit_power_level_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_read_transmit_power_level_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_read_transmit_power_level_return_t>(),
        3usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_cb_read_transmit_power_level_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_read_transmit_power_level_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_cb_read_transmit_power_level_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_read_transmit_power_level_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_power_level) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_read_transmit_power_level_return_t),
            "::",
            stringify!(tx_power_level)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_set_controller_to_host_flow_control_t {
    pub flow_control_enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_set_controller_to_host_flow_control_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_set_controller_to_host_flow_control_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_set_controller_to_host_flow_control_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_cb_set_controller_to_host_flow_control_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_set_controller_to_host_flow_control_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_cb_set_controller_to_host_flow_control_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flow_control_enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_set_controller_to_host_flow_control_t),
            "::",
            stringify!(flow_control_enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_host_buffer_size_t {
    pub host_acl_data_packet_length: u16,
    pub host_sync_data_packet_length: u8,
    pub host_total_num_acl_data_packets: u16,
    pub host_total_num_sync_data_packets: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_host_buffer_size_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_host_buffer_size_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_host_buffer_size_t>(),
        7usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_cb_host_buffer_size_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_host_buffer_size_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_cb_host_buffer_size_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_acl_data_packet_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_host_buffer_size_t),
            "::",
            stringify!(host_acl_data_packet_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_sync_data_packet_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_host_buffer_size_t),
            "::",
            stringify!(host_sync_data_packet_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_total_num_acl_data_packets) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_host_buffer_size_t),
            "::",
            stringify!(host_total_num_acl_data_packets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).host_total_num_sync_data_packets) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_host_buffer_size_t),
            "::",
            stringify!(host_total_num_sync_data_packets)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_cb_host_number_of_completed_packets_t {
    pub num_handles: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_cb_host_number_of_completed_packets_array_params_t>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_host_number_of_completed_packets_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_host_number_of_completed_packets_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_host_number_of_completed_packets_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_cb_host_number_of_completed_packets_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_host_number_of_completed_packets_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_cb_host_number_of_completed_packets_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_handles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_host_number_of_completed_packets_t),
            "::",
            stringify!(num_handles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_params) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_host_number_of_completed_packets_t),
            "::",
            stringify!(array_params)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_cb_set_event_mask_page_2_t {
    pub params: sdc_hci_cb_event_mask_page_2_t,
    pub raw: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_set_event_mask_page_2_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_set_event_mask_page_2_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_set_event_mask_page_2_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_cb_set_event_mask_page_2_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_set_event_mask_page_2_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_cb_set_event_mask_page_2_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_set_event_mask_page_2_t),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_set_event_mask_page_2_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_authenticated_payload_timeout_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_read_authenticated_payload_timeout_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_read_authenticated_payload_timeout_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_read_authenticated_payload_timeout_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_read_authenticated_payload_timeout_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t {
    pub conn_handle: u16,
    pub authenticated_payload_timeout: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).authenticated_payload_timeout) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t),
            "::",
            stringify!(authenticated_payload_timeout)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_write_authenticated_payload_timeout_t {
    pub conn_handle: u16,
    pub authenticated_payload_timeout: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_write_authenticated_payload_timeout_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_write_authenticated_payload_timeout_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_write_authenticated_payload_timeout_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_write_authenticated_payload_timeout_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).authenticated_payload_timeout) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_t),
            "::",
            stringify!(authenticated_payload_timeout)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
extern "C" {
    #[doc = " @defgroup HCI_VS_API API\n @{\n/\n/** @brief Set Event Mask.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.1\n\n The HCI_Set_Event_Mask command is used to control which events are\n generated by the HCI for the Host. If the bit in the Event_Mask is set to a one,\n then the event associated with that bit will be enabled. For an LE Controller, the\n “LE Meta event” bit in the event_Mask shall enable or disable all LE events in\n the LE Meta event (see Section 7.7.65). The event mask allows the Host to\n control how much it is interrupted.\n\n The Controller shall ignore those bits which are reserved for future use or\n represent events which it does not support. If the Host sets any of these bits to\n 1, the Controller shall act as if they were set to 0.\n\n Event(s) generated (unless masked away):\n When the HCI_Set_Event_Mask command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_set_event_mask(p_params: *const sdc_hci_cmd_cb_set_event_mask_t) -> u8;
}
extern "C" {
    #[doc = "  Reset.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.2\n\n The HCI_Reset command will reset the Controller and the Link Manager on the\n BR/EDR Controller or the Link Layer on an LE Controller. If the Controller\n supports both BR/EDR and LE then the HCI_Reset command shall reset the\n Link Manager, Baseband and Link Layer. The HCI_Reset command shall not\n affect the used HCI transport layer since the HCI transport layers may have\n reset mechanisms of their own. After the reset is completed, the current\n operational state will be lost, the Controller will enter standby mode and the\n Controller will automatically revert to the default values for the parameters for\n which default values are defined in the specification.\n\n Note: The HCI_Reset command will not necessarily perform a hardware reset.\n This is implementation defined.\n\n The Host shall not send additional HCI commands before the\n HCI_Command_Complete event related to the HCI_Reset command has been\n received.\n\n Event(s) generated (unless masked away):\n When the reset has been performed, an HCI_Command_Complete event shall\n be generated.\n\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_reset() -> u8;
}
extern "C" {
    #[doc = "  Read Transmit Power Level.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.35\n\n This command reads the values for the TX_Power_Level parameter for the\n specified Connection_Handle. The Connection_Handle shall be a\n Connection_Handle for an ACL connection.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Transmit_Power_Level command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_read_transmit_power_level(
        p_params: *const sdc_hci_cmd_cb_read_transmit_power_level_t,
        p_return: *mut sdc_hci_cmd_cb_read_transmit_power_level_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Set Controller To Host Flow Control.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.38\n\n This command is used by the Host to turn flow control on or off for data and/or\n voice sent in the direction from the Controller to the Host. If flow control is turned\n off, the Host should not send the HCI_Host_Number_Of_Completed_Packets\n command. That command will be ignored by the Controller if it is sent by the\n Host and flow control is off. If flow control is turned on for HCI ACL Data packets\n and off for HCI Synchronous Data packets, HCI_Host_Number_Of_Completed_-\n Packets commands sent by the Host should only contain Connection_Handles\n for ACL connections. If flow control is turned off for HCI ACL Data packets and\n on for HCI Synchronous Data packets, HCI_Host_Number_Of_Completed_-\n Packets commands sent by the Host should only contain Connection_Handles\n for synchronous connections. If flow control is turned on for HCI ACL Data\n packets and HCI Synchronous Data packets, the Host will send HCI_Host_-\n Number_Of_Completed_Packets commands both for ACL connections and\n synchronous connections.\n\n The Flow_Control_Enable parameter shall only be changed if no connections\n exist.\n\n Event(s) generated (unless masked away):\n When the HCI_Set_Controller_To_Host_Flow_Control command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_set_controller_to_host_flow_control(
        p_params: *const sdc_hci_cmd_cb_set_controller_to_host_flow_control_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Host Buffer Size.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.39\n\n The HCI_Host_Buffer_Size command is used by the Host to notify the\n Controller about the maximum size of the data portion of HCI ACL and\n Synchronous Data packets sent from the Controller to the Host. The Controller\n shall segment the data to be transmitted from the Controller to the Host\n according to these sizes, so that the HCI Data packets will contain data with up\n to these sizes. The HCI_Host_Buffer_Size command also notifies the\n Controller about the total number of HCI ACL and Synchronous Data packets\n that can be stored in the data buffers of the Host. If flow control from the\n Controller to the Host is turned off, and the HCI_Host_Buffer_Size command\n has not been issued by the Host, this means that the Controller will send HCI\n Data packets to the Host with any lengths the Controller wants to use, and it is\n assumed that the data buffer sizes of the Host are unlimited. If flow control from\n the Controller to the Host is turned on, the HCI_Host_Buffer_Size command\n shall after a power-on or a reset always be sent by the Host before the first\n HCI_Host_Number_Of_Completed_Packets command is sent.\n\n The Set Controller To Host Flow Control command is used to turn flow control\n on or off. The Host_ACL_Data_Packet_Length command parameter will be\n used to determine the size of the L2CAP segments contained in ACL Data\n packets, which are transferred from the Controller to the Host. The\n Host_Synchronous_Data_Packet_Length command parameter is used to\n determine the maximum size of HCI Synchronous Data packets. Both the Host\n and the Controller shall support command and event packets, where the data\n portion (excluding header) contained in the packets is 255 octets in size.\n\n The Host_Total_Num_ACL_Data_Packets command parameter contains the\n total number of HCI ACL Data packets that can be stored in the data buffers of\n the Host. The Controller will determine how the buffers are to be divided\n between different Connection_Handles. The Host_Total_Num_Synchronous_\n Data_Packets command parameter gives the same information for HCI\n Synchronous Data packets.\n\n Note: The Host_ACL_Data_Packet_Length and Host_Synchronous_Data_-\n Packet_Length command parameters do not include the length of the HCI ACL\n Data packet header or the HCI Synchronous Data packet header respectively.\n\n Event(s) generated (unless masked away):\n When the HCI_Host_Buffer_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_host_buffer_size(p_params: *const sdc_hci_cmd_cb_host_buffer_size_t) -> u8;
}
extern "C" {
    #[doc = "  Host Number Of Completed Packets.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.40\n\n The HCI_Host_Number_Of_Completed_Packets command is used by the\n Host to indicate to the Controller the number of HCI Data packets that have\n been completed for each Connection_Handle since the previous HCI_Host_-\n Number_Of_Completed_Packets command was sent to the Controller. This\n means that the corresponding buffer space has been freed in the Host and is\n available for new packets to be sent. Based on this information, and the\n Host_Total_Num_ACL_Data_Packets and Host_Total_Num_Synchronous_-\n Data_Packets command parameters of the HCI_Host_Buffer_Size command,\n the Controller can determine for which Connection_Handles the following HCI\n Data packets should be sent to the Host. When the Host has completed one or\n more HCI Data packet(s) it shall send an HCI_Host_Number_Of_Completed_-\n Packets command to the Controller, until it finally reports that all pending HCI\n Data packets have been completed. The frequency at which this command is\n sent is manufacturer specific.\n\n The Set Controller To Host Flow Control command is used to turn flow control on\n or off. If flow control from the Controller to the Host is turned on, the HCI_Host_-\n Buffer_Size command shall always be sent by the Host after a power-on or a\n reset before the first HCI_Host_Number_Of_Completed_Packets command is\n sent.\n\n The HCI_Host_Number_Of_Completed_Packets command may be sent at\n any time by the Host when there is at least one connection, or if the Controller\n is in local loopback mode, independent of other commands. If the Host issues\n this command when neither of these cases applies, the Controller shall ignore\n it.\n\n Event(s) generated (unless masked away):\n Normally, no event is generated after the HCI_Host_Number_Of_Completed_-\n Packets command has completed. However, if the HCI_Host_Number_Of_-\n Completed_Packets command contains one or more invalid parameters, the\n Controller shall return an HCI_Command_Complete event containing the error\n code Invalid HCI Command Parameters (0x12). The normal flow control for\n commands is not used for this command.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_host_number_of_completed_packets(
        p_params: *const sdc_hci_cmd_cb_host_number_of_completed_packets_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Set Event Mask Page 2.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.69\n\n The HCI_Set_Event_Mask_Page_2 command is used to control which events\n are generated by the HCI for the Host. The Event_Mask_Page_2 is a logical\n extension to the Event_Mask parameter of the HCI_Set_Event_Mask\n command. If the bit in the Event_Mask_Page_2 is set to a one, then the event\n associated with that bit shall be enabled. The event mask allows the Host to\n control how much it is interrupted.\n\n The Controller shall ignore those bits which are reserved for future use or\n represent events which it does not support. If the Host sets any of these bits to\n 1, the Controller shall act as if they were set to 0.\n\n Event(s) generated (unless masked away):\n When the HCI_Set_Event_Mask_Page_2 command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_set_event_mask_page_2(p_params: *const sdc_hci_cmd_cb_set_event_mask_page_2_t) -> u8;
}
extern "C" {
    #[doc = "  Read Authenticated Payload Timeout.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.93\n\n This command reads the Authenticated_Payload_Timeout\n (authenticatedPayloadTO, see [Vol 2] Part B, Appendix B for BR/EDR\n connections and [Vol 6] Part B, Section 5.4 for LE connections) parameter in\n the Controller on the specified Connection_Handle.\n\n When the Connection_Handle identifies a BR/EDR synchronous connection,\n the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Authenticated_Payload_Timeout command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_read_authenticated_payload_timeout(
        p_params: *const sdc_hci_cmd_cb_read_authenticated_payload_timeout_t,
        p_return: *mut sdc_hci_cmd_cb_read_authenticated_payload_timeout_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Write Authenticated Payload Timeout.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.3.94\n\n This command writes the Authenticated_Payload_Timeout\n (authenticatedPayloadTO, see [Vol 2] Part B, Appendix B and [Vol 6] Part B,\n Section 5.4 for the LE connection) parameter in the Controller for the specified\n Connection_Handle.\n\n When the Connection_Handle identifies a BR/EDR ACL connection:\n • If the connection is in Sniff mode, the Authenticated_Payload_Timeout shall\n   be equal to or greater than Tsniff.\n • If the connection is in Sniff Subrating mode, the\n   Authenticated_Payload_Timeout shall be equal to or greater than\n   (max subrate)xTsniff.\n • If the connection is in Hold mode, the Authenticated_Payload_Timeout shall\n   be equal to or greater than the holdTO value.\n\n When the Connection_Handle identifies a BR/EDR synchronous connection,\n this command shall be rejected with the error code Command Disallowed\n (0x0C).\n\n When the Connection_Handle identifies an LE connection, the\n Authenticated_Payload_Timeout shall be equal to or greater than\n connInterval × connSubrateFactor × (1 + connPeripheralLatency).\n\n When the Connection_Handle is associated with an ACL connection, the Link\n Manager will use this parameter to determine when to use the LMP ping\n sequence.\n\n When the Connection_Handle is associated with an LE connection, the Link\n Layer will use this parameter to determine when to use the LE ping sequence.\n\n Event(s) generated (unless masked away):\n When the HCI_Write_Authenticated_Payload_Timeout command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_cb_write_authenticated_payload_timeout(
        p_params: *const sdc_hci_cmd_cb_write_authenticated_payload_timeout_t,
        p_return: *mut sdc_hci_cmd_cb_write_authenticated_payload_timeout_return_t,
    ) -> u8;
}
#[doc = "  See @ref sdc_hci_cmd_ip_read_local_version_information()."]
pub const sdc_hci_opcode_ip_SDC_HCI_OPCODE_CMD_IP_READ_LOCAL_VERSION_INFORMATION: sdc_hci_opcode_ip = 4097;
#[doc = "  See @ref sdc_hci_cmd_ip_read_local_supported_commands()."]
pub const sdc_hci_opcode_ip_SDC_HCI_OPCODE_CMD_IP_READ_LOCAL_SUPPORTED_COMMANDS: sdc_hci_opcode_ip = 4098;
#[doc = "  See @ref sdc_hci_cmd_ip_read_local_supported_features()."]
pub const sdc_hci_opcode_ip_SDC_HCI_OPCODE_CMD_IP_READ_LOCAL_SUPPORTED_FEATURES: sdc_hci_opcode_ip = 4099;
#[doc = "  See @ref sdc_hci_cmd_ip_read_bd_addr()."]
pub const sdc_hci_opcode_ip_SDC_HCI_OPCODE_CMD_IP_READ_BD_ADDR: sdc_hci_opcode_ip = 4105;
#[doc = "  HCI IP OpCode Field values."]
pub type sdc_hci_opcode_ip = crate::ctypes::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_ip_lmp_features_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_ip_lmp_features_t() {
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_ip_lmp_features_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_ip_lmp_features_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_ip_lmp_features_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_ip_lmp_features_t))
    );
}
impl sdc_hci_ip_lmp_features_t {
    #[inline]
    pub fn slot3_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot3_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slot5_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot5_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slot_offset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot_offset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn timing_accuracy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_timing_accuracy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn role_switch(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_role_switch(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hold_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hold_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sniff_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sniff_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_control_requests(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_power_control_requests(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cqddr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cqddr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sco_link(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sco_link(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hv2_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hv2_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hv3_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hv3_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn u_law_log_sync_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_u_law_log_sync_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn a_law_log_sync_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_a_law_log_sync_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cvsd_sync_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cvsd_sync_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn paging_param_negiotiation(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_paging_param_negiotiation(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn power_control(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_power_control(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transparent_sync_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_transparent_sync_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn flow_control_lag(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_flow_control_lag(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn broadcast_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_broadcast_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_data_rate_acl_2mbps_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_data_rate_acl_2mbps_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_data_rate_acl_3mbps_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_data_rate_acl_3mbps_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_inquiry_scan(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_inquiry_scan(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interlaced_inquiry_scan(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_interlaced_inquiry_scan(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn interlaced_page_scan(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_interlaced_page_scan(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rssi_with_inquiry_results(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rssi_with_inquiry_results(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_sco_link(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ext_sco_link(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ev4_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ev4_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ev5_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ev5_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn afh_capable_peripheral(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_afh_capable_peripheral(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn afh_classification_peripheral(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_afh_classification_peripheral(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn bdedr_not_supported(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_bdedr_not_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_supported(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_supported(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slot3_enhanced_data_rate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot3_enhanced_data_rate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slot5_enhanced_data_rate(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot5_enhanced_data_rate(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sniff_subrating(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sniff_subrating(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pause_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_pause_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn afh_capable_central(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_afh_capable_central(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn afh_classification_central(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_afh_classification_central(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_data_rate_esco_2mbps_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_data_rate_esco_2mbps_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_data_rate_esco_3mbps_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_data_rate_esco_3mbps_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slot3_enhanced_data_rate_esco(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slot3_enhanced_data_rate_esco(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_inquiry_response(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ext_inquiry_response(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn simultanious_le_and_bdedr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_simultanious_le_and_bdedr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn secure_simple_pairing(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_secure_simple_pairing(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn encapsulated_pdu(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_encapsulated_pdu(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn errorneous_data_reporting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_errorneous_data_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn non_flushable_packet_boundary(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_non_flushable_packet_boundary(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_link_supervision_timeout_changed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_link_supervision_timeout_changed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn variable_inquiry_tx_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_variable_inquiry_tx_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn enhanced_power_control(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_enhanced_power_control(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu8(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu8(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ext_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ext_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        slot3_packets: u8,
        slot5_packets: u8,
        encryption: u8,
        slot_offset: u8,
        timing_accuracy: u8,
        role_switch: u8,
        hold_mode: u8,
        sniff_mode: u8,
        previously_used: u8,
        power_control_requests: u8,
        cqddr: u8,
        sco_link: u8,
        hv2_packets: u8,
        hv3_packets: u8,
        u_law_log_sync_data: u8,
        a_law_log_sync_data: u8,
        cvsd_sync_data: u8,
        paging_param_negiotiation: u8,
        power_control: u8,
        transparent_sync_data: u8,
        flow_control_lag: u8,
        broadcast_encryption: u8,
        rfu1: u8,
        enhanced_data_rate_acl_2mbps_mode: u8,
        enhanced_data_rate_acl_3mbps_mode: u8,
        enhanced_inquiry_scan: u8,
        interlaced_inquiry_scan: u8,
        interlaced_page_scan: u8,
        rssi_with_inquiry_results: u8,
        ext_sco_link: u8,
        ev4_packets: u8,
        ev5_packets: u8,
        rfu2: u8,
        afh_capable_peripheral: u8,
        afh_classification_peripheral: u8,
        bdedr_not_supported: u8,
        le_supported: u8,
        slot3_enhanced_data_rate: u8,
        slot5_enhanced_data_rate: u8,
        sniff_subrating: u8,
        pause_encryption: u8,
        afh_capable_central: u8,
        afh_classification_central: u8,
        enhanced_data_rate_esco_2mbps_mode: u8,
        enhanced_data_rate_esco_3mbps_mode: u8,
        slot3_enhanced_data_rate_esco: u8,
        ext_inquiry_response: u8,
        simultanious_le_and_bdedr: u8,
        rfu3: u8,
        secure_simple_pairing: u8,
        encapsulated_pdu: u8,
        errorneous_data_reporting: u8,
        non_flushable_packet_boundary: u8,
        rfu4: u8,
        hci_link_supervision_timeout_changed_event: u8,
        variable_inquiry_tx_power_level: u8,
        enhanced_power_control: u8,
        rfu5: u8,
        rfu6: u8,
        rfu7: u8,
        rfu8: u8,
        ext_features: u8,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let slot3_packets: u8 = unsafe { ::core::mem::transmute(slot3_packets) };
            slot3_packets as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let slot5_packets: u8 = unsafe { ::core::mem::transmute(slot5_packets) };
            slot5_packets as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let encryption: u8 = unsafe { ::core::mem::transmute(encryption) };
            encryption as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let slot_offset: u8 = unsafe { ::core::mem::transmute(slot_offset) };
            slot_offset as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let timing_accuracy: u8 = unsafe { ::core::mem::transmute(timing_accuracy) };
            timing_accuracy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let role_switch: u8 = unsafe { ::core::mem::transmute(role_switch) };
            role_switch as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let hold_mode: u8 = unsafe { ::core::mem::transmute(hold_mode) };
            hold_mode as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let sniff_mode: u8 = unsafe { ::core::mem::transmute(sniff_mode) };
            sniff_mode as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let previously_used: u8 = unsafe { ::core::mem::transmute(previously_used) };
            previously_used as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let power_control_requests: u8 = unsafe { ::core::mem::transmute(power_control_requests) };
            power_control_requests as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let cqddr: u8 = unsafe { ::core::mem::transmute(cqddr) };
            cqddr as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let sco_link: u8 = unsafe { ::core::mem::transmute(sco_link) };
            sco_link as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let hv2_packets: u8 = unsafe { ::core::mem::transmute(hv2_packets) };
            hv2_packets as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let hv3_packets: u8 = unsafe { ::core::mem::transmute(hv3_packets) };
            hv3_packets as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let u_law_log_sync_data: u8 = unsafe { ::core::mem::transmute(u_law_log_sync_data) };
            u_law_log_sync_data as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let a_law_log_sync_data: u8 = unsafe { ::core::mem::transmute(a_law_log_sync_data) };
            a_law_log_sync_data as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let cvsd_sync_data: u8 = unsafe { ::core::mem::transmute(cvsd_sync_data) };
            cvsd_sync_data as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let paging_param_negiotiation: u8 = unsafe { ::core::mem::transmute(paging_param_negiotiation) };
            paging_param_negiotiation as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let power_control: u8 = unsafe { ::core::mem::transmute(power_control) };
            power_control as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let transparent_sync_data: u8 = unsafe { ::core::mem::transmute(transparent_sync_data) };
            transparent_sync_data as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let flow_control_lag: u8 = unsafe { ::core::mem::transmute(flow_control_lag) };
            flow_control_lag as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let broadcast_encryption: u8 = unsafe { ::core::mem::transmute(broadcast_encryption) };
            broadcast_encryption as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let rfu1: u8 = unsafe { ::core::mem::transmute(rfu1) };
            rfu1 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let enhanced_data_rate_acl_2mbps_mode: u8 =
                unsafe { ::core::mem::transmute(enhanced_data_rate_acl_2mbps_mode) };
            enhanced_data_rate_acl_2mbps_mode as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let enhanced_data_rate_acl_3mbps_mode: u8 =
                unsafe { ::core::mem::transmute(enhanced_data_rate_acl_3mbps_mode) };
            enhanced_data_rate_acl_3mbps_mode as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let enhanced_inquiry_scan: u8 = unsafe { ::core::mem::transmute(enhanced_inquiry_scan) };
            enhanced_inquiry_scan as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let interlaced_inquiry_scan: u8 = unsafe { ::core::mem::transmute(interlaced_inquiry_scan) };
            interlaced_inquiry_scan as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let interlaced_page_scan: u8 = unsafe { ::core::mem::transmute(interlaced_page_scan) };
            interlaced_page_scan as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let rssi_with_inquiry_results: u8 = unsafe { ::core::mem::transmute(rssi_with_inquiry_results) };
            rssi_with_inquiry_results as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ext_sco_link: u8 = unsafe { ::core::mem::transmute(ext_sco_link) };
            ext_sco_link as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let ev4_packets: u8 = unsafe { ::core::mem::transmute(ev4_packets) };
            ev4_packets as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let ev5_packets: u8 = unsafe { ::core::mem::transmute(ev5_packets) };
            ev5_packets as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let rfu2: u8 = unsafe { ::core::mem::transmute(rfu2) };
            rfu2 as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let afh_capable_peripheral: u8 = unsafe { ::core::mem::transmute(afh_capable_peripheral) };
            afh_capable_peripheral as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let afh_classification_peripheral: u8 = unsafe { ::core::mem::transmute(afh_classification_peripheral) };
            afh_classification_peripheral as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let bdedr_not_supported: u8 = unsafe { ::core::mem::transmute(bdedr_not_supported) };
            bdedr_not_supported as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let le_supported: u8 = unsafe { ::core::mem::transmute(le_supported) };
            le_supported as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let slot3_enhanced_data_rate: u8 = unsafe { ::core::mem::transmute(slot3_enhanced_data_rate) };
            slot3_enhanced_data_rate as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let slot5_enhanced_data_rate: u8 = unsafe { ::core::mem::transmute(slot5_enhanced_data_rate) };
            slot5_enhanced_data_rate as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let sniff_subrating: u8 = unsafe { ::core::mem::transmute(sniff_subrating) };
            sniff_subrating as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let pause_encryption: u8 = unsafe { ::core::mem::transmute(pause_encryption) };
            pause_encryption as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let afh_capable_central: u8 = unsafe { ::core::mem::transmute(afh_capable_central) };
            afh_capable_central as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let afh_classification_central: u8 = unsafe { ::core::mem::transmute(afh_classification_central) };
            afh_classification_central as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let enhanced_data_rate_esco_2mbps_mode: u8 =
                unsafe { ::core::mem::transmute(enhanced_data_rate_esco_2mbps_mode) };
            enhanced_data_rate_esco_2mbps_mode as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let enhanced_data_rate_esco_3mbps_mode: u8 =
                unsafe { ::core::mem::transmute(enhanced_data_rate_esco_3mbps_mode) };
            enhanced_data_rate_esco_3mbps_mode as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let slot3_enhanced_data_rate_esco: u8 = unsafe { ::core::mem::transmute(slot3_enhanced_data_rate_esco) };
            slot3_enhanced_data_rate_esco as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let ext_inquiry_response: u8 = unsafe { ::core::mem::transmute(ext_inquiry_response) };
            ext_inquiry_response as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let simultanious_le_and_bdedr: u8 = unsafe { ::core::mem::transmute(simultanious_le_and_bdedr) };
            simultanious_le_and_bdedr as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let rfu3: u8 = unsafe { ::core::mem::transmute(rfu3) };
            rfu3 as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let secure_simple_pairing: u8 = unsafe { ::core::mem::transmute(secure_simple_pairing) };
            secure_simple_pairing as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let encapsulated_pdu: u8 = unsafe { ::core::mem::transmute(encapsulated_pdu) };
            encapsulated_pdu as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let errorneous_data_reporting: u8 = unsafe { ::core::mem::transmute(errorneous_data_reporting) };
            errorneous_data_reporting as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let non_flushable_packet_boundary: u8 = unsafe { ::core::mem::transmute(non_flushable_packet_boundary) };
            non_flushable_packet_boundary as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let rfu4: u8 = unsafe { ::core::mem::transmute(rfu4) };
            rfu4 as u64
        });
        __bindgen_bitfield_unit.set(56usize, 1u8, {
            let hci_link_supervision_timeout_changed_event: u8 =
                unsafe { ::core::mem::transmute(hci_link_supervision_timeout_changed_event) };
            hci_link_supervision_timeout_changed_event as u64
        });
        __bindgen_bitfield_unit.set(57usize, 1u8, {
            let variable_inquiry_tx_power_level: u8 =
                unsafe { ::core::mem::transmute(variable_inquiry_tx_power_level) };
            variable_inquiry_tx_power_level as u64
        });
        __bindgen_bitfield_unit.set(58usize, 1u8, {
            let enhanced_power_control: u8 = unsafe { ::core::mem::transmute(enhanced_power_control) };
            enhanced_power_control as u64
        });
        __bindgen_bitfield_unit.set(59usize, 1u8, {
            let rfu5: u8 = unsafe { ::core::mem::transmute(rfu5) };
            rfu5 as u64
        });
        __bindgen_bitfield_unit.set(60usize, 1u8, {
            let rfu6: u8 = unsafe { ::core::mem::transmute(rfu6) };
            rfu6 as u64
        });
        __bindgen_bitfield_unit.set(61usize, 1u8, {
            let rfu7: u8 = unsafe { ::core::mem::transmute(rfu7) };
            rfu7 as u64
        });
        __bindgen_bitfield_unit.set(62usize, 1u8, {
            let rfu8: u8 = unsafe { ::core::mem::transmute(rfu8) };
            rfu8 as u64
        });
        __bindgen_bitfield_unit.set(63usize, 1u8, {
            let ext_features: u8 = unsafe { ::core::mem::transmute(ext_features) };
            ext_features as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_ip_supported_commands_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 47usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_ip_supported_commands_t() {
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_ip_supported_commands_t>(),
        47usize,
        concat!("Size of: ", stringify!(sdc_hci_ip_supported_commands_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_ip_supported_commands_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_ip_supported_commands_t))
    );
}
impl sdc_hci_ip_supported_commands_t {
    #[inline]
    pub fn hci_inquiry(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_inquiry(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_inquiry_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_inquiry_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_periodic_inquiry_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_periodic_inquiry_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_exit_periodic_inquiry_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_exit_periodic_inquiry_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_create_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_create_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_disconnect(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_disconnect(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_0_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_0_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_create_connection_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_create_connection_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_accept_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_accept_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_reject_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_reject_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_link_key_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_link_key_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_link_key_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_link_key_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_pin_code_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_pin_code_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_pin_code_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_pin_code_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_change_connection_packet_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_change_connection_packet_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_authentication_requested(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_authentication_requested(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_connection_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_connection_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_change_connection_link_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_change_connection_link_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_link_key_selection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_link_key_selection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_remote_name_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_name_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_remote_name_request_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_name_request_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_remote_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_remote_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_remote_extended_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_remote_extended_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_remote_version_information(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_remote_version_information(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_clock_offset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_clock_offset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_lmp_handle(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_lmp_handle(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_3_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_3_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_3_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_3_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_3_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_3_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_3_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_4_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_4_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_hold_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_hold_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_sniff_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_sniff_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_exit_sniff_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_exit_sniff_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_4_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_4_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_4_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_4_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_qos_setup(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_qos_setup(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_role_discovery(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_role_discovery(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_switch_role(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_switch_role(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_link_policy_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_link_policy_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_link_policy_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_link_policy_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_default_link_policy_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_default_link_policy_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_default_link_policy_settings(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_default_link_policy_settings(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_flow_specification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_flow_specification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_event_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_event_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_reset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_reset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_event_filter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_event_filter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_flush(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_flush(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_pin_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_pin_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_pin_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_pin_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_6_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_6_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_stored_link_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_stored_link_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_stored_link_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_stored_link_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_delete_stored_link_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_delete_stored_link_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_local_name(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(56usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_local_name(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(56usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_name(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(57usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_name(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(57usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_connection_accept_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(58usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_connection_accept_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(58usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_connection_accept_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(59usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_connection_accept_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(59usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_page_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(60usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_page_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(60usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_page_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(61usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_page_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(61usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_scan_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(62usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_scan_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(62usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_scan_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(63usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_scan_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(63usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_page_scan_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(64usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_page_scan_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(64usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_page_scan_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(65usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_page_scan_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(65usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_inquiry_scan_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(66usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_inquiry_scan_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(66usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_inquiry_scan_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(67usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_inquiry_scan_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(67usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_authentication_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(68usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_authentication_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(68usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_authentication_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(69usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_authentication_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(69usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_8_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(70usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_8_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(70usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_8_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(71usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_8_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(71usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_class_of_device(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(72usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_class_of_device(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(72usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_class_of_device(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(73usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_class_of_device(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(73usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_voice_setting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(74usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_voice_setting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(74usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_voice_setting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(75usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_voice_setting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(75usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_automatic_flush_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(76usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_automatic_flush_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(76usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_automatic_flush_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(77usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_automatic_flush_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(77usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_num_broadcast_retransmissions(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(78usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_num_broadcast_retransmissions(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(78usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_num_broadcast_retransmissions(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(79usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_num_broadcast_retransmissions(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(79usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_hold_mode_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(80usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_hold_mode_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(80usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_hold_mode_activity(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(81usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_hold_mode_activity(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(81usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(82usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(82usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_synchronous_flow_control_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(83usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_synchronous_flow_control_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(83usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_synchronous_flow_control_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(84usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_synchronous_flow_control_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(84usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_controller_to_host_flow_control(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(85usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_controller_to_host_flow_control(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(85usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_host_buffer_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(86usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_host_buffer_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(86usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_host_number_of_completed_packets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(87usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_host_number_of_completed_packets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(87usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_link_supervision_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(88usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_link_supervision_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(88usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_link_supervision_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(89usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_link_supervision_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(89usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_number_of_supported_iac(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(90usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_number_of_supported_iac(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(90usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_current_iac_lap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(91usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_current_iac_lap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(91usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_current_iac_lap(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(92usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_current_iac_lap(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(92usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_11_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(93usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_11_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(93usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_11_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(94usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_11_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(94usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_11_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(95usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_11_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(95usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_12_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(96usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_12_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(96usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_afh_host_channel_classification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(97usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_afh_host_channel_classification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(97usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_12_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(98usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_12_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(98usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_12_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(99usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_12_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(99usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_inquiry_scan_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(100usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_inquiry_scan_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(100usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_inquiry_scan_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(101usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_inquiry_scan_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(101usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_inquiry_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(102usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_inquiry_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(102usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_inquiry_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(103usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_inquiry_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(103usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_page_scan_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(104usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_page_scan_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(104usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_page_scan_type(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(105usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_page_scan_type(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(105usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_afh_channel_assessment_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(106usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_afh_channel_assessment_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(106usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_afh_channel_assessment_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(107usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_afh_channel_assessment_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(107usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_13_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(108usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_13_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(108usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_13_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(109usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_13_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(109usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_13_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(110usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_13_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(110usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_13_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(111usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_13_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(111usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_14_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(112usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_14_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(112usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_14_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(113usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_14_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(113usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_14_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(114usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_14_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(114usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_version_information(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(115usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_version_information(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(115usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_14_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(116usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_14_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(116usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(117usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(117usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_extended_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(118usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_extended_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(118usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_buffer_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(119usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_buffer_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(119usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_15_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(120usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_15_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(120usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_bd_addr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(121usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_bd_addr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(121usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_failed_contact_counter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(122usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_failed_contact_counter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(122usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_reset_failed_contact_counter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(123usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_reset_failed_contact_counter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(123usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_link_quality(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(124usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_link_quality(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(124usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_rssi(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(125usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_rssi(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(125usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_afh_channel_map(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(126usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_afh_channel_map(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(126usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_clock(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(127usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_clock(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(127usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_loopback_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(128usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_loopback_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(128usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_loopback_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(129usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_loopback_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(129usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_enable_device_under_test_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(130usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_enable_device_under_test_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(130usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_setup_synchronous_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(131usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_setup_synchronous_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(131usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_accept_synchronous_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(132usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_accept_synchronous_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(132usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_reject_synchronous_connection_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(133usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_reject_synchronous_connection_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(133usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_16_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(134usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_16_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(134usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_16_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(135usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_16_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(135usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_extended_inquiry_response(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(136usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_extended_inquiry_response(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(136usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_extended_inquiry_response(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(137usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_extended_inquiry_response(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(137usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_refresh_encryption_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(138usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_refresh_encryption_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(138usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_17_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(139usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_17_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(139usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_sniff_subrating(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(140usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_sniff_subrating(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(140usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_simple_pairing_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(141usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_simple_pairing_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(141usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_simple_pairing_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(142usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_simple_pairing_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(142usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_oob_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(143usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_oob_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(143usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_inquiry_response_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(144usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_inquiry_response_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(144usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_inquiry_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(145usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_inquiry_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(145usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_default_erroneous_data_reporting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(146usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_default_erroneous_data_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(146usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_default_erroneous_data_reporting(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(147usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_default_erroneous_data_reporting(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(147usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_18_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(148usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_18_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(148usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_18_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(149usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_18_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(149usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_18_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(150usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_18_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(150usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_io_capability_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(151usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_io_capability_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(151usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_user_confirmation_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(152usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_user_confirmation_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(152usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_user_confirmation_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(153usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_user_confirmation_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(153usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_user_passkey_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(154usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_user_passkey_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(154usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_user_passkey_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(155usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_user_passkey_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(155usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_remote_oob_data_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(156usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_oob_data_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(156usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_simple_pairing_debug_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(157usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_simple_pairing_debug_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(157usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_enhanced_flush(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(158usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_enhanced_flush(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(158usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_remote_oob_data_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(159usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_oob_data_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(159usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_20_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(160usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_20_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(160usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_20_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(161usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_20_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(161usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_send_keypress_notification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(162usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_send_keypress_notification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(162usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_io_capability_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(163usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_io_capability_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(163usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_encryption_key_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(164usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_encryption_key_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(164usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_20_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(165usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_20_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(165usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_20_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(166usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_20_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(166usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_20_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(167usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_20_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(167usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_21_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(168usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(168usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_21_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(169usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(169usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_21_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(170usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(170usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_21_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(171usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(171usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_21_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(172usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(172usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_21_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(173usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(173usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_21_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(174usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(174usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_21_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(175usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_21_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(175usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_22_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(176usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(176usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_22_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(177usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(177usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_event_mask_page_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(178usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_event_mask_page_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(178usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_22_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(179usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(179usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_22_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(180usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(180usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_22_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(181usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(181usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_22_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(182usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(182usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_22_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(183usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_22_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(183usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_flow_control_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(184usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_flow_control_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(184usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_flow_control_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(185usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_flow_control_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(185usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_data_block_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(186usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_data_block_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(186usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_23_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(187usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_23_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(187usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_23_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(188usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_23_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(188usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_23_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(189usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_23_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(189usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_23_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(190usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_23_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(190usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_23_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(191usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_23_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(191usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_enhanced_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(192usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_enhanced_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(192usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_24_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(193usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_24_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(193usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_24_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(194usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_24_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(194usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_24_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(195usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_24_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(195usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn previously_used_24_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(196usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_previously_used_24_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(196usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_le_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(197usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_le_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(197usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_le_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(198usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_le_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(198usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_24_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(199usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_24_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(199usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_event_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(200usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_event_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(200usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_buffer_size_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(201usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_buffer_size_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(201usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_local_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(202usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_local_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(202usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_25_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(203usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_25_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(203usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_random_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(204usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_random_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(204usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_advertising_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(205usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_advertising_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(205usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_advertising_physical_channel_tx_power(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(206usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_advertising_physical_channel_tx_power(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(206usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_advertising_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(207usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_advertising_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(207usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_scan_response_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(208usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_scan_response_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(208usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_advertising_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(209usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_advertising_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(209usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_scan_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(210usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_scan_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(210usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_scan_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(211usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_scan_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(211usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_create_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(212usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(212usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_create_connection_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(213usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_connection_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(213usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_filter_accept_list_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(214usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_filter_accept_list_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(214usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_clear_filter_accept_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(215usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_filter_accept_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(215usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_add_device_to_filter_accept_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(216usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_add_device_to_filter_accept_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(216usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_remove_device_from_filter_accept_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(217usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_device_from_filter_accept_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(217usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_connection_update(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(218usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_connection_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(218usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_host_channel_classification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(219usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_host_channel_classification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(219usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_channel_map(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(220usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_channel_map(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(220usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_remote_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(221usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_remote_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(221usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_encrypt(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(222usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_encrypt(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(222usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_rand(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(223usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_rand(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(223usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_enable_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(224usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_enable_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(224usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_long_term_key_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(225usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_long_term_key_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(225usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_long_term_key_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(226usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_long_term_key_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(226usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_supported_states(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(227usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_supported_states(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(227usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_receiver_test_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(228usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_receiver_test_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(228usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_transmitter_test_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(229usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_transmitter_test_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(229usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_test_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(230usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_test_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(230usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_28_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(231usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_28_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(231usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_29_0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(232usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_29_0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(232usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_29_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(233usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_29_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(233usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_29_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(234usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_29_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(234usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_enhanced_setup_synchronous_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(235usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_enhanced_setup_synchronous_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(235usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_enhanced_accept_synchronous_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(236usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_enhanced_accept_synchronous_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(236usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_supported_codecs(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(237usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_codecs(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(237usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_mws_channel_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(238usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_channel_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(238usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_external_frame_configuration(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(239usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_external_frame_configuration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(239usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_mws_signaling(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(240usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_signaling(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(240usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_mws_transport_layer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(241usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_transport_layer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(241usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_mws_scan_frequency_table(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(242usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_scan_frequency_table(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(242usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_get_mws_transport_layer_configuration(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(243usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_get_mws_transport_layer_configuration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(243usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_mws_pattern_configuration(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(244usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_mws_pattern_configuration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(244usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_triggered_clock_capture(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(245usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_triggered_clock_capture(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(245usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_truncated_page(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(246usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_truncated_page(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(246usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_truncated_page_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(247usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_truncated_page_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(247usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_connectionless_peripheral_broadcast(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(248usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_connectionless_peripheral_broadcast(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(248usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_connectionless_peripheral_broadcast_receive(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(249usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_connectionless_peripheral_broadcast_receive(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(249usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_start_synchronization_train(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(250usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_start_synchronization_train(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(250usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_receive_synchronization_train(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(251usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_receive_synchronization_train(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(251usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_reserved_lt_addr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(252usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_reserved_lt_addr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(252usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_delete_reserved_lt_addr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(253usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_delete_reserved_lt_addr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(253usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_connectionless_peripheral_broadcast_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(254usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_connectionless_peripheral_broadcast_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(254usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_synchronization_train_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(255usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_synchronization_train_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(255usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_synchronization_train_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(256usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_synchronization_train_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(256usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_remote_oob_extended_data_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(257usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_remote_oob_extended_data_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(257usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_secure_connections_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(258usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_secure_connections_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(258usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_secure_connections_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(259usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_secure_connections_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(259usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_authenticated_payload_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(260usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_authenticated_payload_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(260usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_authenticated_payload_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(261usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_authenticated_payload_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(261usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_oob_extended_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(262usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_oob_extended_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(262usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_secure_connections_test_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(263usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_secure_connections_test_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(263usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_extended_page_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(264usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_extended_page_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(264usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_extended_page_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(265usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_extended_page_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(265usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_extended_inquiry_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(266usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_extended_inquiry_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(266usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_write_extended_inquiry_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(267usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_write_extended_inquiry_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(267usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_remote_connection_parameter_request_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(268usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remote_connection_parameter_request_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(268usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_remote_connection_parameter_request_negative_reply(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(269usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remote_connection_parameter_request_negative_reply(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(269usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(270usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(270usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_suggested_default_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(271usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_suggested_default_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(271usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_write_suggested_default_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(272usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_write_suggested_default_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(272usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_local_p256_public_key(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(273usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_local_p256_public_key(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(273usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_generate_dhkey_v1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(274usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_generate_dhkey_v1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(274usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_add_device_to_resolving_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(275usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_add_device_to_resolving_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(275usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_remove_device_from_resolving_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(276usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_device_from_resolving_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(276usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_clear_resolving_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(277usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_resolving_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(277usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_resolving_list_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(278usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_resolving_list_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(278usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_peer_resolvable_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(279usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_peer_resolvable_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(279usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_local_resolvable_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(280usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_local_resolvable_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(280usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_address_resolution_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(281usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_address_resolution_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(281usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_resolvable_private_address_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(282usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_resolvable_private_address_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(282usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_maximum_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(283usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_maximum_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(283usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(284usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(284usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_default_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(285usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_default_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(285usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(286usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(286usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_receiver_test_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(287usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_receiver_test_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(287usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_transmitter_test_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(288usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_transmitter_test_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(288usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_advertising_set_random_address(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(289usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_advertising_set_random_address(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(289usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_extended_advertising_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(290usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_advertising_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(290usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_extended_advertising_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(291usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_advertising_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(291usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_extended_scan_response_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(292usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_scan_response_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(292usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_extended_advertising_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(293usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_advertising_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(293usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_maximum_advertising_data_length(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(294usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_maximum_advertising_data_length(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(294usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_number_of_supported_advertising_sets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(295usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_number_of_supported_advertising_sets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(295usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_remove_advertising_set(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(296usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_advertising_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(296usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_clear_advertising_sets(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(297usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_advertising_sets(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(297usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(298usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(298usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_data(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(299usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_data(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(299usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(300usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(300usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_extended_scan_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(301usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_scan_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(301usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_extended_scan_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(302usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_extended_scan_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(302usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_extended_create_connection(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(303usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_extended_create_connection(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(303usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_create_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(304usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_create_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(304usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_create_sync_cancel(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(305usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_create_sync_cancel(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(305usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_terminate_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(306usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_terminate_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(306usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_add_device_to_periodic_advertiser_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(307usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_add_device_to_periodic_advertiser_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(307usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_remove_device_from_periodic_advertiser_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(308usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_device_from_periodic_advertiser_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(308usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_clear_periodic_advertiser_list(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(309usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_clear_periodic_advertiser_list(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(309usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_periodic_advertiser_list_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(310usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_periodic_advertiser_list_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(310usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_transmit_power(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(311usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_transmit_power(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(311usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_rf_path_compensation(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(312usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_rf_path_compensation(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(312usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_write_rf_path_compensation(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(313usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_write_rf_path_compensation(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(313usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_privacy_mode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(314usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_privacy_mode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(314usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_receiver_test_v3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(315usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_receiver_test_v3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(315usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_transmitter_test_v3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(316usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_transmitter_test_v3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(316usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_connectionless_cte_transmit_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(317usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connectionless_cte_transmit_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(317usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_connectionless_cte_transmit_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(318usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connectionless_cte_transmit_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(318usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_connectionless_iq_sampling_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(319usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connectionless_iq_sampling_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(319usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_connection_cte_receive_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(320usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connection_cte_receive_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(320usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_connection_cte_transmit_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(321usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_connection_cte_transmit_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(321usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_connection_cte_request_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(322usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_connection_cte_request_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(322usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_connection_cte_response_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(323usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_connection_cte_response_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(323usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_antenna_information(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(324usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_antenna_information(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(324usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_receive_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(325usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_receive_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(325usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_sync_transfer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(326usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_sync_transfer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(326usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_periodic_advertising_set_info_transfer(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(327usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_periodic_advertising_set_info_transfer(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(327usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_periodic_advertising_sync_transfer_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(328usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_periodic_advertising_sync_transfer_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(328usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_default_periodic_advertising_sync_transfer_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(329usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_default_periodic_advertising_sync_transfer_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(329usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_generate_dhkey_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(330usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_generate_dhkey_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(330usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_simple_pairing_options(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(331usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_simple_pairing_options(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(331usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_modify_sleep_clock_accuracy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(332usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_modify_sleep_clock_accuracy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(332usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_buffer_size_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(333usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_buffer_size_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(333usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_iso_tx_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(334usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_iso_tx_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(334usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_cig_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(335usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_cig_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(335usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_cig_parameters_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(336usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_cig_parameters_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(336usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_create_cis(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(337usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_cis(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(337usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_remove_cig(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(338usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_cig(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(338usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_accept_cis_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(339usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_accept_cis_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(339usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_reject_cis_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(340usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_reject_cis_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(340usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_create_big(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(341usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_big(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(341usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_create_big_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(342usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_create_big_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(342usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_terminate_big(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(343usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_terminate_big(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(343usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_big_create_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(344usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_big_create_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(344usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_big_terminate_sync(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(345usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_big_terminate_sync(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(345usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_request_peer_sca(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(346usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_request_peer_sca(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(346usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_setup_iso_data_path(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(347usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_setup_iso_data_path(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(347usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_remove_iso_data_path(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(348usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_remove_iso_data_path(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(348usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_iso_transmit_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(349usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_iso_transmit_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(349usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_iso_receive_test(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(350usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_iso_receive_test(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(350usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_iso_read_test_counters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(351usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_iso_read_test_counters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(351usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_iso_test_end(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(352usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_iso_test_end(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(352usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_host_feature(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(353usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_host_feature(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(353usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_iso_link_quality(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(354usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_iso_link_quality(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(354usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_enhanced_read_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(355usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_enhanced_read_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(355usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_read_remote_transmit_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(356usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_read_remote_transmit_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(356usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_path_loss_reporting_parameters(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(357usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_path_loss_reporting_parameters(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(357usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_path_loss_reporting_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(358usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_path_loss_reporting_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(358usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_transmit_power_reporting_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(359usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_transmit_power_reporting_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(359usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_transmitter_test_v4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(360usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_transmitter_test_v4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(360usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_ecosystem_base_interval(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(361usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_ecosystem_base_interval(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(361usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_supported_codecs_v2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(362usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_codecs_v2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(362usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_supported_codec_capabilities(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(363usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_codec_capabilities(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(363usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_read_local_supported_controller_delay(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(364usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_read_local_supported_controller_delay(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(364usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_configure_data_path(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(365usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_configure_data_path(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(365usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_data_related_address_changes(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(366usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_data_related_address_changes(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(366usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_set_min_encryption_key_size(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(367usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_set_min_encryption_key_size(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(367usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_set_default_subrate_command(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(368usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_set_default_subrate_command(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(368usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn hci_le_subrate_request_command(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(369usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_hci_le_subrate_request_command(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(369usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_46_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(370usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_46_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(370usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_46_3(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(371usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_46_3(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(371usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_46_4(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(372usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_46_4(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(372usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_46_5(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(373usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_46_5(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(373usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_46_6(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(374usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_46_6(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(374usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rfu_46_7(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(375usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rfu_46_7(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(375usize, 1u8, val as u64)
        }
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_ip_read_local_version_information_return_t {
    pub hci_version: u8,
    pub hci_subversion: u16,
    pub lmp_version: u8,
    pub company_identifier: u16,
    pub lmp_subversion: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_ip_read_local_version_information_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_ip_read_local_version_information_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_ip_read_local_version_information_return_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_ip_read_local_version_information_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_ip_read_local_version_information_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_ip_read_local_version_information_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hci_version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_version_information_return_t),
            "::",
            stringify!(hci_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hci_subversion) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_version_information_return_t),
            "::",
            stringify!(hci_subversion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmp_version) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_version_information_return_t),
            "::",
            stringify!(lmp_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).company_identifier) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_version_information_return_t),
            "::",
            stringify!(company_identifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lmp_subversion) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_version_information_return_t),
            "::",
            stringify!(lmp_subversion)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_ip_read_local_supported_commands_return_t {
    pub params: sdc_hci_ip_supported_commands_t,
    pub raw: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_ip_read_local_supported_commands_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_ip_read_local_supported_commands_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_ip_read_local_supported_commands_return_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_ip_read_local_supported_commands_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_ip_read_local_supported_commands_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_ip_read_local_supported_commands_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_supported_commands_return_t),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_supported_commands_return_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_ip_read_local_supported_features_return_t {
    pub params: sdc_hci_ip_lmp_features_t,
    pub raw: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_ip_read_local_supported_features_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_ip_read_local_supported_features_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_ip_read_local_supported_features_return_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_ip_read_local_supported_features_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_ip_read_local_supported_features_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_ip_read_local_supported_features_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_supported_features_return_t),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_local_supported_features_return_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_ip_read_bd_addr_return_t {
    pub bd_addr: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_ip_read_bd_addr_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_ip_read_bd_addr_return_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_ip_read_bd_addr_return_t>(),
        6usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_ip_read_bd_addr_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_ip_read_bd_addr_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_ip_read_bd_addr_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_ip_read_bd_addr_return_t),
            "::",
            stringify!(bd_addr)
        )
    );
}
extern "C" {
    #[doc = " @defgroup HCI_VS_API API\n @{\n/\n/** @brief Read Local Version Information.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.4.1\n\n This command reads the values for the version information for the local\n Controller.\n\n The HCI_Version information defines the version information of the HCI layer.\n The LMP_Version information defines the version of the LMP. The\n Company_Identifier information indicates the manufacturer of the local device.\n\n The HCI_Subversion and LMP_Subversion are vendor-specific.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Local_Version_Information command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_ip_read_local_version_information(
        p_return: *mut sdc_hci_cmd_ip_read_local_version_information_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Read Local Supported Commands.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.4.2\n\n This command reads the list of HCI commands supported for the local\n Controller.\n\n This command shall return the Supported_Commands configuration\n parameter.\n\n See Section 6.27 for more information.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Local_Supported_Commands command has completed,\n an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_ip_read_local_supported_commands(
        p_return: *mut sdc_hci_cmd_ip_read_local_supported_commands_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Read Local Supported Features.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.4.3\n\n This command requests a list of the supported features for the local BR/EDR\n Controller. This command will return a list of the LMP features. For details see\n [Vol 2] Part C, Link Manager Protocol Specification.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_Local_Supported_Features command has completed,\n an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_ip_read_local_supported_features(
        p_return: *mut sdc_hci_cmd_ip_read_local_supported_features_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Read BD_ADDR.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.4.6\n\n On a BR/EDR Controller, this command reads the Bluetooth Controller address\n (BD_ADDR). (See [Vol 2] Part B, Section 1.2 and [Vol 3] Part C, Section 3.2.1).\n\n On an LE Controller, this command shall read the Public Device Address as\n defined in [Vol 6] Part B, Section 1.3. If this Controller does not have a Public\n Device Address, the value 0x000000000000 shall be returned.\n\n On a BR/EDR/LE Controller, the public address shall be the same as the\n BD_ADDR.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_BD_ADDR command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_ip_read_bd_addr(p_return: *mut sdc_hci_cmd_ip_read_bd_addr_return_t) -> u8;
}
#[doc = "  See @ref sdc_hci_cmd_le_set_event_mask()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_EVENT_MASK: sdc_hci_opcode_le = 8193;
#[doc = "  See @ref sdc_hci_cmd_le_read_buffer_size()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_BUFFER_SIZE: sdc_hci_opcode_le = 8194;
#[doc = "  See @ref sdc_hci_cmd_le_read_local_supported_features()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_LOCAL_SUPPORTED_FEATURES: sdc_hci_opcode_le = 8195;
#[doc = "  See @ref sdc_hci_cmd_le_set_random_address()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_RANDOM_ADDRESS: sdc_hci_opcode_le = 8197;
#[doc = "  See @ref sdc_hci_cmd_le_set_adv_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_ADV_PARAMS: sdc_hci_opcode_le = 8198;
#[doc = "  See @ref sdc_hci_cmd_le_read_adv_physical_channel_tx_power()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_ADV_PHYSICAL_CHANNEL_TX_POWER: sdc_hci_opcode_le = 8199;
#[doc = "  See @ref sdc_hci_cmd_le_set_adv_data()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_ADV_DATA: sdc_hci_opcode_le = 8200;
#[doc = "  See @ref sdc_hci_cmd_le_set_scan_response_data()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_SCAN_RESPONSE_DATA: sdc_hci_opcode_le = 8201;
#[doc = "  See @ref sdc_hci_cmd_le_set_adv_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_ADV_ENABLE: sdc_hci_opcode_le = 8202;
#[doc = "  See @ref sdc_hci_cmd_le_set_scan_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_SCAN_PARAMS: sdc_hci_opcode_le = 8203;
#[doc = "  See @ref sdc_hci_cmd_le_set_scan_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_SCAN_ENABLE: sdc_hci_opcode_le = 8204;
#[doc = "  See @ref sdc_hci_cmd_le_create_conn()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_CREATE_CONN: sdc_hci_opcode_le = 8205;
#[doc = "  See @ref sdc_hci_cmd_le_create_conn_cancel()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_CREATE_CONN_CANCEL: sdc_hci_opcode_le = 8206;
#[doc = "  See @ref sdc_hci_cmd_le_read_filter_accept_list_size()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_FILTER_ACCEPT_LIST_SIZE: sdc_hci_opcode_le = 8207;
#[doc = "  See @ref sdc_hci_cmd_le_clear_filter_accept_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_CLEAR_FILTER_ACCEPT_LIST: sdc_hci_opcode_le = 8208;
#[doc = "  See @ref sdc_hci_cmd_le_add_device_to_filter_accept_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_ADD_DEVICE_TO_FILTER_ACCEPT_LIST: sdc_hci_opcode_le = 8209;
#[doc = "  See @ref sdc_hci_cmd_le_remove_device_from_filter_accept_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_REMOVE_DEVICE_FROM_FILTER_ACCEPT_LIST: sdc_hci_opcode_le = 8210;
#[doc = "  See @ref sdc_hci_cmd_le_conn_update()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_CONN_UPDATE: sdc_hci_opcode_le = 8211;
#[doc = "  See @ref sdc_hci_cmd_le_set_host_channel_classification()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_HOST_CHANNEL_CLASSIFICATION: sdc_hci_opcode_le = 8212;
#[doc = "  See @ref sdc_hci_cmd_le_read_channel_map()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_CHANNEL_MAP: sdc_hci_opcode_le = 8213;
#[doc = "  See @ref sdc_hci_cmd_le_read_remote_features()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_REMOTE_FEATURES: sdc_hci_opcode_le = 8214;
#[doc = "  See @ref sdc_hci_cmd_le_encrypt()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_ENCRYPT: sdc_hci_opcode_le = 8215;
#[doc = "  See @ref sdc_hci_cmd_le_rand()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_RAND: sdc_hci_opcode_le = 8216;
#[doc = "  See @ref sdc_hci_cmd_le_enable_encryption()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_ENABLE_ENCRYPTION: sdc_hci_opcode_le = 8217;
#[doc = "  See @ref sdc_hci_cmd_le_long_term_key_request_reply()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_LONG_TERM_KEY_REQUEST_REPLY: sdc_hci_opcode_le = 8218;
#[doc = "  See @ref sdc_hci_cmd_le_long_term_key_request_negative_reply()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_LONG_TERM_KEY_REQUEST_NEGATIVE_REPLY: sdc_hci_opcode_le = 8219;
#[doc = "  See @ref sdc_hci_cmd_le_read_supported_states()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_SUPPORTED_STATES: sdc_hci_opcode_le = 8220;
#[doc = "  See @ref sdc_hci_cmd_le_test_end()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_TEST_END: sdc_hci_opcode_le = 8223;
#[doc = "  See @ref sdc_hci_cmd_le_set_data_length()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_DATA_LENGTH: sdc_hci_opcode_le = 8226;
#[doc = "  See @ref sdc_hci_cmd_le_read_suggested_default_data_length()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_SUGGESTED_DEFAULT_DATA_LENGTH: sdc_hci_opcode_le = 8227;
#[doc = "  See @ref sdc_hci_cmd_le_write_suggested_default_data_length()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_WRITE_SUGGESTED_DEFAULT_DATA_LENGTH: sdc_hci_opcode_le = 8228;
#[doc = "  See @ref sdc_hci_cmd_le_add_device_to_resolving_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_ADD_DEVICE_TO_RESOLVING_LIST: sdc_hci_opcode_le = 8231;
#[doc = "  See @ref sdc_hci_cmd_le_remove_device_from_resolving_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_REMOVE_DEVICE_FROM_RESOLVING_LIST: sdc_hci_opcode_le = 8232;
#[doc = "  See @ref sdc_hci_cmd_le_clear_resolving_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_CLEAR_RESOLVING_LIST: sdc_hci_opcode_le = 8233;
#[doc = "  See @ref sdc_hci_cmd_le_read_resolving_list_size()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_RESOLVING_LIST_SIZE: sdc_hci_opcode_le = 8234;
#[doc = "  See @ref sdc_hci_cmd_le_set_address_resolution_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_ADDRESS_RESOLUTION_ENABLE: sdc_hci_opcode_le = 8237;
#[doc = "  See @ref sdc_hci_cmd_le_set_resolvable_private_address_timeout()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_RESOLVABLE_PRIVATE_ADDRESS_TIMEOUT: sdc_hci_opcode_le = 8238;
#[doc = "  See @ref sdc_hci_cmd_le_read_max_data_length()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_MAX_DATA_LENGTH: sdc_hci_opcode_le = 8239;
#[doc = "  See @ref sdc_hci_cmd_le_read_phy()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_PHY: sdc_hci_opcode_le = 8240;
#[doc = "  See @ref sdc_hci_cmd_le_set_default_phy()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_DEFAULT_PHY: sdc_hci_opcode_le = 8241;
#[doc = "  See @ref sdc_hci_cmd_le_set_phy()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PHY: sdc_hci_opcode_le = 8242;
#[doc = "  See @ref sdc_hci_cmd_le_set_adv_set_random_address()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_ADV_SET_RANDOM_ADDRESS: sdc_hci_opcode_le = 8245;
#[doc = "  See @ref sdc_hci_cmd_le_set_ext_adv_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_EXT_ADV_PARAMS: sdc_hci_opcode_le = 8246;
#[doc = "  See @ref sdc_hci_cmd_le_set_ext_adv_data()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_EXT_ADV_DATA: sdc_hci_opcode_le = 8247;
#[doc = "  See @ref sdc_hci_cmd_le_set_ext_scan_response_data()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_EXT_SCAN_RESPONSE_DATA: sdc_hci_opcode_le = 8248;
#[doc = "  See @ref sdc_hci_cmd_le_set_ext_adv_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_EXT_ADV_ENABLE: sdc_hci_opcode_le = 8249;
#[doc = "  See @ref sdc_hci_cmd_le_read_max_adv_data_length()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_MAX_ADV_DATA_LENGTH: sdc_hci_opcode_le = 8250;
#[doc = "  See @ref sdc_hci_cmd_le_read_number_of_supported_adv_sets()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_NUMBER_OF_SUPPORTED_ADV_SETS: sdc_hci_opcode_le = 8251;
#[doc = "  See @ref sdc_hci_cmd_le_remove_adv_set()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_REMOVE_ADV_SET: sdc_hci_opcode_le = 8252;
#[doc = "  See @ref sdc_hci_cmd_le_clear_adv_sets()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_CLEAR_ADV_SETS: sdc_hci_opcode_le = 8253;
#[doc = "  See @ref sdc_hci_cmd_le_set_periodic_adv_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_PARAMS: sdc_hci_opcode_le = 8254;
#[doc = "  See @ref sdc_hci_cmd_le_set_periodic_adv_data()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_DATA: sdc_hci_opcode_le = 8255;
#[doc = "  See @ref sdc_hci_cmd_le_set_periodic_adv_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_ENABLE: sdc_hci_opcode_le = 8256;
#[doc = "  See @ref sdc_hci_cmd_le_set_ext_scan_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_EXT_SCAN_PARAMS: sdc_hci_opcode_le = 8257;
#[doc = "  See @ref sdc_hci_cmd_le_set_ext_scan_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_EXT_SCAN_ENABLE: sdc_hci_opcode_le = 8258;
#[doc = "  See @ref sdc_hci_cmd_le_ext_create_conn()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_EXT_CREATE_CONN: sdc_hci_opcode_le = 8259;
#[doc = "  See @ref sdc_hci_cmd_le_periodic_adv_create_sync()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_CREATE_SYNC: sdc_hci_opcode_le = 8260;
#[doc = "  See @ref sdc_hci_cmd_le_periodic_adv_create_sync_cancel()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_CREATE_SYNC_CANCEL: sdc_hci_opcode_le = 8261;
#[doc = "  See @ref sdc_hci_cmd_le_periodic_adv_terminate_sync()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_TERMINATE_SYNC: sdc_hci_opcode_le = 8262;
#[doc = "  See @ref sdc_hci_cmd_le_add_device_to_periodic_adv_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_ADD_DEVICE_TO_PERIODIC_ADV_LIST: sdc_hci_opcode_le = 8263;
#[doc = "  See @ref sdc_hci_cmd_le_remove_device_from_periodic_adv_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_REMOVE_DEVICE_FROM_PERIODIC_ADV_LIST: sdc_hci_opcode_le = 8264;
#[doc = "  See @ref sdc_hci_cmd_le_clear_periodic_adv_list()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_CLEAR_PERIODIC_ADV_LIST: sdc_hci_opcode_le = 8265;
#[doc = "  See @ref sdc_hci_cmd_le_read_periodic_adv_list_size()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_PERIODIC_ADV_LIST_SIZE: sdc_hci_opcode_le = 8266;
#[doc = "  See @ref sdc_hci_cmd_le_read_transmit_power()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_TRANSMIT_POWER: sdc_hci_opcode_le = 8267;
#[doc = "  See @ref sdc_hci_cmd_le_read_rf_path_compensation()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_RF_PATH_COMPENSATION: sdc_hci_opcode_le = 8268;
#[doc = "  See @ref sdc_hci_cmd_le_write_rf_path_compensation()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_WRITE_RF_PATH_COMPENSATION: sdc_hci_opcode_le = 8269;
#[doc = "  See @ref sdc_hci_cmd_le_set_privacy_mode()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PRIVACY_MODE: sdc_hci_opcode_le = 8270;
#[doc = "  See @ref sdc_hci_cmd_le_set_connless_cte_transmit_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_CONNLESS_CTE_TRANSMIT_PARAMS: sdc_hci_opcode_le = 8273;
#[doc = "  See @ref sdc_hci_cmd_le_set_connless_cte_transmit_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_CONNLESS_CTE_TRANSMIT_ENABLE: sdc_hci_opcode_le = 8274;
#[doc = "  See @ref sdc_hci_cmd_le_set_conn_cte_transmit_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_CONN_CTE_TRANSMIT_PARAMS: sdc_hci_opcode_le = 8277;
#[doc = "  See @ref sdc_hci_cmd_le_conn_cte_response_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_CONN_CTE_RESPONSE_ENABLE: sdc_hci_opcode_le = 8279;
#[doc = "  See @ref sdc_hci_cmd_le_read_antenna_information()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_ANTENNA_INFORMATION: sdc_hci_opcode_le = 8280;
#[doc = "  See @ref sdc_hci_cmd_le_set_periodic_adv_receive_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_RECEIVE_ENABLE: sdc_hci_opcode_le = 8281;
#[doc = "  See @ref sdc_hci_cmd_le_periodic_adv_sync_transfer()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_SYNC_TRANSFER: sdc_hci_opcode_le = 8282;
#[doc = "  See @ref sdc_hci_cmd_le_periodic_adv_set_info_transfer()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_PERIODIC_ADV_SET_INFO_TRANSFER: sdc_hci_opcode_le = 8283;
#[doc = "  See @ref sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PERIODIC_ADV_SYNC_TRANSFER_PARAMS: sdc_hci_opcode_le = 8284;
#[doc = "  See @ref sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_DEFAULT_PERIODIC_ADV_SYNC_TRANSFER_PARAMS: sdc_hci_opcode_le =
    8285;
#[doc = "  See @ref sdc_hci_cmd_le_enhanced_read_transmit_power_level()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_ENHANCED_READ_TRANSMIT_POWER_LEVEL: sdc_hci_opcode_le = 8310;
#[doc = "  See @ref sdc_hci_cmd_le_read_remote_transmit_power_level()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_READ_REMOTE_TRANSMIT_POWER_LEVEL: sdc_hci_opcode_le = 8311;
#[doc = "  See @ref sdc_hci_cmd_le_set_path_loss_reporting_params()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PATH_LOSS_REPORTING_PARAMS: sdc_hci_opcode_le = 8312;
#[doc = "  See @ref sdc_hci_cmd_le_set_path_loss_reporting_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_PATH_LOSS_REPORTING_ENABLE: sdc_hci_opcode_le = 8313;
#[doc = "  See @ref sdc_hci_cmd_le_set_transmit_power_reporting_enable()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_TRANSMIT_POWER_REPORTING_ENABLE: sdc_hci_opcode_le = 8314;
#[doc = "  See @ref sdc_hci_cmd_le_set_data_related_address_changes()."]
pub const sdc_hci_opcode_le_SDC_HCI_OPCODE_CMD_LE_SET_DATA_RELATED_ADDRESS_CHANGES: sdc_hci_opcode_le = 8316;
#[doc = "  HCI LE OpCode Field values."]
pub type sdc_hci_opcode_le = crate::ctypes::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_ext_create_conn_array_params_t {
    pub scan_interval: u16,
    pub scan_window: u16,
    pub conn_interval_min: u16,
    pub conn_interval_max: u16,
    pub max_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_length: u16,
    pub max_ce_length: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_le_ext_create_conn_array_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_le_ext_create_conn_array_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_le_ext_create_conn_array_params_t>(),
        16usize,
        concat!("Size of: ", stringify!(sdc_hci_le_ext_create_conn_array_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_le_ext_create_conn_array_params_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_le_ext_create_conn_array_params_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_ext_create_conn_array_params_t),
            "::",
            stringify!(scan_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_window) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_ext_create_conn_array_params_t),
            "::",
            stringify!(scan_window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_interval_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_ext_create_conn_array_params_t),
            "::",
            stringify!(conn_interval_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_interval_max) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_ext_create_conn_array_params_t),
            "::",
            stringify!(conn_interval_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_latency) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_ext_create_conn_array_params_t),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supervision_timeout) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_ext_create_conn_array_params_t),
            "::",
            stringify!(supervision_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_ce_length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_ext_create_conn_array_params_t),
            "::",
            stringify!(min_ce_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_ce_length) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_ext_create_conn_array_params_t),
            "::",
            stringify!(max_ce_length)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_le_event_mask_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_le_le_event_mask_t() {
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_le_le_event_mask_t>(),
        5usize,
        concat!("Size of: ", stringify!(sdc_hci_le_le_event_mask_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_le_le_event_mask_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_le_le_event_mask_t))
    );
}
impl sdc_hci_le_le_event_mask_t {
    #[inline]
    pub fn le_connection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_connection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_connection_update_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_connection_update_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_read_remote_features_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_read_remote_features_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_long_term_key_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_long_term_key_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_remote_connection_parameter_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_remote_connection_parameter_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_data_length_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_data_length_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_read_local_p256_public_key_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_read_local_p256_public_key_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_generate_dhkey_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_generate_dhkey_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_enhanced_connection_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_enhanced_connection_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_directed_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_directed_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_phy_update_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_phy_update_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_extended_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_extended_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_periodic_advertising_sync_established_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_sync_established_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_periodic_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_periodic_advertising_sync_lost_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_sync_lost_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_scan_timeout_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_scan_timeout_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_advertising_set_terminated_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_advertising_set_terminated_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_scan_request_received_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_scan_request_received_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_channel_selection_algorithm_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_channel_selection_algorithm_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_connectionless_iq_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_connectionless_iq_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_connection_iq_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_connection_iq_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_cte_request_failed_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_cte_request_failed_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_periodic_advertising_sync_transfer_received_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising_sync_transfer_received_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_cis_established_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_cis_established_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_cis_request_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_cis_request_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_create_big_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_create_big_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_terminate_big_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_terminate_big_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_big_sync_established_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_big_sync_established_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_big_sync_lost_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_big_sync_lost_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_request_peer_sca_complete_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_request_peer_sca_complete_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_path_loss_threshold_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_path_loss_threshold_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_transmit_power_reporting_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_transmit_power_reporting_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_biginfo_advertising_report_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_biginfo_advertising_report_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_subrate_change_event(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_subrate_change_event(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        le_connection_complete_event: u8,
        le_advertising_report_event: u8,
        le_connection_update_complete_event: u8,
        le_read_remote_features_complete_event: u8,
        le_long_term_key_request_event: u8,
        le_remote_connection_parameter_request_event: u8,
        le_data_length_change_event: u8,
        le_read_local_p256_public_key_complete_event: u8,
        le_generate_dhkey_complete_event: u8,
        le_enhanced_connection_complete_event: u8,
        le_directed_advertising_report_event: u8,
        le_phy_update_complete_event: u8,
        le_extended_advertising_report_event: u8,
        le_periodic_advertising_sync_established_event: u8,
        le_periodic_advertising_report_event: u8,
        le_periodic_advertising_sync_lost_event: u8,
        le_scan_timeout_event: u8,
        le_advertising_set_terminated_event: u8,
        le_scan_request_received_event: u8,
        le_channel_selection_algorithm_event: u8,
        le_connectionless_iq_report_event: u8,
        le_connection_iq_report_event: u8,
        le_cte_request_failed_event: u8,
        le_periodic_advertising_sync_transfer_received_event: u8,
        le_cis_established_event: u8,
        le_cis_request_event: u8,
        le_create_big_complete_event: u8,
        le_terminate_big_complete_event: u8,
        le_big_sync_established_event: u8,
        le_big_sync_lost_event: u8,
        le_request_peer_sca_complete_event: u8,
        le_path_loss_threshold_event: u8,
        le_transmit_power_reporting_event: u8,
        le_biginfo_advertising_report_event: u8,
        le_subrate_change_event: u8,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let le_connection_complete_event: u8 = unsafe { ::core::mem::transmute(le_connection_complete_event) };
            le_connection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let le_advertising_report_event: u8 = unsafe { ::core::mem::transmute(le_advertising_report_event) };
            le_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let le_connection_update_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_connection_update_complete_event) };
            le_connection_update_complete_event as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let le_read_remote_features_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_read_remote_features_complete_event) };
            le_read_remote_features_complete_event as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let le_long_term_key_request_event: u8 = unsafe { ::core::mem::transmute(le_long_term_key_request_event) };
            le_long_term_key_request_event as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let le_remote_connection_parameter_request_event: u8 =
                unsafe { ::core::mem::transmute(le_remote_connection_parameter_request_event) };
            le_remote_connection_parameter_request_event as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let le_data_length_change_event: u8 = unsafe { ::core::mem::transmute(le_data_length_change_event) };
            le_data_length_change_event as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let le_read_local_p256_public_key_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_read_local_p256_public_key_complete_event) };
            le_read_local_p256_public_key_complete_event as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let le_generate_dhkey_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_generate_dhkey_complete_event) };
            le_generate_dhkey_complete_event as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let le_enhanced_connection_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_enhanced_connection_complete_event) };
            le_enhanced_connection_complete_event as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let le_directed_advertising_report_event: u8 =
                unsafe { ::core::mem::transmute(le_directed_advertising_report_event) };
            le_directed_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let le_phy_update_complete_event: u8 = unsafe { ::core::mem::transmute(le_phy_update_complete_event) };
            le_phy_update_complete_event as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let le_extended_advertising_report_event: u8 =
                unsafe { ::core::mem::transmute(le_extended_advertising_report_event) };
            le_extended_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let le_periodic_advertising_sync_established_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_sync_established_event) };
            le_periodic_advertising_sync_established_event as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let le_periodic_advertising_report_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_report_event) };
            le_periodic_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let le_periodic_advertising_sync_lost_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_sync_lost_event) };
            le_periodic_advertising_sync_lost_event as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let le_scan_timeout_event: u8 = unsafe { ::core::mem::transmute(le_scan_timeout_event) };
            le_scan_timeout_event as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let le_advertising_set_terminated_event: u8 =
                unsafe { ::core::mem::transmute(le_advertising_set_terminated_event) };
            le_advertising_set_terminated_event as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let le_scan_request_received_event: u8 = unsafe { ::core::mem::transmute(le_scan_request_received_event) };
            le_scan_request_received_event as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let le_channel_selection_algorithm_event: u8 =
                unsafe { ::core::mem::transmute(le_channel_selection_algorithm_event) };
            le_channel_selection_algorithm_event as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let le_connectionless_iq_report_event: u8 =
                unsafe { ::core::mem::transmute(le_connectionless_iq_report_event) };
            le_connectionless_iq_report_event as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let le_connection_iq_report_event: u8 = unsafe { ::core::mem::transmute(le_connection_iq_report_event) };
            le_connection_iq_report_event as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let le_cte_request_failed_event: u8 = unsafe { ::core::mem::transmute(le_cte_request_failed_event) };
            le_cte_request_failed_event as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let le_periodic_advertising_sync_transfer_received_event: u8 =
                unsafe { ::core::mem::transmute(le_periodic_advertising_sync_transfer_received_event) };
            le_periodic_advertising_sync_transfer_received_event as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let le_cis_established_event: u8 = unsafe { ::core::mem::transmute(le_cis_established_event) };
            le_cis_established_event as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let le_cis_request_event: u8 = unsafe { ::core::mem::transmute(le_cis_request_event) };
            le_cis_request_event as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let le_create_big_complete_event: u8 = unsafe { ::core::mem::transmute(le_create_big_complete_event) };
            le_create_big_complete_event as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let le_terminate_big_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_terminate_big_complete_event) };
            le_terminate_big_complete_event as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let le_big_sync_established_event: u8 = unsafe { ::core::mem::transmute(le_big_sync_established_event) };
            le_big_sync_established_event as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let le_big_sync_lost_event: u8 = unsafe { ::core::mem::transmute(le_big_sync_lost_event) };
            le_big_sync_lost_event as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let le_request_peer_sca_complete_event: u8 =
                unsafe { ::core::mem::transmute(le_request_peer_sca_complete_event) };
            le_request_peer_sca_complete_event as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let le_path_loss_threshold_event: u8 = unsafe { ::core::mem::transmute(le_path_loss_threshold_event) };
            le_path_loss_threshold_event as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let le_transmit_power_reporting_event: u8 =
                unsafe { ::core::mem::transmute(le_transmit_power_reporting_event) };
            le_transmit_power_reporting_event as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let le_biginfo_advertising_report_event: u8 =
                unsafe { ::core::mem::transmute(le_biginfo_advertising_report_event) };
            le_biginfo_advertising_report_event as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let le_subrate_change_event: u8 = unsafe { ::core::mem::transmute(le_subrate_change_event) };
            le_subrate_change_event as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_le_features_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_le_le_features_t() {
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_le_le_features_t>(),
        5usize,
        concat!("Size of: ", stringify!(sdc_hci_le_le_features_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_le_le_features_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_le_le_features_t))
    );
}
impl sdc_hci_le_le_features_t {
    #[inline]
    pub fn le_encryption(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_encryption(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_parameters_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_parameters_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_reject_indication(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended_reject_indication(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn slave_initiated_features_exchange(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_slave_initiated_features_exchange(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_ping(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_ping(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_data_packet_length_extension(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_data_packet_length_extension(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ll_privacy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ll_privacy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_scanner_filter_policies(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_extended_scanner_filter_policies(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_2m_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_2m_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stable_modulation_index_transmitter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stable_modulation_index_transmitter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stable_modulation_index_receiver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_stable_modulation_index_receiver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_coded_phy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_coded_phy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_extended_advertising(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_extended_advertising(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_periodic_advertising(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_periodic_advertising(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel_selection_algorithm_2(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_channel_selection_algorithm_2(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_Power_class_1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_Power_class_1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn minimum_number_of_used_channels_procedure(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_minimum_number_of_used_channels_procedure(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_cte_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_cte_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_cte_response(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_cte_response(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connectionless_cte_transmitter(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_cte_transmitter(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connectionless_cte_receiver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connectionless_cte_receiver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn antenna_switching_during_cte_transmission_aod(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_antenna_switching_during_cte_transmission_aod(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn antenna_switching_during_cte_reception_aoa(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_antenna_switching_during_cte_reception_aoa(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn receiving_constant_tone_extensions(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_receiving_constant_tone_extensions(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn periodic_advertising_sync_transfer_sender(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_advertising_sync_transfer_sender(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn periodic_advertising_sync_transfer_recipient(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_advertising_sync_transfer_recipient(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn sleep_clock_accuracy_updates(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_sleep_clock_accuracy_updates(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn remote_public_key_validation(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_remote_public_key_validation(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connected_isochronous_stream_master(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connected_isochronous_stream_master(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connected_isochronous_stream_slave(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connected_isochronous_stream_slave(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isochronous_broadcaster(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isochronous_broadcaster(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn synchronized_receiver(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_synchronized_receiver(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn isochronous_channels_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_isochronous_channels_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_power_control_request(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_power_control_request(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_power_change_indication(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_power_change_indication(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_path_loss_monitoring(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_le_path_loss_monitoring(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn periodic_advertising_adi_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_advertising_adi_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_subrating(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_subrating(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn connection_subrating_host_support(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_connection_subrating_host_support(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn channel_classification(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_channel_classification(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        le_encryption: u8,
        connection_parameters_request: u8,
        extended_reject_indication: u8,
        slave_initiated_features_exchange: u8,
        le_ping: u8,
        le_data_packet_length_extension: u8,
        ll_privacy: u8,
        extended_scanner_filter_policies: u8,
        le_2m_phy: u8,
        stable_modulation_index_transmitter: u8,
        stable_modulation_index_receiver: u8,
        le_coded_phy: u8,
        le_extended_advertising: u8,
        le_periodic_advertising: u8,
        channel_selection_algorithm_2: u8,
        le_Power_class_1: u8,
        minimum_number_of_used_channels_procedure: u8,
        connection_cte_request: u8,
        connection_cte_response: u8,
        connectionless_cte_transmitter: u8,
        connectionless_cte_receiver: u8,
        antenna_switching_during_cte_transmission_aod: u8,
        antenna_switching_during_cte_reception_aoa: u8,
        receiving_constant_tone_extensions: u8,
        periodic_advertising_sync_transfer_sender: u8,
        periodic_advertising_sync_transfer_recipient: u8,
        sleep_clock_accuracy_updates: u8,
        remote_public_key_validation: u8,
        connected_isochronous_stream_master: u8,
        connected_isochronous_stream_slave: u8,
        isochronous_broadcaster: u8,
        synchronized_receiver: u8,
        isochronous_channels_host_support: u8,
        le_power_control_request: u8,
        le_power_change_indication: u8,
        le_path_loss_monitoring: u8,
        periodic_advertising_adi_support: u8,
        connection_subrating: u8,
        connection_subrating_host_support: u8,
        channel_classification: u8,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let le_encryption: u8 = unsafe { ::core::mem::transmute(le_encryption) };
            le_encryption as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let connection_parameters_request: u8 = unsafe { ::core::mem::transmute(connection_parameters_request) };
            connection_parameters_request as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let extended_reject_indication: u8 = unsafe { ::core::mem::transmute(extended_reject_indication) };
            extended_reject_indication as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let slave_initiated_features_exchange: u8 =
                unsafe { ::core::mem::transmute(slave_initiated_features_exchange) };
            slave_initiated_features_exchange as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let le_ping: u8 = unsafe { ::core::mem::transmute(le_ping) };
            le_ping as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let le_data_packet_length_extension: u8 =
                unsafe { ::core::mem::transmute(le_data_packet_length_extension) };
            le_data_packet_length_extension as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ll_privacy: u8 = unsafe { ::core::mem::transmute(ll_privacy) };
            ll_privacy as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let extended_scanner_filter_policies: u8 =
                unsafe { ::core::mem::transmute(extended_scanner_filter_policies) };
            extended_scanner_filter_policies as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let le_2m_phy: u8 = unsafe { ::core::mem::transmute(le_2m_phy) };
            le_2m_phy as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let stable_modulation_index_transmitter: u8 =
                unsafe { ::core::mem::transmute(stable_modulation_index_transmitter) };
            stable_modulation_index_transmitter as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let stable_modulation_index_receiver: u8 =
                unsafe { ::core::mem::transmute(stable_modulation_index_receiver) };
            stable_modulation_index_receiver as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let le_coded_phy: u8 = unsafe { ::core::mem::transmute(le_coded_phy) };
            le_coded_phy as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let le_extended_advertising: u8 = unsafe { ::core::mem::transmute(le_extended_advertising) };
            le_extended_advertising as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let le_periodic_advertising: u8 = unsafe { ::core::mem::transmute(le_periodic_advertising) };
            le_periodic_advertising as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let channel_selection_algorithm_2: u8 = unsafe { ::core::mem::transmute(channel_selection_algorithm_2) };
            channel_selection_algorithm_2 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let le_Power_class_1: u8 = unsafe { ::core::mem::transmute(le_Power_class_1) };
            le_Power_class_1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let minimum_number_of_used_channels_procedure: u8 =
                unsafe { ::core::mem::transmute(minimum_number_of_used_channels_procedure) };
            minimum_number_of_used_channels_procedure as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let connection_cte_request: u8 = unsafe { ::core::mem::transmute(connection_cte_request) };
            connection_cte_request as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let connection_cte_response: u8 = unsafe { ::core::mem::transmute(connection_cte_response) };
            connection_cte_response as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let connectionless_cte_transmitter: u8 = unsafe { ::core::mem::transmute(connectionless_cte_transmitter) };
            connectionless_cte_transmitter as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let connectionless_cte_receiver: u8 = unsafe { ::core::mem::transmute(connectionless_cte_receiver) };
            connectionless_cte_receiver as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let antenna_switching_during_cte_transmission_aod: u8 =
                unsafe { ::core::mem::transmute(antenna_switching_during_cte_transmission_aod) };
            antenna_switching_during_cte_transmission_aod as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let antenna_switching_during_cte_reception_aoa: u8 =
                unsafe { ::core::mem::transmute(antenna_switching_during_cte_reception_aoa) };
            antenna_switching_during_cte_reception_aoa as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let receiving_constant_tone_extensions: u8 =
                unsafe { ::core::mem::transmute(receiving_constant_tone_extensions) };
            receiving_constant_tone_extensions as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let periodic_advertising_sync_transfer_sender: u8 =
                unsafe { ::core::mem::transmute(periodic_advertising_sync_transfer_sender) };
            periodic_advertising_sync_transfer_sender as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let periodic_advertising_sync_transfer_recipient: u8 =
                unsafe { ::core::mem::transmute(periodic_advertising_sync_transfer_recipient) };
            periodic_advertising_sync_transfer_recipient as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let sleep_clock_accuracy_updates: u8 = unsafe { ::core::mem::transmute(sleep_clock_accuracy_updates) };
            sleep_clock_accuracy_updates as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let remote_public_key_validation: u8 = unsafe { ::core::mem::transmute(remote_public_key_validation) };
            remote_public_key_validation as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let connected_isochronous_stream_master: u8 =
                unsafe { ::core::mem::transmute(connected_isochronous_stream_master) };
            connected_isochronous_stream_master as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let connected_isochronous_stream_slave: u8 =
                unsafe { ::core::mem::transmute(connected_isochronous_stream_slave) };
            connected_isochronous_stream_slave as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let isochronous_broadcaster: u8 = unsafe { ::core::mem::transmute(isochronous_broadcaster) };
            isochronous_broadcaster as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let synchronized_receiver: u8 = unsafe { ::core::mem::transmute(synchronized_receiver) };
            synchronized_receiver as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let isochronous_channels_host_support: u8 =
                unsafe { ::core::mem::transmute(isochronous_channels_host_support) };
            isochronous_channels_host_support as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let le_power_control_request: u8 = unsafe { ::core::mem::transmute(le_power_control_request) };
            le_power_control_request as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let le_power_change_indication: u8 = unsafe { ::core::mem::transmute(le_power_change_indication) };
            le_power_change_indication as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let le_path_loss_monitoring: u8 = unsafe { ::core::mem::transmute(le_path_loss_monitoring) };
            le_path_loss_monitoring as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let periodic_advertising_adi_support: u8 =
                unsafe { ::core::mem::transmute(periodic_advertising_adi_support) };
            periodic_advertising_adi_support as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let connection_subrating: u8 = unsafe { ::core::mem::transmute(connection_subrating) };
            connection_subrating as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let connection_subrating_host_support: u8 =
                unsafe { ::core::mem::transmute(connection_subrating_host_support) };
            connection_subrating_host_support as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let channel_classification: u8 = unsafe { ::core::mem::transmute(channel_classification) };
            channel_classification as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_conn_cte_transmit_params_array_params_t {
    pub antenna_ids: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_le_set_conn_cte_transmit_params_array_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_le_set_conn_cte_transmit_params_array_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_le_set_conn_cte_transmit_params_array_params_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_le_set_conn_cte_transmit_params_array_params_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_le_set_conn_cte_transmit_params_array_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_le_set_conn_cte_transmit_params_array_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).antenna_ids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_set_conn_cte_transmit_params_array_params_t),
            "::",
            stringify!(antenna_ids)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_connless_cte_transmit_params_array_params_t {
    pub antenna_ids: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_le_set_connless_cte_transmit_params_array_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_le_set_connless_cte_transmit_params_array_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_le_set_connless_cte_transmit_params_array_params_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_le_set_connless_cte_transmit_params_array_params_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_le_set_connless_cte_transmit_params_array_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_le_set_connless_cte_transmit_params_array_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).antenna_ids) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_set_connless_cte_transmit_params_array_params_t),
            "::",
            stringify!(antenna_ids)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_ext_adv_enable_array_params_t {
    pub adv_handle: u8,
    pub duration: u16,
    pub max_ext_adv_events: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_le_set_ext_adv_enable_array_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_le_set_ext_adv_enable_array_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_le_set_ext_adv_enable_array_params_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_le_set_ext_adv_enable_array_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_le_set_ext_adv_enable_array_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_le_set_ext_adv_enable_array_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_set_ext_adv_enable_array_params_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_set_ext_adv_enable_array_params_t),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_ext_adv_events) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_set_ext_adv_enable_array_params_t),
            "::",
            stringify!(max_ext_adv_events)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_le_set_ext_scan_params_array_params_t {
    pub scan_type: u8,
    pub scan_interval: u16,
    pub scan_window: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_le_set_ext_scan_params_array_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_le_set_ext_scan_params_array_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_le_set_ext_scan_params_array_params_t>(),
        5usize,
        concat!("Size of: ", stringify!(sdc_hci_le_set_ext_scan_params_array_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_le_set_ext_scan_params_array_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_le_set_ext_scan_params_array_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_set_ext_scan_params_array_params_t),
            "::",
            stringify!(scan_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_interval) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_set_ext_scan_params_array_params_t),
            "::",
            stringify!(scan_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_window) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_le_set_ext_scan_params_array_params_t),
            "::",
            stringify!(scan_window)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_set_event_mask_t {
    pub params: sdc_hci_le_le_event_mask_t,
    pub raw: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_event_mask_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_event_mask_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_event_mask_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_event_mask_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_event_mask_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_event_mask_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_event_mask_t),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_event_mask_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_buffer_size_return_t {
    pub le_acl_data_packet_length: u16,
    pub total_num_le_acl_data_packets: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_buffer_size_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_buffer_size_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_buffer_size_return_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_buffer_size_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_buffer_size_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_read_buffer_size_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_acl_data_packet_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_buffer_size_return_t),
            "::",
            stringify!(le_acl_data_packet_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).total_num_le_acl_data_packets) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_buffer_size_return_t),
            "::",
            stringify!(total_num_le_acl_data_packets)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_le_read_local_supported_features_return_t {
    pub params: sdc_hci_le_le_features_t,
    pub raw: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_local_supported_features_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_local_supported_features_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_local_supported_features_return_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_local_supported_features_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_local_supported_features_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_local_supported_features_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_local_supported_features_return_t),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_local_supported_features_return_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_random_address_t {
    pub random_address: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_random_address_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_random_address_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_random_address_t>(),
        6usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_random_address_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_random_address_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_random_address_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).random_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_random_address_t),
            "::",
            stringify!(random_address)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_adv_params_t {
    pub adv_interval_min: u16,
    pub adv_interval_max: u16,
    pub adv_type: u8,
    pub own_address_type: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub adv_channel_map: u8,
    pub adv_filter_policy: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_adv_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_adv_params_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_adv_params_t>(),
        15usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_adv_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_adv_params_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_adv_params_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_interval_min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_params_t),
            "::",
            stringify!(adv_interval_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_interval_max) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_params_t),
            "::",
            stringify!(adv_interval_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_type) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_params_t),
            "::",
            stringify!(adv_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).own_address_type) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_params_t),
            "::",
            stringify!(own_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_address_type) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_params_t),
            "::",
            stringify!(peer_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_address) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_params_t),
            "::",
            stringify!(peer_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_channel_map) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_params_t),
            "::",
            stringify!(adv_channel_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_filter_policy) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_params_t),
            "::",
            stringify!(adv_filter_policy)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t {
    pub tx_power_level: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_power_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t),
            "::",
            stringify!(tx_power_level)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_adv_data_t {
    pub adv_data_length: u8,
    pub adv_data: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_adv_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_adv_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_adv_data_t>(),
        32usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_adv_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_adv_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_adv_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_data_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_data_t),
            "::",
            stringify!(adv_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_data) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_data_t),
            "::",
            stringify!(adv_data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_scan_response_data_t {
    pub scan_response_data_length: u8,
    pub scan_response_data: [u8; 31usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_scan_response_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_scan_response_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_scan_response_data_t>(),
        32usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_scan_response_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_scan_response_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_scan_response_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_response_data_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_response_data_t),
            "::",
            stringify!(scan_response_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_response_data) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_response_data_t),
            "::",
            stringify!(scan_response_data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_adv_enable_t {
    pub adv_enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_adv_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_adv_enable_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_adv_enable_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_adv_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_adv_enable_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_adv_enable_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_enable_t),
            "::",
            stringify!(adv_enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_scan_params_t {
    pub le_scan_type: u8,
    pub le_scan_interval: u16,
    pub le_scan_window: u16,
    pub own_address_type: u8,
    pub scanning_filter_policy: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_scan_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_scan_params_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_scan_params_t>(),
        7usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_scan_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_scan_params_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_scan_params_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_scan_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_params_t),
            "::",
            stringify!(le_scan_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_scan_interval) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_params_t),
            "::",
            stringify!(le_scan_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_scan_window) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_params_t),
            "::",
            stringify!(le_scan_window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).own_address_type) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_params_t),
            "::",
            stringify!(own_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scanning_filter_policy) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_params_t),
            "::",
            stringify!(scanning_filter_policy)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_scan_enable_t {
    pub le_scan_enable: u8,
    pub filter_duplicates: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_scan_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_scan_enable_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_scan_enable_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_scan_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_scan_enable_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_scan_enable_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_scan_enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_enable_t),
            "::",
            stringify!(le_scan_enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter_duplicates) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_scan_enable_t),
            "::",
            stringify!(filter_duplicates)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_create_conn_t {
    pub le_scan_interval: u16,
    pub le_scan_window: u16,
    pub initiator_filter_policy: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub own_address_type: u8,
    pub conn_interval_min: u16,
    pub conn_interval_max: u16,
    pub max_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_length: u16,
    pub max_ce_length: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_create_conn_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_create_conn_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_create_conn_t>(),
        25usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_create_conn_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_create_conn_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_create_conn_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_scan_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(le_scan_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_scan_window) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(le_scan_window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initiator_filter_policy) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(initiator_filter_policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_address_type) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(peer_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_address) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(peer_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).own_address_type) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(own_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_interval_min) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(conn_interval_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_interval_max) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(conn_interval_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_latency) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supervision_timeout) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(supervision_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_ce_length) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(min_ce_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_ce_length) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_create_conn_t),
            "::",
            stringify!(max_ce_length)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_filter_accept_list_size_return_t {
    pub filter_accept_list_size: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_filter_accept_list_size_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_filter_accept_list_size_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_filter_accept_list_size_return_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_filter_accept_list_size_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_filter_accept_list_size_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_filter_accept_list_size_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter_accept_list_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_filter_accept_list_size_return_t),
            "::",
            stringify!(filter_accept_list_size)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_add_device_to_filter_accept_list_t {
    pub address_type: u8,
    pub address: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_add_device_to_filter_accept_list_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_add_device_to_filter_accept_list_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_add_device_to_filter_accept_list_t>(),
        7usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_add_device_to_filter_accept_list_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_add_device_to_filter_accept_list_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_add_device_to_filter_accept_list_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_filter_accept_list_t),
            "::",
            stringify!(address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_filter_accept_list_t),
            "::",
            stringify!(address)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_device_from_filter_accept_list_t {
    pub address_type: u8,
    pub address: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_remove_device_from_filter_accept_list_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_remove_device_from_filter_accept_list_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_remove_device_from_filter_accept_list_t>(),
        7usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_filter_accept_list_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_remove_device_from_filter_accept_list_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_remove_device_from_filter_accept_list_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_filter_accept_list_t),
            "::",
            stringify!(address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_filter_accept_list_t),
            "::",
            stringify!(address)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_conn_update_t {
    pub conn_handle: u16,
    pub conn_interval_min: u16,
    pub conn_interval_max: u16,
    pub max_latency: u16,
    pub supervision_timeout: u16,
    pub min_ce_length: u16,
    pub max_ce_length: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_conn_update_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_conn_update_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_conn_update_t>(),
        14usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_conn_update_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_conn_update_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_conn_update_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_update_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_interval_min) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_update_t),
            "::",
            stringify!(conn_interval_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_interval_max) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_update_t),
            "::",
            stringify!(conn_interval_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_latency) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_update_t),
            "::",
            stringify!(max_latency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supervision_timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_update_t),
            "::",
            stringify!(supervision_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_ce_length) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_update_t),
            "::",
            stringify!(min_ce_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_ce_length) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_update_t),
            "::",
            stringify!(max_ce_length)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_host_channel_classification_t {
    pub channel_map: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_host_channel_classification_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_host_channel_classification_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_host_channel_classification_t>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_host_channel_classification_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_host_channel_classification_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_host_channel_classification_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_map) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_host_channel_classification_t),
            "::",
            stringify!(channel_map)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_channel_map_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_channel_map_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_channel_map_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_channel_map_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_channel_map_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_channel_map_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_read_channel_map_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_channel_map_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_channel_map_return_t {
    pub conn_handle: u16,
    pub channel_map: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_channel_map_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_channel_map_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_channel_map_return_t>(),
        7usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_channel_map_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_channel_map_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_read_channel_map_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_channel_map_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_map) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_channel_map_return_t),
            "::",
            stringify!(channel_map)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_remote_features_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_remote_features_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_remote_features_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_remote_features_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_remote_features_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_remote_features_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_read_remote_features_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_remote_features_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_encrypt_t {
    pub key: [u8; 16usize],
    pub plaintext_data: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_encrypt_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_encrypt_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_encrypt_t>(),
        32usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_encrypt_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_encrypt_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_encrypt_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_encrypt_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).plaintext_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_encrypt_t),
            "::",
            stringify!(plaintext_data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_encrypt_return_t {
    pub encrypted_data: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_encrypt_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_encrypt_return_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_encrypt_return_t>(),
        16usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_encrypt_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_encrypt_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_encrypt_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypted_data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_encrypt_return_t),
            "::",
            stringify!(encrypted_data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_rand_return_t {
    pub random_number: u64,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_rand_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_rand_return_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_rand_return_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_rand_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_rand_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_rand_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).random_number) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_rand_return_t),
            "::",
            stringify!(random_number)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_enable_encryption_t {
    pub conn_handle: u16,
    pub random_number: [u8; 8usize],
    pub encrypted_diversifier: [u8; 2usize],
    pub long_term_key: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_enable_encryption_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_enable_encryption_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_enable_encryption_t>(),
        28usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_enable_encryption_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_enable_encryption_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_enable_encryption_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enable_encryption_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).random_number) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enable_encryption_t),
            "::",
            stringify!(random_number)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).encrypted_diversifier) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enable_encryption_t),
            "::",
            stringify!(encrypted_diversifier)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).long_term_key) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enable_encryption_t),
            "::",
            stringify!(long_term_key)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_long_term_key_request_reply_t {
    pub conn_handle: u16,
    pub long_term_key: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_long_term_key_request_reply_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_long_term_key_request_reply_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_long_term_key_request_reply_t>(),
        18usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_long_term_key_request_reply_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_long_term_key_request_reply_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_reply_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).long_term_key) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_reply_t),
            "::",
            stringify!(long_term_key)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_long_term_key_request_reply_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_long_term_key_request_reply_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_long_term_key_request_reply_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_long_term_key_request_reply_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_reply_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_long_term_key_request_reply_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_reply_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_reply_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_long_term_key_request_negative_reply_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_long_term_key_request_negative_reply_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_long_term_key_request_negative_reply_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_long_term_key_request_negative_reply_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_negative_reply_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_long_term_key_request_negative_reply_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_negative_reply_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_negative_reply_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_supported_states_return_t {
    #[doc = "  See the table in Core_v5.3, Vol 4, Part E, Section 7.8.27."]
    pub le_states: [u8; 8usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_supported_states_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_supported_states_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_supported_states_return_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_supported_states_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_supported_states_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_supported_states_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_states) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_supported_states_return_t),
            "::",
            stringify!(le_states)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_test_end_return_t {
    pub num_packets: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_test_end_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_test_end_return_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_test_end_return_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_test_end_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_test_end_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_test_end_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_packets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_test_end_return_t),
            "::",
            stringify!(num_packets)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_data_length_t {
    pub conn_handle: u16,
    pub tx_octets: u16,
    pub tx_time: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_data_length_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_data_length_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_data_length_t>(),
        6usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_data_length_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_data_length_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_data_length_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_data_length_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_octets) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_data_length_t),
            "::",
            stringify!(tx_octets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_data_length_t),
            "::",
            stringify!(tx_time)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_data_length_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_data_length_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_data_length_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_data_length_return_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_data_length_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_data_length_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_data_length_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_data_length_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_suggested_default_data_length_return_t {
    pub suggested_max_tx_octets: u16,
    pub suggested_max_tx_time: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_suggested_default_data_length_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_suggested_default_data_length_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_suggested_default_data_length_return_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_suggested_default_data_length_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_suggested_default_data_length_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_suggested_default_data_length_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suggested_max_tx_octets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_suggested_default_data_length_return_t),
            "::",
            stringify!(suggested_max_tx_octets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suggested_max_tx_time) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_suggested_default_data_length_return_t),
            "::",
            stringify!(suggested_max_tx_time)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_write_suggested_default_data_length_t {
    pub suggested_max_tx_octets: u16,
    pub suggested_max_tx_time: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_write_suggested_default_data_length_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_write_suggested_default_data_length_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_write_suggested_default_data_length_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_write_suggested_default_data_length_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_write_suggested_default_data_length_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_write_suggested_default_data_length_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suggested_max_tx_octets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_write_suggested_default_data_length_t),
            "::",
            stringify!(suggested_max_tx_octets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).suggested_max_tx_time) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_write_suggested_default_data_length_t),
            "::",
            stringify!(suggested_max_tx_time)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_add_device_to_resolving_list_t {
    pub peer_identity_address_type: u8,
    pub peer_identity_address: [u8; 6usize],
    pub peer_irk: [u8; 16usize],
    pub local_irk: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_add_device_to_resolving_list_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_add_device_to_resolving_list_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_add_device_to_resolving_list_t>(),
        39usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_add_device_to_resolving_list_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_add_device_to_resolving_list_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_add_device_to_resolving_list_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_identity_address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_resolving_list_t),
            "::",
            stringify!(peer_identity_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_identity_address) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_resolving_list_t),
            "::",
            stringify!(peer_identity_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_irk) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_resolving_list_t),
            "::",
            stringify!(peer_irk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_irk) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_resolving_list_t),
            "::",
            stringify!(local_irk)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_device_from_resolving_list_t {
    pub peer_identity_address_type: u8,
    pub peer_identity_address: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_remove_device_from_resolving_list_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_remove_device_from_resolving_list_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_remove_device_from_resolving_list_t>(),
        7usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_resolving_list_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_remove_device_from_resolving_list_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_remove_device_from_resolving_list_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_identity_address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_resolving_list_t),
            "::",
            stringify!(peer_identity_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_identity_address) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_resolving_list_t),
            "::",
            stringify!(peer_identity_address)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_resolving_list_size_return_t {
    pub resolving_list_size: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_resolving_list_size_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_resolving_list_size_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_resolving_list_size_return_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_resolving_list_size_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_resolving_list_size_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_resolving_list_size_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resolving_list_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_resolving_list_size_return_t),
            "::",
            stringify!(resolving_list_size)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_address_resolution_enable_t {
    pub address_resolution_enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_address_resolution_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_address_resolution_enable_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_address_resolution_enable_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_address_resolution_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_address_resolution_enable_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_address_resolution_enable_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address_resolution_enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_address_resolution_enable_t),
            "::",
            stringify!(address_resolution_enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_resolvable_private_address_timeout_t {
    pub rpa_timeout: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_resolvable_private_address_timeout_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_resolvable_private_address_timeout_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_resolvable_private_address_timeout_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_resolvable_private_address_timeout_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_resolvable_private_address_timeout_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_resolvable_private_address_timeout_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rpa_timeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_resolvable_private_address_timeout_t),
            "::",
            stringify!(rpa_timeout)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_max_data_length_return_t {
    pub supported_max_tx_octets: u16,
    pub supported_max_tx_time: u16,
    pub supported_max_rx_octets: u16,
    pub supported_max_rx_time: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_max_data_length_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_max_data_length_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_max_data_length_return_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_max_data_length_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_max_data_length_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_max_data_length_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_max_tx_octets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_max_data_length_return_t),
            "::",
            stringify!(supported_max_tx_octets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_max_tx_time) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_max_data_length_return_t),
            "::",
            stringify!(supported_max_tx_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_max_rx_octets) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_max_data_length_return_t),
            "::",
            stringify!(supported_max_rx_octets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_max_rx_time) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_max_data_length_return_t),
            "::",
            stringify!(supported_max_rx_time)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_phy_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_phy_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_phy_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_phy_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_phy_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_phy_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_read_phy_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_phy_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_phy_return_t {
    pub conn_handle: u16,
    pub tx_phy: u8,
    pub rx_phy: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_phy_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_phy_return_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_phy_return_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_phy_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_phy_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_read_phy_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_phy_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_phy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_phy_return_t),
            "::",
            stringify!(tx_phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_phy) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_phy_return_t),
            "::",
            stringify!(rx_phy)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_default_phy_t {
    pub all_phys: u8,
    pub tx_phys: u8,
    pub rx_phys: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_default_phy_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_default_phy_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_default_phy_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_default_phy_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_default_phy_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_default_phy_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).all_phys) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_default_phy_t),
            "::",
            stringify!(all_phys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_phys) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_default_phy_t),
            "::",
            stringify!(tx_phys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_phys) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_default_phy_t),
            "::",
            stringify!(rx_phys)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_phy_t {
    pub conn_handle: u16,
    pub all_phys: u8,
    pub tx_phys: u8,
    pub rx_phys: u8,
    pub phy_options: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_phy_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_phy_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_phy_t>(),
        7usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_phy_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_phy_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_phy_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_phy_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).all_phys) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_phy_t),
            "::",
            stringify!(all_phys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_phys) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_phy_t),
            "::",
            stringify!(tx_phys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_phys) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_phy_t),
            "::",
            stringify!(rx_phys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy_options) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_phy_t),
            "::",
            stringify!(phy_options)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_adv_set_random_address_t {
    pub adv_handle: u8,
    pub random_address: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_adv_set_random_address_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_adv_set_random_address_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_adv_set_random_address_t>(),
        7usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_adv_set_random_address_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_adv_set_random_address_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_adv_set_random_address_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_set_random_address_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).random_address) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_adv_set_random_address_t),
            "::",
            stringify!(random_address)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_ext_adv_params_t {
    pub adv_handle: u8,
    pub adv_event_properties: u16,
    pub primary_adv_interval_min: [u8; 3usize],
    pub primary_adv_interval_max: [u8; 3usize],
    pub primary_adv_channel_map: u8,
    pub own_address_type: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub adv_filter_policy: u8,
    pub adv_tx_power: i8,
    pub primary_adv_phy: u8,
    pub secondary_adv_max_skip: u8,
    pub secondary_adv_phy: u8,
    pub adv_sid: u8,
    pub scan_request_notification_enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_ext_adv_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_ext_adv_params_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_params_t>(),
        25usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_ext_adv_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_params_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_ext_adv_params_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_event_properties) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(adv_event_properties)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).primary_adv_interval_min) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(primary_adv_interval_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).primary_adv_interval_max) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(primary_adv_interval_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).primary_adv_channel_map) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(primary_adv_channel_map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).own_address_type) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(own_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_address_type) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(peer_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_address) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(peer_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_filter_policy) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(adv_filter_policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_tx_power) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(adv_tx_power)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).primary_adv_phy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(primary_adv_phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secondary_adv_max_skip) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(secondary_adv_max_skip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).secondary_adv_phy) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(secondary_adv_phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_sid) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(adv_sid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_request_notification_enable) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_t),
            "::",
            stringify!(scan_request_notification_enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_ext_adv_params_return_t {
    pub selected_tx_power: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_ext_adv_params_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_ext_adv_params_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_params_return_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_ext_adv_params_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_params_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_ext_adv_params_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selected_tx_power) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_params_return_t),
            "::",
            stringify!(selected_tx_power)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_ext_adv_data_t {
    pub adv_handle: u8,
    pub operation: u8,
    pub fragment_preference: u8,
    pub adv_data_length: u8,
    pub adv_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_ext_adv_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_ext_adv_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_data_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_ext_adv_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_ext_adv_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_data_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_data_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fragment_preference) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_data_t),
            "::",
            stringify!(fragment_preference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_data_length) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_data_t),
            "::",
            stringify!(adv_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_data_t),
            "::",
            stringify!(adv_data)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_ext_scan_response_data_t {
    pub adv_handle: u8,
    pub operation: u8,
    pub fragment_preference: u8,
    pub scan_response_data_length: u8,
    pub scan_response_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_ext_scan_response_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_ext_scan_response_data_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_ext_scan_response_data_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_ext_scan_response_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_ext_scan_response_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_ext_scan_response_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_response_data_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_response_data_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fragment_preference) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_response_data_t),
            "::",
            stringify!(fragment_preference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_response_data_length) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_response_data_t),
            "::",
            stringify!(scan_response_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scan_response_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_response_data_t),
            "::",
            stringify!(scan_response_data)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_ext_adv_enable_t {
    pub enable: u8,
    pub num_sets: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_ext_adv_enable_array_params_t>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_ext_adv_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_ext_adv_enable_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_ext_adv_enable_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_ext_adv_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_ext_adv_enable_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_ext_adv_enable_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_enable_t),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_sets) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_enable_t),
            "::",
            stringify!(num_sets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_params) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_adv_enable_t),
            "::",
            stringify!(array_params)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_max_adv_data_length_return_t {
    pub max_adv_data_length: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_max_adv_data_length_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_max_adv_data_length_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_max_adv_data_length_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_max_adv_data_length_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_max_adv_data_length_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_max_adv_data_length_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_adv_data_length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_max_adv_data_length_return_t),
            "::",
            stringify!(max_adv_data_length)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t {
    pub num_supported_adv_sets: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_supported_adv_sets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t),
            "::",
            stringify!(num_supported_adv_sets)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_adv_set_t {
    pub adv_handle: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_remove_adv_set_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_remove_adv_set_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_remove_adv_set_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_remove_adv_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_remove_adv_set_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_remove_adv_set_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_remove_adv_set_t),
            "::",
            stringify!(adv_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_params_t {
    pub adv_handle: u8,
    pub periodic_adv_interval_min: u16,
    pub periodic_adv_interval_max: u16,
    pub periodic_adv_properties: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_periodic_adv_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_periodic_adv_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_params_t>(),
        7usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_periodic_adv_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_params_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_periodic_adv_params_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_params_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic_adv_interval_min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_params_t),
            "::",
            stringify!(periodic_adv_interval_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic_adv_interval_max) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_params_t),
            "::",
            stringify!(periodic_adv_interval_max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic_adv_properties) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_params_t),
            "::",
            stringify!(periodic_adv_properties)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_periodic_adv_data_t {
    pub adv_handle: u8,
    pub operation: u8,
    pub adv_data_length: u8,
    pub adv_data: __IncompleteArrayField<u8>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_periodic_adv_data_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_periodic_adv_data_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_data_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_periodic_adv_data_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_data_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_periodic_adv_data_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_data_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_data_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_data_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_data_t),
            "::",
            stringify!(adv_data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_data) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_data_t),
            "::",
            stringify!(adv_data)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_enable_t {
    pub enable: u8,
    pub adv_handle: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_periodic_adv_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_periodic_adv_enable_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_enable_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_periodic_adv_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_enable_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_periodic_adv_enable_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_enable_t),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_enable_t),
            "::",
            stringify!(adv_handle)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_ext_scan_params_t {
    pub own_address_type: u8,
    pub scanning_filter_policy: u8,
    pub scanning_phys: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_ext_scan_params_array_params_t>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_ext_scan_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_ext_scan_params_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_ext_scan_params_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_ext_scan_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_ext_scan_params_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_ext_scan_params_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).own_address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_params_t),
            "::",
            stringify!(own_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scanning_filter_policy) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_params_t),
            "::",
            stringify!(scanning_filter_policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scanning_phys) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_params_t),
            "::",
            stringify!(scanning_phys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_params) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_params_t),
            "::",
            stringify!(array_params)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_ext_scan_enable_t {
    pub enable: u8,
    pub filter_duplicates: u8,
    pub duration: u16,
    pub period: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_ext_scan_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_ext_scan_enable_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_ext_scan_enable_t>(),
        6usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_ext_scan_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_ext_scan_enable_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_ext_scan_enable_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_enable_t),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter_duplicates) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_enable_t),
            "::",
            stringify!(filter_duplicates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_enable_t),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_ext_scan_enable_t),
            "::",
            stringify!(period)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_ext_create_conn_t {
    pub initiator_filter_policy: u8,
    pub own_address_type: u8,
    pub peer_address_type: u8,
    pub peer_address: [u8; 6usize],
    pub initiating_phys: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_ext_create_conn_array_params_t>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_ext_create_conn_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_ext_create_conn_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_ext_create_conn_t>(),
        10usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_ext_create_conn_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_ext_create_conn_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_ext_create_conn_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initiator_filter_policy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_ext_create_conn_t),
            "::",
            stringify!(initiator_filter_policy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).own_address_type) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_ext_create_conn_t),
            "::",
            stringify!(own_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_address_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_ext_create_conn_t),
            "::",
            stringify!(peer_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_address) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_ext_create_conn_t),
            "::",
            stringify!(peer_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initiating_phys) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_ext_create_conn_t),
            "::",
            stringify!(initiating_phys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_params) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_ext_create_conn_t),
            "::",
            stringify!(array_params)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_create_sync_t {
    pub options: u8,
    pub adv_sid: u8,
    pub adv_address_type: u8,
    pub adv_address: [u8; 6usize],
    pub skip: u16,
    pub sync_timeout: u16,
    pub sync_cte_type: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_periodic_adv_create_sync_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_periodic_adv_create_sync_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_create_sync_t>(),
        14usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_create_sync_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t),
            "::",
            stringify!(options)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_sid) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t),
            "::",
            stringify!(adv_sid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_address_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t),
            "::",
            stringify!(adv_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_address) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t),
            "::",
            stringify!(adv_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sync_timeout) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t),
            "::",
            stringify!(sync_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sync_cte_type) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_create_sync_t),
            "::",
            stringify!(sync_cte_type)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_terminate_sync_t {
    pub sync_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_periodic_adv_terminate_sync_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_periodic_adv_terminate_sync_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_terminate_sync_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_periodic_adv_terminate_sync_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_terminate_sync_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_periodic_adv_terminate_sync_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sync_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_terminate_sync_t),
            "::",
            stringify!(sync_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_add_device_to_periodic_adv_list_t {
    pub adv_address_type: u8,
    pub adv_address: [u8; 6usize],
    pub adv_sid: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_add_device_to_periodic_adv_list_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_add_device_to_periodic_adv_list_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_add_device_to_periodic_adv_list_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_add_device_to_periodic_adv_list_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_add_device_to_periodic_adv_list_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_add_device_to_periodic_adv_list_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_periodic_adv_list_t),
            "::",
            stringify!(adv_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_address) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_periodic_adv_list_t),
            "::",
            stringify!(adv_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_sid) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_add_device_to_periodic_adv_list_t),
            "::",
            stringify!(adv_sid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t {
    pub adv_address_type: u8,
    pub adv_address: [u8; 6usize],
    pub adv_sid: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t),
            "::",
            stringify!(adv_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_address) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t),
            "::",
            stringify!(adv_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_sid) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t),
            "::",
            stringify!(adv_sid)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_periodic_adv_list_size_return_t {
    pub periodic_adv_list_size: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_periodic_adv_list_size_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_periodic_adv_list_size_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_periodic_adv_list_size_return_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_periodic_adv_list_size_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_periodic_adv_list_size_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_periodic_adv_list_size_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic_adv_list_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_periodic_adv_list_size_return_t),
            "::",
            stringify!(periodic_adv_list_size)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_transmit_power_return_t {
    pub min_tx_power: i8,
    pub max_tx_power: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_transmit_power_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_transmit_power_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_transmit_power_return_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_read_transmit_power_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_transmit_power_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_read_transmit_power_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_tx_power) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_transmit_power_return_t),
            "::",
            stringify!(min_tx_power)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_tx_power) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_transmit_power_return_t),
            "::",
            stringify!(max_tx_power)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_rf_path_compensation_return_t {
    pub rf_tx_path_compensation_value: i16,
    pub rf_rx_path_compensation_value: i16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_rf_path_compensation_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_rf_path_compensation_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_rf_path_compensation_return_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_rf_path_compensation_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_rf_path_compensation_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_rf_path_compensation_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_tx_path_compensation_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_rf_path_compensation_return_t),
            "::",
            stringify!(rf_tx_path_compensation_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_rx_path_compensation_value) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_rf_path_compensation_return_t),
            "::",
            stringify!(rf_rx_path_compensation_value)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_write_rf_path_compensation_t {
    pub rf_tx_path_compensation_value: i16,
    pub rf_rx_path_compensation_value: i16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_write_rf_path_compensation_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_write_rf_path_compensation_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_write_rf_path_compensation_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_write_rf_path_compensation_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_write_rf_path_compensation_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_write_rf_path_compensation_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_tx_path_compensation_value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_write_rf_path_compensation_t),
            "::",
            stringify!(rf_tx_path_compensation_value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rf_rx_path_compensation_value) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_write_rf_path_compensation_t),
            "::",
            stringify!(rf_rx_path_compensation_value)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_privacy_mode_t {
    pub peer_identity_address_type: u8,
    pub peer_identity_address: [u8; 6usize],
    pub privacy_mode: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_privacy_mode_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_privacy_mode_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_privacy_mode_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_privacy_mode_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_privacy_mode_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_set_privacy_mode_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_identity_address_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_privacy_mode_t),
            "::",
            stringify!(peer_identity_address_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).peer_identity_address) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_privacy_mode_t),
            "::",
            stringify!(peer_identity_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).privacy_mode) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_privacy_mode_t),
            "::",
            stringify!(privacy_mode)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_connless_cte_transmit_params_t {
    pub adv_handle: u8,
    pub cte_length: u8,
    pub cte_type: u8,
    pub cte_count: u8,
    pub switching_pattern_length: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_connless_cte_transmit_params_array_params_t>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_connless_cte_transmit_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_connless_cte_transmit_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_connless_cte_transmit_params_t>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_connless_cte_transmit_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cte_length) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t),
            "::",
            stringify!(cte_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cte_type) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t),
            "::",
            stringify!(cte_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cte_count) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t),
            "::",
            stringify!(cte_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).switching_pattern_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t),
            "::",
            stringify!(switching_pattern_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_params) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_params_t),
            "::",
            stringify!(array_params)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_connless_cte_transmit_enable_t {
    pub adv_handle: u8,
    pub cte_enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_connless_cte_transmit_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_connless_cte_transmit_enable_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_connless_cte_transmit_enable_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_enable_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_connless_cte_transmit_enable_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_enable_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_enable_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cte_enable) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_connless_cte_transmit_enable_t),
            "::",
            stringify!(cte_enable)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_le_set_conn_cte_transmit_params_t {
    pub conn_handle: u16,
    pub cte_types: u8,
    pub switching_pattern_length: u8,
    pub array_params: __IncompleteArrayField<sdc_hci_le_set_conn_cte_transmit_params_array_params_t>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_conn_cte_transmit_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_conn_cte_transmit_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_conn_cte_transmit_params_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_conn_cte_transmit_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cte_types) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t),
            "::",
            stringify!(cte_types)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).switching_pattern_length) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t),
            "::",
            stringify!(switching_pattern_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).array_params) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_t),
            "::",
            stringify!(array_params)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_conn_cte_response_enable_t {
    pub conn_handle: u16,
    pub enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_conn_cte_response_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_conn_cte_response_enable_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_conn_cte_response_enable_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_conn_cte_response_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_conn_cte_response_enable_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_conn_cte_response_enable_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_cte_response_enable_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_cte_response_enable_t),
            "::",
            stringify!(enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_conn_cte_response_enable_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_conn_cte_response_enable_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_conn_cte_response_enable_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_conn_cte_response_enable_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_conn_cte_response_enable_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_conn_cte_response_enable_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_conn_cte_response_enable_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_conn_cte_response_enable_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_antenna_information_return_t {
    pub supported_switching_sampling_rates: u8,
    pub num_antennae: u8,
    pub max_switching_pattern_length: u8,
    pub max_cte_length: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_antenna_information_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_antenna_information_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_antenna_information_return_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_antenna_information_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_antenna_information_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_antenna_information_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supported_switching_sampling_rates) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_antenna_information_return_t),
            "::",
            stringify!(supported_switching_sampling_rates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_antennae) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_antenna_information_return_t),
            "::",
            stringify!(num_antennae)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_switching_pattern_length) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_antenna_information_return_t),
            "::",
            stringify!(max_switching_pattern_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_cte_length) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_antenna_information_return_t),
            "::",
            stringify!(max_cte_length)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_receive_enable_t {
    pub sync_handle: u16,
    pub enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_periodic_adv_receive_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_periodic_adv_receive_enable_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_receive_enable_t>(),
        3usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_receive_enable_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_receive_enable_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_receive_enable_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sync_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_receive_enable_t),
            "::",
            stringify!(sync_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_receive_enable_t),
            "::",
            stringify!(enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_sync_transfer_t {
    pub conn_handle: u16,
    pub service_data: u16,
    pub sync_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_periodic_adv_sync_transfer_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_periodic_adv_sync_transfer_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_sync_transfer_t>(),
        6usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_periodic_adv_sync_transfer_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_sync_transfer_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_le_periodic_adv_sync_transfer_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_sync_transfer_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).service_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_sync_transfer_t),
            "::",
            stringify!(service_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sync_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_sync_transfer_t),
            "::",
            stringify!(sync_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_set_info_transfer_t {
    pub conn_handle: u16,
    pub service_data: u16,
    pub advertising_handle: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_periodic_adv_set_info_transfer_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_periodic_adv_set_info_transfer_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_set_info_transfer_t>(),
        5usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_set_info_transfer_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).service_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_t),
            "::",
            stringify!(service_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).advertising_handle) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_t),
            "::",
            stringify!(advertising_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t {
    pub conn_handle: u16,
    pub mode: u8,
    pub skip: u16,
    pub sync_timeout: u16,
    pub cte_type: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sync_timeout) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(sync_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cte_type) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(cte_type)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t {
    pub mode: u8,
    pub skip: u16,
    pub sync_timeout: u16,
    pub cte_type: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sync_timeout) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(sync_timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cte_type) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t),
            "::",
            stringify!(cte_type)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_enhanced_read_transmit_power_level_t {
    pub conn_handle: u16,
    pub phy: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_enhanced_read_transmit_power_level_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_enhanced_read_transmit_power_level_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_enhanced_read_transmit_power_level_t>(),
        3usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_enhanced_read_transmit_power_level_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_t),
            "::",
            stringify!(phy)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t {
    pub conn_handle: u16,
    pub phy: u8,
    pub current_tx_power_level: i8,
    pub max_tx_power_level: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t),
            "::",
            stringify!(phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_tx_power_level) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t),
            "::",
            stringify!(current_tx_power_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_tx_power_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t),
            "::",
            stringify!(max_tx_power_level)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_read_remote_transmit_power_level_t {
    pub conn_handle: u16,
    pub phy: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_read_remote_transmit_power_level_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_read_remote_transmit_power_level_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_read_remote_transmit_power_level_t>(),
        3usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_read_remote_transmit_power_level_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_read_remote_transmit_power_level_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_read_remote_transmit_power_level_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_remote_transmit_power_level_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_read_remote_transmit_power_level_t),
            "::",
            stringify!(phy)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_path_loss_reporting_params_t {
    pub conn_handle: u16,
    pub high_threshold: u8,
    pub high_hysteresis: u8,
    pub low_threshold: u8,
    pub low_hysteresis: u8,
    pub min_time_spent: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_path_loss_reporting_params_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_path_loss_reporting_params_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_path_loss_reporting_params_t>(),
        8usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_path_loss_reporting_params_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high_threshold) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_t),
            "::",
            stringify!(high_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).high_hysteresis) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_t),
            "::",
            stringify!(high_hysteresis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).low_threshold) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_t),
            "::",
            stringify!(low_threshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).low_hysteresis) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_t),
            "::",
            stringify!(low_hysteresis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min_time_spent) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_t),
            "::",
            stringify!(min_time_spent)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_path_loss_reporting_params_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_path_loss_reporting_params_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_path_loss_reporting_params_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_path_loss_reporting_params_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_path_loss_reporting_params_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_params_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_path_loss_reporting_enable_t {
    pub conn_handle: u16,
    pub enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_path_loss_reporting_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_path_loss_reporting_enable_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_path_loss_reporting_enable_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_le_set_path_loss_reporting_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_path_loss_reporting_enable_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_enable_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_enable_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_enable_t),
            "::",
            stringify!(enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_transmit_power_reporting_enable_t {
    pub conn_handle: u16,
    pub local_enable: u8,
    pub remote_enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_transmit_power_reporting_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_transmit_power_reporting_enable_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_transmit_power_reporting_enable_t>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_transmit_power_reporting_enable_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).local_enable) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_t),
            "::",
            stringify!(local_enable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).remote_enable) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_t),
            "::",
            stringify!(remote_enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_le_set_data_related_address_changes_t {
    pub adv_handle: u8,
    pub change_reasons: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_le_set_data_related_address_changes_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_le_set_data_related_address_changes_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_le_set_data_related_address_changes_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_le_set_data_related_address_changes_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_le_set_data_related_address_changes_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_le_set_data_related_address_changes_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_data_related_address_changes_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).change_reasons) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_le_set_data_related_address_changes_t),
            "::",
            stringify!(change_reasons)
        )
    );
}
extern "C" {
    #[doc = " @defgroup HCI_VS_API API\n @{\n/\n/** @brief LE Set Event Mask.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.1\n\n The HCI_LE_Set_Event_Mask command is used to control which LE events\n are generated by the HCI for the Host. If the bit in the LE_Event_Mask is set to\n a one, then the event associated with that bit will be enabled. The event mask\n allows the Host to control which events will interrupt it.\n\n The Controller shall ignore those bits which are reserved for future use or\n represent events which it does not support. If the Host sets any of these bits to\n 1, the Controller shall act as if they were set to 0.\n\n For LE events to be generated, the LE Meta event bit in the Event_Mask shall\n also be set. If that bit is not set, then LE events shall not be generated,\n regardless of how the LE_Event_Mask is set.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Event_Mask command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_event_mask(p_params: *const sdc_hci_cmd_le_set_event_mask_t) -> u8;
}
extern "C" {
    #[doc = "  LE Read Buffer Size [v1].\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.2\n\n This command is used to read the maximum size of the data portion of ACL\n data packets and isochronous data packets sent from the Host to the Control-\n ler. The Host shall segment the data transmitted to the Controller according to\n these values so that the HCI ACL Data packets and HCI ISO Data packets will\n contain data up to this size. The HCI_LE_Read_Buffer_Size command also\n returns the total number of HCI LE ACL Data packets and isochronous data\n packets that can be stored in the data buffers of the Controller. The HCI_LE_-\n Read_Buffer_Size command shall be issued by the Host before it sends any\n data to an LE Controller (see Section 4.1.1). If the Controller supports HCI ISO\n Data packets, it shall return non-zero values for the ISO_Data_Packet_Length\n and Total_Num_ISO_Data_Packets parameters.\n\n If the Controller returns a length value of zero for ACL data packets, the Host\n shall use the HCI_Read_Buffer_Size command to determine the size of the\n data buffers (shared between BR/EDR and LE transports).\n\n Note: Both the HCI_Read_Buffer_Size command and the HCI_LE_Read_-\n Buffer_Size command may return buffer length and number of packets param-\n eter values that are nonzero. This allows a Controller to offer different buffers\n and number of buffers for BR/EDR data packets and LE data packets.\n\n The LE_ACL_Data_Packet_Length return parameter shall be used to deter-\n mine the maximum size of the L2CAP PDU segments that are contained in\n ACL data packets, and which are transferred from the Host to the Controller to\n be broken up into packets by the Link Layer. The Total_Num_LE_ACL_Data_-\n Packets return parameter contains the total number of HCI ACL Data packets\n that can be stored in the data buffers of the Controller. The Host determines\n how to divide the buffers between different connection handles.\n\n The ISO_Data_Packet_Length return parameter shall be used to determine the\n maximum size of the SDU segments that are contained in isochronous data\n packets, and which are transferred from the Host to the Controller. The\n Total_Num_ISO_Data_Packets return parameter contains the total number of\n isochronous data packets that can be stored in the data buffers of the\n Controller. The Host determines how to divide the buffers between different\n connection handle(s).\n\n Note: The LE_ACL_Data_Packet_Length and ISO_Data_Packet_Length\n return parameters do not include the length of the HCI ACL Data packet header\n or the HCI ISO Data packet header respectively.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Buffer_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_buffer_size(p_return: *mut sdc_hci_cmd_le_read_buffer_size_return_t) -> u8;
}
extern "C" {
    #[doc = "  LE Read Local Supported Features.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.3\n\n This command requests the list of the supported LE features for the Controller.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Local_Supported_Features command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_local_supported_features(
        p_return: *mut sdc_hci_cmd_le_read_local_supported_features_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Random Address.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.4\n\n The HCI_LE_Set_Random_Address command is used by the Host to set the\n LE Random Device Address in the Controller (see [Vol 6] Part B, Section 1.3).\n\n If this command is used to change the address, the new random address shall\n take effect for advertising no later than the next successful HCI_LE_Set_-\n Advertising_Enable command, for scanning no later than the next successful\n HCI_LE_Set_Scan_Enable command or HCI_LE_Set_Extended_Scan_-\n Enable command, and for initiating no later than the next successful HCI_LE_-\n Create_Connection command or HCI_LE_Extended_Create_Connection\n command.\n\n Note: If the extended advertising commands are in use, this command only\n affects the address used for scanning and initiating. The addresses used for\n advertising are set by the HCI_LE_Set_Advertising_Set_Random_Address\n command (see Section 7.8.52).\n\n If the Host issues this command when any of advertising (created using legacy\n advertising commands), scanning, or initiating are enabled, the Controller shall\n return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Random_Address command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_random_address(p_params: *const sdc_hci_cmd_le_set_random_address_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Advertising Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.5\n\n The HCI_LE_Set_Advertising_Parameters command is used by the Host to set\n the advertising parameters.\n\n The Advertising_Interval_Min shall be less than or equal to the\n Advertising_Interval_Max. The Advertising_Interval_Min and\n Advertising_Interval_Max should not be the same value to enable the\n Controller to determine the best advertising interval given other activities.\n\n For high duty cycle directed advertising, i.e. when Advertising_Type is 0x01\n (ADV_DIRECT_IND, high duty cycle), the Advertising_Interval_Min and\n Advertising_Interval_Max parameters are not used and shall be ignored.\n\n The Advertising_Type is used to determine the packet type that is used for\n advertising when advertising is enabled.\n\n Own_Address_Type parameter indicates the type of address being used in the\n advertising packets.\n\n If Own_Address_Type equals 0x02 or 0x03, the Peer_Address parameter\n contains the peer’s Identity Address and the Peer_Address_Type parameter\n contains the Peer’s Identity Type (i.e. 0x00 or 0x01). These parameters are\n used to locate the corresponding local IRK in the resolving list; this IRK is used\n to generate the own address used in the advertisement.\n\n If directed advertising is performed, i.e. when Advertising_Type is set to 0x01\n (ADV_DIRECT_IND, high duty cycle) or 0x04 (ADV_DIRECT_IND, low duty\n cycle mode), then the Peer_Address_Type and Peer_Address shall be valid.\n\n If Own_Address_Type equals 0x02 or 0x03, the Controller generates the\n peer’s Resolvable Private Address using the peer’s IRK corresponding to the\n peer’s Identity Address contained in the Peer_Address parameter and peer’s\n Identity Address Type (i.e. 0x00 or 0x01) contained in the Peer_Address_Type\n parameter.\n The Advertising_Channel_Map is a bit field that indicates the advertising\n channel indices that shall be used when transmitting advertising packets. At\n least one channel bit shall be set in the Advertising_Channel_Map parameter.\n\n The Advertising_Filter_Policy parameter shall be ignored when directed\n advertising is enabled.\n\n The Host shall not issue this command when advertising is enabled in the\n Controller; if it is the Command Disallowed error code shall be used.\n\n If the advertising interval range provided by the Host (Advertising_Interval_Min,\n Advertising_Interval_Max) is outside the advertising interval range supported\n by the Controller, then the Controller shall return the Unsupported Feature or\n Parameter Value (0x11) error code.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Advertising_Parameters command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_adv_params(p_params: *const sdc_hci_cmd_le_set_adv_params_t) -> u8;
}
extern "C" {
    #[doc = "  LE Read Advertising Physical Channel Tx Power.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.6\n\n The HCI_LE_Read_Advertising_Physical_Channel_Tx_Power command is\n used by the Host to read the transmit power level used for LE advertising\n physical channel packets.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Advertising_Physical_Channel_Tx_Power command\n has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_adv_physical_channel_tx_power(
        p_return: *mut sdc_hci_cmd_le_read_adv_physical_channel_tx_power_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Advertising Data.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.7\n\n The HCI_LE_Set_Advertising_Data command is used to set the data used in\n advertising packets that have a data field.\n Only the significant part of the Advertising_Data should be transmitted in the\n advertising packets, as defined in [Vol 3] Part C, Section 11.\n If advertising is currently enabled, the Controller shall use the new data in\n subsequent advertising events. If an advertising event is in progress when this\n command is issued, the Controller may use the old or new data for that event.\n If advertising is currently disabled, the data shall be kept by the Controller and\n used once advertising is enabled.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Advertising_Data command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_adv_data(p_params: *const sdc_hci_cmd_le_set_adv_data_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Scan Response Data.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.8\n\n This command is used to provide data used in Scanning Packets that have a\n data field.\n\n Only the significant part of the Scan_Response_Data should be transmitted in\n the Scanning Packets, as defined in [Vol 3] Part C, Section 11.\n\n If advertising is currently enabled, the Controller shall use the new data in\n subsequent advertising events. If an advertising event is in progress when this\n command is issued, the Controller may use the old or new data for that event.\n If advertising is currently disabled, the data shall be kept by the Controller and\n used once advertising is enabled.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Scan_Response_Data command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_scan_response_data(p_params: *const sdc_hci_cmd_le_set_scan_response_data_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Advertising Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.9\n\n The HCI_LE_Set_Advertising_Enable command is used to request the Con-\n troller to start or stop advertising. The Controller manages the timing of adver-\n tisements as per the advertising parameters given in the\n HCI_LE_Set_Advertising_Parameters command.\n\n The Controller shall continue advertising until the Host issues an HCI_LE_-\n Set_Advertising_Enable command with Advertising_Enable set to 0x00\n (Advertising is disabled). a connection is created using the advertising, or the\n Advertising is timed out due to high duty cycle Directed Advertising. In these\n cases, advertising is then disabled.\n\n If Advertising_Enable is set to 0x01, the advertising parameters' Own_-\n Address_Type parameter is set to 0x00, and the device does not have a public\n address, the Controller should return an error code which should be Invalid HCI\n Command Parameters (0x12).\n\n If Advertising_Enable is set to 0x01, the advertising parameters' Own_-\n Address_Type parameter is set to 0x01, and the random address for the device\n has not been initialized using the HCI_LE_Set_Random_Address command,\n the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If Advertising_Enable is set to 0x01, the advertising parameters' Own_-\n Address_Type parameter is set to 0x02, the Controller's resolving list did not\n contain a matching entry, and the device does not have a public address, the\n Controller should return an error code which should be Invalid HCI Command\n Parameters (0x12).\n\n If Advertising_Enable is set to 0x01, the advertising parameters' Own_-\n Address_Type parameter is set to 0x03, the controller's resolving list did not\n contain a matching entry, and the random address for the device has not been\n initialized using the HCI_LE_Set_Random_Address command, the Controller\n shall return the error code Invalid HCI Command Parameters.(0x12).\n\n Enabling advertising when it is already enabled can cause the random address\n to change. Disabling advertising when it is already disabled has no effect.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Advertising_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the Advertising_Type parameter is 0x01 (ADV_DIRECT_IND, high duty\n cycle) and the directed advertising fails to create a connection, an\n HCI_LE_Connection_Complete or HCI_LE_Enhanced_Connection_Complete\n event shall be generated with the Status code set to Advertising Timeout\n (0x3C).\n\n If the Advertising_Type parameter is 0x00 (ADV_IND), 0x01 (ADV_DIRECT_-\n IND, high duty cycle), or 0x04 (ADV_DIRECT_IND, low duty cycle) and a\n connection is created, an HCI_LE_Connection_Complete or HCI_LE_-\n Enhanced_Connection_Complete event shall be generated.\n\n Note: There is a possible race condition if the Advertising_Enable parameter is\n set to 0x00 (Disable) and the Advertising_Type parameter is 0x00, 0x01, or\n 0x04. The advertisements might not be stopped before a connection is\n created, and therefore both the HCI_Command_Complete event and either an\n HCI_LE_Connection_Complete event or an HCI_LE_Enhanced_Connection_-\n Complete event could be generated. This can also occur when high duty cycle\n directed advertising is timed out and this command disables advertising.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_adv_enable(p_params: *const sdc_hci_cmd_le_set_adv_enable_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Scan Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.10\n\n The HCI_LE_Set_Scan_Parameters command is used to set the scan\n parameters.\n\n The LE_Scan_Type parameter controls the type of scan to perform.\n\n The LE_Scan_Interval and LE_Scan_Window parameters are recommenda-\n tions from the Host on how long (LE_Scan_Window) and how frequently\n (LE_Scan_Interval) the Controller should scan (See [Vol 6] Part B, Section\n 4.4.3). The LE_Scan_Window parameter shall always be set to a value smaller\n or equal to the value set for the LE_Scan_Interval parameter. If they are set to\n the same value scanning should be run continuously.\n\n Own_Address_Type parameter indicates the type of address being used in the\n scan request packets.\n\n The Host shall not issue this command when scanning is enabled in the\n Controller; if it is the Command Disallowed error code shall be used.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Scan_Parameters command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_scan_params(p_params: *const sdc_hci_cmd_le_set_scan_params_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Scan Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.11\n\n The HCI_LE_Set_Scan_Enable command is used to start and stop scanning\n for legacy PDUs (but not extended PDUs, even if the device supports extended\n advertising). Scanning is used to discover advertising devices nearby.\n\n The Filter_Duplicates parameter controls whether the Link Layer should filter\n out duplicate advertising reports (Filtering_Enabled) to the Host, or if the Link\n Layer should generate advertising reports for each packet received\n (Filtering_Disabled). See [Vol 6] Part B, Section 4.4.3.5. If LE_Scan_Enable is\n set to 0x00 then Filter_Duplicates shall be ignored.\n\n If LE_Scan_Enable is set to 0x01, the scanning parameters' Own_Address_-\n Type parameter is set to 0x00 or 0x02, and the device does not have a public\n address, the Controller should return an error code which should be Invalid HCI\n Command Parameters (0x12).\n\n If LE_Scan_Enable is set to 0x01, the scanning parameters' Own_Address_-\n Type parameter is set to 0x01 or 0x03, and the random address for the device\n has not been initialized using the HCI_LE_Set_Random_Address command,\n the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n If the LE_Scan_Enable parameter is set to 0x01 and scanning is already\n enabled, any change to the Filter_Duplicates setting shall take effect.\n\n Disabling scanning when it is disabled has no effect.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Scan_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n Zero or more HCI_LE_Advertising_Report events are generated by the\n Controller based on legacy advertising packets received and the duplicate\n filtering. More than one advertising packet may be reported in each\n HCI_LE_Advertising_Report event. No report shall be issued for extended\n advertising PDUs.\n\n When the Scanning_Filter_Policy is set to 0x02 or 0x03 (see Section 7.8.10)\n and a directed advertisement was received where the advertiser used a\n resolvable private address which the Controller is unable to resolve, an\n HCI_LE_Directed_Advertising_Report event shall be generated instead of an\n HCI_LE_Advertising_Report event.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_scan_enable(p_params: *const sdc_hci_cmd_le_set_scan_enable_t) -> u8;
}
extern "C" {
    #[doc = "  LE Create Connection.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.12\n\n The HCI_LE_Create_Connection command is used to create an ACL\n connection, with the local device in the Central role, to a connectable\n advertiser.\n If a connection is created with the local device in the Peripheral role while this\n command is pending, then this command remains pending.\n\n The LE_Scan_Interval and LE_Scan_Window parameters are recommenda-\n tions from the Host on how long (LE_Scan_Window) and how frequently\n (LE_Scan_Interval) the Controller should scan. The LE_Scan_Window param-\n eter shall be set to a value smaller or equal to the value set for the LE_Scan_-\n Interval parameter. If both are set to the same value, scanning should run\n continuously.\n The Initiator_Filter_Policy is used to determine whether the Filter Accept List is\n used. If the Filter Accept List is not used, the Peer_Address_Type and the\n Peer_Address parameters specify the address type and address of the\n advertising device to connect to.\n Peer_Address_Type parameter indicates the type of address used in the\n connectable advertisement sent by the peer. The Host shall not set\n Peer_Address_Type to either 0x02 or 0x03 if both the Host and the Controller\n support the HCI_LE_Set_Privacy_Mode command. If a Controller that\n supports the HCI_LE_Set_Privacy_Mode command receives the\n HCI_LE_Create_Connection command with Peer_Address_Type set to either\n 0x02 or 0x03, it may use either device privacy mode or network privacy mode\n for that peer device.\n Peer_Address parameter indicates the Peer’s Public Device Address, Random\n (static) Device Address, Non-Resolvable Private Address or Resolvable\n Private Address depending on the Peer_Address_Type parameter.\n Own_Address_Type parameter indicates the type of address being used in the\n connection request packets.\n The Connection_Interval_Min and Connection_Interval_Max parameters\n define the minimum and maximum allowed connection interval. The\n Connection_Interval_Min parameter shall not be greater than the\n Connection_Interval_Max parameter.\n The Max_Latency parameter defines the maximum allowed Peripheral latency\n (see [Vol 6] Part B, Section 4.5.1).\n The Supervision_Timeout parameter defines the link supervision timeout for\n the connection. The Supervision_Timeout in milliseconds shall be larger than\n (1 + Max_Latency) * Connection_Interval_Max * 2, where\n Connection_Interval_Max is given in milliseconds. (See [Vol 6] Part B, Section\n 4.5.2).\n The Min_CE_Length and Max_CE_Length parameters provide the Controller\n with the expected minimum and maximum length of the connection events.\n The Min_CE_Length parameter shall be less than or equal to the\n Max_CE_Length parameter. The Controller is not required to use these values.\n If the Host issues this command when another HCI_LE_Create_Connection\n command is pending in the Controller, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If the Own_Address_Type parameter is set to 0x00 and the device does not\n have a public address, the Controller should return an error code which should\n be Invalid HCI Command Parameters (0x12).\n If the Own_Address_Type parameter is set to 0x01 and the random address for\n the device has not been initialized using the HCI_LE_Set_Random_Address\n command, the Controller shall return the error code Invalid HCI Command\n Parameters (0x12).\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy\n parameter is set to 0x00, the Controller's resolving list did not contain a\n matching entry, and the device does not have a public address, the Controller\n should return an error code which should be Invalid HCI Command Parameters\n (0x12).\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy\n parameter is set to 0x01, and the device does not have a public address, the\n Controller should return an error code which should be Invalid HCI Command\n Parameters (0x12).\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy\n parameter is set to 0x00, the controller's resolving list did not contain a\n matching entry, and the random address for the device has not been initialized\n using the HCI_LE_Set_Random_Address command, the Controller shall return\n the error code Invalid HCI Command Parameters (0x12).\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy\n parameter is set to 0x01, and the random address for the device has not been\n initialized using the HCI_LE_Set_Random_Address command, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Create_Connection command, the\n Controller sends the HCI_Command_Status event to the Host. An HCI_LE_-\n Connection_Complete or HCI_LE_Enhanced_Connection_Complete event\n shall be generated when a connection is created because of this command or\n the connection creation procedure is cancelled; until one of these events is\n generated, the command is considered pending. If a connection is created and\n the Controller supports the LE Channel Selection Algorithm #2 feature, this\n event shall be immediately followed by an HCI_LE_Channel_Selection_-\n Algorithm event.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_create_conn(p_params: *const sdc_hci_cmd_le_create_conn_t) -> u8;
}
extern "C" {
    #[doc = "  LE Create Connection Cancel.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.13\n\n The HCI_LE_Create_Connection_Cancel command is used to cancel the\n HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection\n commands.\n\n If no HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection\n command is pending, then the Controller shall return the error code Command\n Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Create_Connection_Cancel command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the cancellation was successful then, after the HCI_Command_Complete\n event for the HCI_LE_Create_Connection_Cancel command, either an LE\n Connection Complete or an HCI_LE_Enhanced_Connection_Complete event\n shall be generated. In either case, the event shall be sent with the error code\n Unknown Connection Identifier (0x02).\n\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_create_conn_cancel() -> u8;
}
extern "C" {
    #[doc = "  LE Read Filter Accept List Size.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.14\n\n The HCI_LE_Read_Filter_Accept_List_Size command is used to read the total\n number of Filter Accept List entries that can be stored in the Controller.\n\n Note: The number of entries that can be stored is not fixed and the Controller\n can change it at any time (e.g. because the memory used to store the Filter\n Accept List can also be used for other purposes).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Filter_Accept_List_Size command has completed,\n an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_filter_accept_list_size(
        p_return: *mut sdc_hci_cmd_le_read_filter_accept_list_size_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Clear Filter Accept List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.15\n\n The HCI_LE_Clear_Filter_Accept_List command is used to clear the Filter\n Accept List stored in the Controller.\n\n This command shall not be used when:\n • any advertising filter policy uses the Filter Accept List and advertising is\n   enabled,\n • the scanning filter policy uses the Filter Accept List and scanning is enabled,\n   or\n • the initiator filter policy uses the Filter Accept List and an\n   HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection\n   command is pending.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Clear_Filter_Accept_List command has completed, an\n HCI_Command_Complete event shall be generated.\n\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_clear_filter_accept_list() -> u8;
}
extern "C" {
    #[doc = "  LE Add Device To Filter Accept List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.16\n\n The HCI_LE_Add_Device_To_Filter_Accept_List command is used to add a\n single device to the Filter Accept List stored in the Controller.\n\n This command shall not be used when:\n • any advertising filter policy uses the Filter Accept List and advertising is\n   enabled,\n • the scanning filter policy uses the Filter Accept List and scanning is enabled,\n   or\n • the initiator filter policy uses the Filter Accept List and an\n   HCI_LE_Create_Connection or HCI_LE_Extended_Create_Connection\n   command is pending.\n\n When a Controller cannot add a device to the Filter Accept List because there\n is no space available, it shall return the error code Memory Capacity Exceeded\n (0x07).\n\n If the device is already in the Filter Accept List, the Controller should not add\n the device to the Filter Accept List again and should return success.\n\n Address shall be ignored when Address_Type is set to 0xFF.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Add_Device_To_Filter_Accept_List command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_add_device_to_filter_accept_list(
        p_params: *const sdc_hci_cmd_le_add_device_to_filter_accept_list_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Remove Device From Filter Accept List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.17\n\n The HCI_LE_Remove_Device_From_Filter_Accept_List command is used to\n remove a single device from the Filter Accept List stored in the Controller.\n This command shall not be used when:\n • any advertising filter policy uses the Filter Accept List and advertising is\n   enabled,\n • the scanning filter policy uses the Filter Accept List and scanning is enabled,\n   or\n • the initiator filter policy uses the Filter Accept List and an HCI_LE_-\n   Create_Connection or HCI_LE_Extended_Create_Connection command is\n   pending.\n\n Address shall be ignored when Address_Type is set to 0xFF.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_Device_From_Filter_Accept_List command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_device_from_filter_accept_list(
        p_params: *const sdc_hci_cmd_le_remove_device_from_filter_accept_list_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Connection Update.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.18\n\n The HCI_LE_Connection_Update command is used to change the ACL\n connection parameters. This command may be issued on both the Central and\n Peripheral.\n\n The Connection_Interval_Min and Connection_Interval_Max parameters are\n used to define the minimum and maximum allowed connection interval. The\n Connection_Interval_Min parameter shall not be greater than the\n Connection_Interval_Max parameter.\n\n The Max_Latency parameter shall define the maximum allowed Peripheral\n latency.\n\n The Supervision_Timeout parameter shall define the link supervision timeout\n for the LE link. The Supervision_Timeout in milliseconds shall be larger than (1\n + Max_Latency) × Subrate_Factor × Connection_Interval_Max × 2, where\n Connection_Interval_Max is given in milliseconds and Subrate_Factor is the\n current subrate factor of the connection.\n\n The Min_CE_Length and Max_CE_Length are information parameters\n providing the Controller with a hint about the expected minimum and maximum\n length of the connection events. The Min_CE_Length shall be less than or\n equal to the Max_CE_Length.\n\n The actual parameter values selected by the Link Layer may be different from\n the parameter values provided by the Host through this command.\n\n If this command completes successfully and the connection interval has\n changed, then the subrating factor shall be set to 1 and the continuation\n number to 0. In this case, Max_Latency must be interpreted in underlying\n connection events. Otherwise the subrating factor and continuation number\n shall be unchanged and Max_Latency must be interpreted in subrated events.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Connection_Update command, the\n Controller sends the HCI_Command_Status event to the Host. The HCI_LE_-\n Connection_Update_Complete event shall be generated after the connection\n parameters have been applied by the Controller or if the command\n subsequently fails.\n\n Note: An HCI_Command_Complete event is not sent by the Controller to\n indicate that this command has been completed. Instead, the HCI_LE_-\n Connection_Update_Complete event indicates that this command has been\n completed.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_conn_update(p_params: *const sdc_hci_cmd_le_conn_update_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Host Channel Classification.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.19\n\n The HCI_LE_Set_Host_Channel_Classification command allows the Host to\n specify a channel classification for the data, secondary advertising, periodic,\n and isochronous physical channels based on its “local information”. This\n classification persists until overwritten with a subsequent\n HCI_LE_Set_Host_Channel_Classification command or until the Controller is\n reset using the HCI_Reset command (see [Vol 6] Part B, Section 4.5.8.1).\n\n If this command is used, the Host should send it within 10 seconds of knowing\n that the channel classification has changed. The interval between two\n successive commands sent shall be at least one second.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Host_Channel_Classification command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_host_channel_classification(
        p_params: *const sdc_hci_cmd_le_set_host_channel_classification_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Channel Map.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.20\n\n The HCI_LE_Read_Channel_Map command returns the current Channel_Map\n for the specified Connection_Handle. The returned value indicates the state of\n the Channel_Map specified by the last transmitted or received Channel_Map\n (in a CONNECT_IND or LL_CHANNEL_MAP_IND message) for the specified\n Connection_Handle, regardless of whether the Central has received an\n acknowledgment. If the connection handle does not identify an ACL\n connection, the Controller shall reject the command and should return the error\n code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Channel_Map command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_channel_map(
        p_params: *const sdc_hci_cmd_le_read_channel_map_t,
        p_return: *mut sdc_hci_cmd_le_read_channel_map_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Remote Features.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.21\n\n This command requests, from the remote device identified by the\n Connection_Handle, the features used on the connection and the features\n supported by the remote device. For details see [Vol 6] Part B, Section 4.6.\n\n This command may be issued on both the Central and Peripheral.\n\n Note: If a connection already exists between the two devices and the features\n have already been fetched on that connection, the Controller may use a\n cached copy of the features.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Read_Remote_Features command,\n the Controller shall send the HCI_Command_Status event to the Host. When\n the Controller has completed the procedure to determine the remote features\n or has determined that it will be using a cached copy, the Controller shall send\n an HCI_LE_Read_Remote_Features_Complete event to the Host.\n\n The HCI_LE_Read_Remote_Features_Complete event contains the status of\n this command and the parameter describing the features used on the\n connection and the features supported by the remote device.\n\n Note: An HCI_Command_Complete event is not sent by the Controller to\n indicate that this command has been completed. Instead, the HCI_LE_Read_-\n Remote_Features_Complete event indicates that this command has been\n completed.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_remote_features(p_params: *const sdc_hci_cmd_le_read_remote_features_t) -> u8;
}
extern "C" {
    #[doc = "  LE Encrypt.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.22\n\n The HCI_LE_Encrypt command is used to request the Controller to encrypt the\n Plaintext_Data in the command using the Key given in the command and\n returns the Encrypted_Data to the Host. The AES-128 bit block cypher is\n defined in NIST Publication FIPS-197 (http://csrc.nist.gov/publications/fips/\n fips197/fips-197.pdf).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Encrypt command has completed, an HCI_Command_-\n Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_encrypt(
        p_params: *const sdc_hci_cmd_le_encrypt_t,
        p_return: *mut sdc_hci_cmd_le_encrypt_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Rand.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.23\n\n The HCI_LE_Rand command is used to request the Controller to generate 8\n octets of random data to be sent to the Host. The Random_Number shall be\n generated according to [Vol 2] Part H, Section 2 if the LE Feature (LE\n Encryption) is supported.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Rand command has completed, an HCI_Command_-\n Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_rand(p_return: *mut sdc_hci_cmd_le_rand_return_t) -> u8;
}
extern "C" {
    #[doc = "  LE Enable Encryption.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.27.\n\n The HCI_LE_Enable_Encryption command is used to authenticate the given\n encryption key associated with the remote device specified by the\n Connection_Handle, and once authenticated will encrypt the connection. The\n parameters are as defined in [Vol 3] Part H, Section 2.4.4.\n\n If the connection is already encrypted then the Controller shall pause\n connection encryption before attempting to authenticate the given encryption\n key, and then re-encrypt the connection. While encryption is paused no user\n data shall be transmitted.\n\n If the Connection_Handle parameter identifies an ACL with an associated CIS\n that has been created, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n On an authentication failure, the connection shall be automatically\n disconnected by the Link Layer. If this command succeeds, then the\n connection shall be encrypted.\n\n This command shall only be used when the local device's role is Central.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Enable_Encryption command it\n shall send the HCI_Command_Status event to the Host. If the connection is not\n encrypted when this command is issued, an HCI_Encryption_Change event\n shall occur when encryption has been started for the connection. If the connec-\n tion is encrypted when this command is issued, an HCI_Encryption_Key_-\n Refresh_Complete event shall occur when encryption has been resumed.\n\n Note: An HCI_Command_Complete event is not sent by the Controller to\n indicate that this command has been completed. Instead, the\n HCI_Encryption_Change or HCI_Encryption_Key_Refresh_Complete events\n indicate that this command has been completed.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_enable_encryption(p_params: *const sdc_hci_cmd_le_enable_encryption_t) -> u8;
}
extern "C" {
    #[doc = "  LE Long Term Key Request Reply.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.25\n\n The HCI_LE_Long_Term_Key_Request_Reply command is used to reply to an\n HCI_LE_Long_Term_Key_Request event from the Controller, and specifies the\n Long_Term_Key parameter that shall be used for this Connection_Handle. The\n Long_Term_Key is used as defined in [Vol 6] Part B, Section 5.1.3.\n This command shall only be used when the local device’s role is Peripheral.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Long_Term_Key_Request_Reply command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_long_term_key_request_reply(
        p_params: *const sdc_hci_cmd_le_long_term_key_request_reply_t,
        p_return: *mut sdc_hci_cmd_le_long_term_key_request_reply_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Long Term Key Request Negative Reply.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.26\n\n The HCI_LE_Long_Term_Key_Request_Negative_Reply command is used to\n reply to an HCI_LE_Long_Term_Key_Request event from the Controller if the\n Host cannot provide a Long Term Key for this Connection_Handle.\n\n This command shall only be used when the local device’s role is Peripheral.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Long_Term_Key_Request_Negative_Reply command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_long_term_key_request_negative_reply(
        p_params: *const sdc_hci_cmd_le_long_term_key_request_negative_reply_t,
        p_return: *mut sdc_hci_cmd_le_long_term_key_request_negative_reply_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Supported States.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.27\n\n The HCI_LE_Read_Supported_States command reads the states and state\n combinations that the Link Layer supports. See [Vol 6] Part B, Section 1.1.1.\n\n LE_States is an 8-octet bit field. If a bit is set to 1 then this state or state\n combination is supported by the Controller. Multiple bits in LE_States may be\n set to 1 to indicate support for multiple state and state combinations.\n\n Note: This command only provides information about the supported states that\n can be used with legacy advertising. It does not provide information about\n states, and combinations of states, that can only be used with the extended\n advertising commands (see Section 3.1.1).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Supported_States command has completed, an\n HCI_Command_Complete event will be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_supported_states(p_return: *mut sdc_hci_cmd_le_read_supported_states_return_t) -> u8;
}
extern "C" {
    #[doc = "  LE Test End.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.30\n\n This command is used to stop any test which is in progress. The Num_Packets\n for a transmitter test shall be reported as 0x0000. The Num_Packets is an\n unsigned number and contains the number of received packets.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Test_End command has completed, an HCI_Command_-\n Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_test_end(p_return: *mut sdc_hci_cmd_le_test_end_return_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Data Length.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.33\n\n The HCI_LE_Set_Data_Length command allows the Host to suggest the\n maximum transmission payload size and maximum packet transmission time\n (connMaxTxOctets and connMaxTxTime - see [Vol 6] Part B, Section 4.5.10) to\n be used for LL Data PDUs on a given connection. The Controller may use\n smaller or larger values based on local information.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Data_Length command has completed, an\n HCI_Command_Complete event shall be generated.\n\n If the command causes the maximum transmission packet size or maximum\n packet transmission time to change, an HCI_LE_Data_Length_Change event\n shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_data_length(
        p_params: *const sdc_hci_cmd_le_set_data_length_t,
        p_return: *mut sdc_hci_cmd_le_set_data_length_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Suggested Default Data Length.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.34\n\n The HCI_LE_Read_Suggested_Default_Data_Length command allows the\n Host to read the Host's suggested values (Suggested_Max_TX_Octets and\n Suggested_Max_TX_Time) for the Controller's maximum transmitted number\n of payload octets and maximum packet transmission time for packets\n containing LL Data PDUs to be used for new connections (see [Vol 6] Part B,\n Section 4.5.10).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Suggested_Default_Data_Length command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_suggested_default_data_length(
        p_return: *mut sdc_hci_cmd_le_read_suggested_default_data_length_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Write Suggested Default Data Length.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.35\n\n The HCI_LE_Write_Suggested_Default_Data_Length command allows the\n Host to specify its suggested values for the Controller's maximum transmission\n number of payload octets and maximum packet transmission time for packets\n containing LL Data PDUs to be used for new connections. The Controller may\n use smaller or larger values for connInitialMaxTxOctets and\n connInitialMaxTxTime based on local information. (See [Vol 6] Part B, Section\n 4.5.10).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Write_Suggested_Default_Data_Length command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_write_suggested_default_data_length(
        p_params: *const sdc_hci_cmd_le_write_suggested_default_data_length_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Add Device To Resolving List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.38\n\n The HCI_LE_Add_Device_To_Resolving_List command is used to add one\n device to the resolving list used to generate and resolve Resolvable Private\n Addresses in the Controller.\n\n This command shall not be used when address resolution is enabled in the\n Controller and:\n • Advertising (other than periodic advertising) is enabled,\n • Scanning is enabled, or\n • an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n   HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n This command may be used at any time when address resolution is disabled in\n the Controller.\n\n The added device shall be set to Network Privacy mode.\n\n When a Controller cannot add a device to the list because there is no space\n available, it shall return the error code Memory Capacity Exceeded (0x07).\n\n If an entry already exists in the resolving list with the same four parameter\n values, the Controller shall either reject the command or not add the device to\n the resolving list again and return success. If the command is rejected then the\n error code Invalid HCI Command Parameters (0x12) should be used.\n\n If there is an existing entry in the resolving list with the same\n Peer_Identity_Address and Peer_Identity_Address_Type, or with the same\n Peer_IRK, the Controller should return the error code Invalid HCI Command\n Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Add_Device_To_Resolving_List command has completed,\n an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_add_device_to_resolving_list(
        p_params: *const sdc_hci_cmd_le_add_device_to_resolving_list_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Remove Device From Resolving List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.39\n\n The HCI_LE_Remove_Device_From_Resolving_List command is used to\n remove one device from the resolving list used to resolve Resolvable Private\n Addresses in the Controller.\n\n This command shall not be used when address resolution is enabled in the\n Controller and:\n • Advertising (other than periodic advertising) is enabled,\n • Scanning is enabled, or\n • an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n   HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n This command may be used at any time when address resolution is disabled in\n the Controller.\n\n When a Controller cannot remove a device from the resolving list because it is\n not found, it shall return the error code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_Device_From_Resolving_List command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_device_from_resolving_list(
        p_params: *const sdc_hci_cmd_le_remove_device_from_resolving_list_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Clear Resolving List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.40\n\n The HCI_LE_Clear_Resolving_List command is used to remove all devices\n from the resolving list used to resolve Resolvable Private Addresses in the\n Controller.\n\n This command shall not be used when address resolution is enabled in the\n Controller and:\n • Advertising (other than periodic advertising) is enabled,\n • Scanning is enabled, or\n • an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n   HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n This command may be used at any time when address resolution is disabled in\n the Controller.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Clear_Resolving_List command has completed, an\n HCI_Command_Complete event shall be generated.\n\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_clear_resolving_list() -> u8;
}
extern "C" {
    #[doc = "  LE Read Resolving List Size.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.41\n\n The HCI_LE_Read_Resolving_List_Size command is used to read the total\n number of entries in the resolving list that can be stored in the Controller.\n\n Note: The number of entries that can be stored is not fixed and the Controller\n can change it at any time (e.g. because the memory used to store the list can\n also be used for other purposes).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Resolving_List_Size command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_resolving_list_size(
        p_return: *mut sdc_hci_cmd_le_read_resolving_list_size_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Address Resolution Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.44\n\n The HCI_LE_Set_Address_Resolution_Enable command is used to enable\n resolution of Resolvable Private Addresses in the Controller. This causes the\n Controller to use the resolving list whenever the Controller receives a local or\n peer Resolvable Private Address.\n\n This command shall not be used when:\n • Advertising (other than periodic advertising) is enabled,\n • Scanning is enabled, or\n • an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n   HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n Enabling address resolution when it is already enabled, or disabling it when it is\n already disabled, has no effect.\n\n The requirements in [Vol 6] Part B, Section 6 related to the generation of\n Resolvable Private Addresses and the privacy of the device are independent of\n this command.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Address_Resolution_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_address_resolution_enable(
        p_params: *const sdc_hci_cmd_le_set_address_resolution_enable_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Resolvable Private Address Timeout.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.45\n\n The HCI_LE_Set_Resolvable_Private_Address_Timeout command set the\n length of time the Controller uses a Resolvable Private Address before a new\n resolvable private address is generated and starts being used.\n\n This timeout applies to all resolvable private addresses generated by the\n Controller.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Resolvable_Private_Address_Timeout command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_resolvable_private_address_timeout(
        p_params: *const sdc_hci_cmd_le_set_resolvable_private_address_timeout_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Maximum Data Length.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.46\n\n The HCI_LE_Read_Maximum_Data_Length command allows the Host to read\n the Controller’s maximum supported payload octets and packet duration times\n for transmission and reception (Supported_Max_TX_Octets, Supported_Max_-\n TX_Time, Supported_Max_RX_Octets, and Supported_Max_RX_Time, see\n [Vol 6] Part B, Section 4.5.10).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Maximum_Data_Length command has completed,\n an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_max_data_length(p_return: *mut sdc_hci_cmd_le_read_max_data_length_return_t) -> u8;
}
extern "C" {
    #[doc = "  LE Read PHY.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.47\n\n The HCI_LE_Read_PHY command is used to read the current transmitter PHY\n and receiver PHY on the connection identified by the Connection_Handle.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_PHY command has completed, an HCI_Command_-\n Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_phy(
        p_params: *const sdc_hci_cmd_le_read_phy_t,
        p_return: *mut sdc_hci_cmd_le_read_phy_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Default PHY.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.48\n\n The HCI_LE_Set_Default_PHY command allows the Host to specify its\n preferred values for the transmitter PHY and receiver PHY to be used for all\n subsequent connections over the LE transport.\n\n The All_PHYs parameter is a bit field that allows the Host to specify, for each\n direction, whether it has no preference among the PHYs that the Controller\n supports in a given direction or whether it has specified particular PHYs that it\n prefers in the TX_PHYs or RX_PHYs parameter.\n\n The TX_PHYs parameter is a bit field that indicates the transmitter PHYs that\n the Host prefers the Controller to use. If the All_PHYs parameter specifies that\n the Host has no preference, the TX_PHYs parameter shall be ignored;\n otherwise at least one bit shall be set to 1.\n\n The RX_PHYs parameter is a bit field that indicates the receiver PHYs that the\n Host prefers the Controller to use. If the All_PHYs parameter specifies that the\n Host has no preference, the RX_PHYs parameter shall be ignored; otherwise\n at least one bit shall be set to 1.\n\n If the Host sets, in the TX_PHYs or RX_PHYs parameter, a bit for a PHY that\n the Controller does not support, including a bit that is reserved for future use,\n the Controller shall return the error code Unsupported Feature or Parameter\n Value (0x11).\n\n If the Controller does not support asymmetric connections (see [Vol 6] Part B,\n Section 4.6.9.1) and the Host sets All_PHYs to 0x00 and TX_PHYs to a\n different value than RX_PHYs, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Default_PHY command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_default_phy(p_params: *const sdc_hci_cmd_le_set_default_phy_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set PHY.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.49\n\n The HCI_LE_Set_PHY command is used to set the PHY preferences for the\n connection identified by the Connection_Handle. The Controller might not be\n able to make the change (e.g. because the peer does not support the\n requested PHY) or may decide that the current PHY is preferable (e.g.,\n because it could not schedule other activities if the requested PHY was used or\n because it requires a PHY that supports Constant Tone Extensions).\n\n The All_PHYs parameter is a bit field that allows the Host to specify, for each\n direction, whether it has no preference among the PHYs that the Controller\n supports in a given direction or whether it has specified particular PHYs that it\n prefers in the TX_PHYs or RX_PHYs parameter.\n\n The TX_PHYs parameter is a bit field that indicates the transmitter PHYs that\n the Host prefers the Controller to use. If the All_PHYs parameter specifies that\n the Host has no preference, the TX_PHYs parameter shall be ignored;\n otherwise at least one bit shall be set to 1.\n\n The RX_PHYs parameter is a bit field that indicates the receiver PHYs that the\n Host prefers the Controller to use. If the All_PHYs parameter specifies that the\n Host has no preference, the RX_PHYs parameter shall be ignored; otherwise\n at least one bit shall be set to 1.\n\n If, for at least one direction, the Host has specified a preference and the current\n PHY is not one of those preferred, the Controller shall request a change.\n Otherwise the Controller may, but need not, request a change.\n\n The PHY preferences provided by the HCI_LE_Set_PHY command override\n those provided via the HCI_LE_Set_Default_PHY command (Section 7.8.48)\n or any preferences previously set using the HCI_LE_Set_PHY command on\n the same connection.\n\n The PHY_Options parameter is a bit field that allows the Host to specify\n options for PHYs. The default value for a new connection shall be all zero bits.\n The Controller may override any preferred coding for transmitting on the LE\n Coded PHY.\n The Host may specify a preferred coding even if it prefers not to use the LE\n Coded transmitter PHY since the Controller may override the PHY preference.\n\n If the Host sets, in the TX_PHYs or RX_PHYs parameter, a bit for a PHY that\n the Controller does not support, including a bit that is reserved for future use,\n the Controller shall return the error code Unsupported Feature or Parameter\n Value (0x11).\n\n If the Controller does not support asymmetric connections (see [Vol 6] Part B,\n Section 4.6.9.1) and the Host sets All_PHYs to 0x00 and TX_PHYs to a\n different value than RX_PHYs, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Set_PHY command, the Controller\n shall send the HCI_Command_Status event to the Host. The HCI_LE_PHY_-\n Update_Complete event shall be generated either when one or both PHY\n changes or when the Controller determines that neither PHY will change\n immediately.\n\n Note: If the peer negotiation resulted in no change to either PHY, this is not an\n error and the HCI_LE_PHY_Update_Complete event will contain a status\n indicating success.\n\n Note: An HCI_Command_Complete event is not sent by the Controller to\n indicate that this command has been completed. Instead, the HCI_LE_PHY_-\n Update_Complete event indicates that this command has been completed.\n The HCI_LE_PHY_Update_Complete event may also be issued autonomously\n by the Link Layer.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_phy(p_params: *const sdc_hci_cmd_le_set_phy_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Advertising Set Random Address.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.52\n\n The HCI_LE_Set_Advertising_Set_Random_Address command is used by the\n Host to set the random device address specified by the Random_Address\n parameter. This address is used in the Controller (see [Vol 6] Part B, Section\n 1.3.2) for the advertiser's address contained in the advertising PDUs for the\n advertising set specified by the Advertising_Handle parameter.\n\n This command may be issued at any time after an advertising set identified by\n the Advertising_Handle parameter has been created using the HCI_LE_Set_-\n Extended_Advertising_Parameters command (see Section 7.8.53). However, if\n the Host issues this command while the advertising set identified by the\n Advertising_Handle parameter is using connectable advertising and is\n enabled, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n If this command is used to change the address, the new random address shall\n take effect for advertising no later than the next successful HCI_LE_-\n Extended_Set_Advertising_Enable command and for periodic advertising no\n later than the next successful HCI_LE_Periodic_Advertising_Enable\n command.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Advertising_Set_Random_Address command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_adv_set_random_address(
        p_params: *const sdc_hci_cmd_le_set_adv_set_random_address_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Extended Advertising Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.53\n\n The HCI_LE_Set_Extended_Advertising_Parameters command is used by the\n Host to set the advertising parameters.\n\n The Advertising_Handle parameter identifies the advertising set whose\n parameters are being configured.\n\n The Advertising_Event_Properties parameter describes the type of advertising\n event that is being configured and its basic properties. The type shall be one\n supported by the Controller. In particular, the following restrictions apply to this\n parameter:\n • If legacy advertising PDU types are being used, then the parameter value\n   shall be one of those specified in Table 7.2. If the advertising set already\n   contains data, the type shall be one that supports advertising data and the\n   amount of data shall not exceed 31 octets.\n                                                            Advertising\n                                                            Event         Advertising\n  Event Type                      PDU Type                  Properties    Data\n\n  Connectable and scannable       ADV_IND                   0b00010011    Supported\n  undirected\n\n  Connectable directed            ADV_DIRECT_IND            0b00010101    Not allowed\n  (low duty cycle)\n\n  Connectable directed            ADV_DIRECT_IND            0b00011101    Not allowed\n  (high duty cycle)\n\n  Scannable undirected            ADV_SCAN_IND              0b00010010    Supported\n\n  Non-connectable and non-        ADV_NONCONN_IND           0b00010000    Supported\n  scannable undirected\n\n Table 7.2: Advertising_Event_Properties values for legacy PDUs\n\n • If extended advertising PDU types are being used (bit 4 = 0) then:\n           The advertisement shall not be both connectable and scannable.\n           High duty cycle directed connectable advertising (≤ 3.75 ms\n           advertising interval) shall not be used (bit 3 = 0).\n\n If the Advertising_Event_Properties parameter does not describe an event type\n supported by the Controller, contains an invalid bit combination, or specifies a\n type that does not support advertising data when the advertising set already\n contains some, the Controller shall return the error code Invalid HCI Command\n Parameters (0x12).\n\n The parameters beginning with “Secondary” are only valid when extended\n advertising PDU types are being used (bit 4 = 0).\n\n The Own_Address_Type parameter shall be ignored for undirected\n anonymous advertising (bit 2 = 0 and bit 5 = 1).\n\n If Directed advertising is selected, the Peer_Address_Type and Peer_Address\n shall be valid and the Advertising_Filter_Policy parameter shall be ignored.\n\n The Primary_Advertising_Interval_Min parameter shall be less than or equal to\n the Primary_Advertising_Interval_Max parameter. The\n Primary_Advertising_Interval_Min and Primary_Advertising_Interval_Max\n parameters should not be the same value so that the Controller can choose the\n best advertising interval given other activities.\n\n For high duty cycle connectable directed advertising event type\n (ADV_DIRECT_IND), the Primary_Advertising_Interval_Min and\n Primary_Advertising_Interval_Max parameters are not used and shall be\n ignored.\n If the primary advertising interval range provided by the Host\n (Primary_Advertising_Interval_Min, Primary_Advertising_Interval_Max) is\n outside the advertising interval range supported by the Controller, then the\n Controller shall return the error code Unsupported Feature or Parameter Value\n (0x11).\n\n The Primary_Advertising_Channel_Map is a bit field that indicates the advertis-\n ing channel indices that shall be used when transmitting advertising packets. At\n least one channel bit shall be set in the Primary_Advertising_Channel_Map\n parameter.\n\n The Own_Address_Type parameter specifies the type of address being used in\n the advertising packets. For random addresses, the address is specified by the\n HCI_LE_Set_Advertising_Set_Random_Address command.\n\n If Own_Address_Type equals 0x02 or 0x03, the Peer_Address parameter\n contains the peer’s Identity Address and the Peer_Address_Type parameter\n contains the peer’s Identity Type (i.e., 0x00 or 0x01). These parameters are\n used to locate the corresponding local IRK in the resolving list; this IRK is used\n to generate their own address used in the advertisement.\n\n The Advertising_TX_Power parameter indicates the maximum power level at\n which the advertising packets are to be transmitted on the advertising physical\n channels. The Controller shall choose a power level lower than or equal to the\n one specified by the Host.\n\n The Primary_Advertising_PHY parameter indicates the PHY on which the\n advertising packets are transmitted on the primary advertising physical\n channel. If legacy advertising PDUs are being used, the\n Primary_Advertising_PHY shall indicate the LE 1M PHY. The\n Secondary_Advertising_PHY parameter indicates the PHY on which the\n advertising packets are be transmitted on the secondary advertising physical\n channel. If the Host specifies a PHY that is not supported by the Controller,\n including a value that is reserved for future use, it should return the error code\n Unsupported Feature or Parameter Value (0x11). If Constant Tone Extensions\n are enabled for the advertising set and Secondary_Advertising_PHY specifies\n a PHY that does not allow Constant Tone Extensions, the Controller shall\n return the error code Command Disallowed (0x0C).\n\n The Secondary_Advertising_Max_Skip parameter is the maximum number of\n advertising events that can be skipped before the AUX_ADV_IND can be sent.\n\n The Advertising_SID parameter specifies the value to be transmitted in the\n Advertising SID subfield of the ADI field of the Extended Header of those\n advertising physical channel PDUs that have an ADI field. If the advertising set\n only uses PDUs that do not contain an ADI field, Advertising_SID shall be\n ignored.\n\n The Scan_Request_Notification_Enable parameter indicates whether the\n Controller shall send notifications upon the receipt of a scan request PDU that\n is in response to an advertisement from the specified advertising set that\n contains its device address and is from a scanner that is allowed by the\n advertising filter policy.\n\n The Controller shall set the Selected_TX_Power return parameter to the\n transmit power that it will use for transmitting the advertising packets for the\n specified advertising set. The Controller shall only change this value if\n requested by the Host. If the radiated power level will vary between packets\n (e.g., because of frequency-dependent properties of the transmitter) then the\n value should be the best estimate of the maximum power used.\n\n If the Host issues this command when advertising is enabled for the specified\n advertising set, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n If the Host issues this command when periodic advertising is enabled for the\n specified advertising set and connectable, scannable, legacy, or anonymous\n advertising is specified, the Controller shall return the error code Invalid HCI\n Command Parameters (0x12).\n\n If periodic advertising is enabled for the advertising set and the\n Secondary_Advertising_PHY parameter does not specify the PHY currently\n being used for the periodic advertising, the Controller shall return the error\n code Command Disallowed (0x0C).\n\n If the Advertising_Handle does not identify an existing advertising set and the\n Controller is unable to support a new advertising set at present, the Controller\n shall return the error code Memory Capacity Exceeded (0x07).\n\n If the advertising set already contains advertising data or scan response data,\n extended advertising is being used, and the length of the data is greater than\n the maximum that the Controller can transmit within the longest possible\n auxiliary advertising segment consistent with the parameters, the Controller\n shall return the error code Packet Too Long (0x45). If advertising on the LE\n Coded PHY, the S=8 coding shall be assumed.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Advertising_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_adv_params(
        p_params: *const sdc_hci_cmd_le_set_ext_adv_params_t,
        p_return: *mut sdc_hci_cmd_le_set_ext_adv_params_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Extended Advertising Data.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.54\n\n The HCI_LE_Set_Extended_Advertising_Data command is used to set the\n data used in advertising PDUs that have a data field. This command may be\n issued at any time after an advertising set identified by the Advertising_Handle\n parameter has been created using the HCI_LE_Set_Extended_Advertising_-\n Parameters command (see Section 7.8.53), regardless of whether advertising\n in that set is enabled or disabled.\n\n If advertising is currently enabled for the specified advertising set, the\n Controller shall use the new data in subsequent extended advertising events\n for this advertising set. If an extended advertising event is in progress when\n this command is issued, the Controller may use the old or new data for that\n event.\n\n If advertising is currently disabled for the specified advertising set, the data\n shall be kept by the Controller and used once advertising is enabled for that\n set. The data shall be discarded when the advertising set is removed.\n\n Only the significant part of the advertising data should be transmitted in the\n advertising packets as defined in [Vol 3] Part C, Section 11.\n\n The Host may set the advertising data in one or more operations using the\n Operation parameter in the command. If the combined length of the data\n exceeds the capacity of the advertising set identified by the Advertising_-\n Handle parameter (see Section 7.8.57 LE Read Maximum Advertising Data\n Length command) or the amount of memory currently available, all the data\n shall be discarded and the Controller shall return the error code Memory\n Capacity Exceeded (0x07).\n\n If the advertising set uses extended advertising and the combined length of the\n data is greater than the maximum that the Controller can transmit within the\n longest possible auxiliary advertising segment consistent with the current\n parameters of the advertising set (using the current advertising interval if\n advertising is enabled), all the data shall be discarded and the Controller shall\n return the error code Packet Too Long (0x45). If advertising on the LE Coded\n PHY, the S=8 coding shall be assumed.\n If Operation indicates the start of new data (values 0x01 or 0x03), then any\n existing partial or complete advertising data shall be discarded.\n\n If the advertising data is discarded by the command or the combined length of\n the data after the command completes is zero, the advertising set will have no\n advertising data.\n\n If Operation is 0x04, the behavior is the same as if the current advertising data\n had been sent again; this can be used to cause the Advertising DID value to be\n updated (see [Vol 6] Part B, Section 4.4.2.11).\n\n The Fragment_Preference parameter provides a hint to the Controller as to\n whether advertising data should be fragmented.\n\n If the advertising set specifies a type that does not support advertising data, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the advertising set uses legacy advertising PDUs that support advertising\n data and either Operation is not 0x03 or the Advertising_Data_Length\n parameter exceeds 31 octets, the Controller shall return the error code Invalid\n HCI Command Parameters (0x12).\n\n If Operation is 0x04 and:\n • advertising is currently disabled for the advertising set;\n • the advertising set contains no data;\n • the advertising set uses legacy PDUs; or\n • Advertising_Data_Length is not zero;\n\n then the Controller shall return the error code Invalid HCI Command\n Parameters (0x12).\n\n If Operation is not 0x03 or 0x04 and Advertising_Data_Length is zero, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If advertising is currently enabled for the specified advertising set and\n Operation does not have the value 0x03 or 0x04, the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If advertising is currently enabled for the specified advertising set, the\n advertising set uses extended advertising, and the length of the data is greater\n than the maximum that the Controller can transmit within the longest possible\n auxiliary advertising segment consistent with the current parameters of the\n advertising set, the Controller shall return the error code Packet Too Long\n (0x45). If advertising on the LE Coded PHY, the S=8 coding shall be assumed.\n\n If the advertising set corresponding to the Advertising_Handle parameter does\n not exist, then the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Advertising_Data command has completed,\n an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_adv_data(p_params: *const sdc_hci_cmd_le_set_ext_adv_data_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Extended Scan Response Data.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.55\n\n The HCI_LE_Set_Extended_Scan_Response_Data command is used to\n provide scan response data used in scanning response PDUs. This command\n may be issued at any time after the advertising set identified by the Advertis-\n ing_Handle parameter has been created using the HCI_LE_Set_Extended_-\n Advertising_Parameters command (see Section 7.8.53) regardless of whether\n advertising in that set is enabled or disabled.\n\n If advertising is currently enabled for the specified advertising set, the\n Controller shall use the new data in subsequent extended advertising events\n for this advertising set. If an extended advertising event is in progress when\n this command is issued, the Controller may use the old or new data for that\n event.\n\n If advertising is currently disabled for the specified advertising set, the data\n shall be kept by the Controller and used once advertising is enabled for that\n set. The data shall be discarded when the advertising set is removed.\n\n Only the significant part of the scan response data should be transmitted in the\n advertising packets as defined in [Vol 3] Part C, Section 11.\n\n The Host may set the scan response data in one or more operations using the\n Operation parameter in the command. If the combined length of the data\n exceeds the capacity of the advertising set identified by the\n Advertising_Handle parameter (see Section 7.8.57 LE Read Maximum\n Advertising Data Length command) or the amount of memory currently\n available, all the data shall be discarded and the Controller shall return the\n error code Memory Capacity Exceeded (0x07).\n\n If Operation indicates the start of new data (values 0x01 or 0x03), then any\n existing partial or complete scan response data shall be discarded.\n\n If the scan response data is discarded by the command or the combined length\n of the data after the command completes is zero, the advertising set will have\n no scan response data.\n The Fragment_Preference parameter provides a hint to the Controller as to\n whether advertising data should be fragmented.\n\n If the advertising set is non-scannable and the Host uses this command other\n than to discard existing data, the Controller shall return the error code Invalid\n HCI Command Parameters (0x12). If the advertising set uses scannable leg-\n acy advertising PDUs and either Operation is not 0x03 or the Scan_-\n Response_Data_Length parameter exceeds 31 octets, the Controller shall\n return the error code Invalid HCI Command Parameters (0x12).\n\n If Operation is not 0x03 and Scan_Response_Data_Length is zero, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If advertising is currently enabled for the specified advertising set and\n Operation does not have the value 0x03, the Controller shall return the error\n code Command Disallowed (0x0C).\n\n If the advertising set uses extended advertising and the combined length of the\n data is greater than the maximum that the Controller can transmit within the\n longest possible auxiliary advertising segment consistent with the current\n parameters of the advertising set (using the current advertising interval if\n advertising is enabled), all the data shall be discarded and the Controller shall\n return the error code Packet Too Long (0x45). If advertising on the LE Coded\n PHY, the S=8 coding shall be assumed.\n\n If the advertising set uses scannable extended advertising PDUs, advertising is\n currently enabled for the specified advertising set, and Scan_Response_-\n Data_Length is zero, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the advertising set corresponding to the Advertising_Handle parameter does\n not exist, then the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Scan_Response_Data command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_scan_response_data(
        p_params: *const sdc_hci_cmd_le_set_ext_scan_response_data_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Extended Advertising Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.56\n\n The HCI_LE_Set_Extended_Advertising_Enable command is used to request\n the Controller to enable or disable one or more advertising sets using the\n advertising sets identified by the Advertising_Handle[i] parameter. The Control-\n ler manages the timing of advertisements in accordance with the advertising\n parameters given in the HCI_LE_Set_Extended_Advertising_Parameters\n command. The Num_Sets parameter is the number of advertising sets\n contained in the parameter arrays. If Enable and Num_Sets are both set to\n 0x00, then all advertising sets are disabled.\n\n The Controller shall only start an advertising event when the corresponding\n advertising set is enabled. The Controller shall continue advertising until all\n advertising sets have been disabled. An advertising set shall be disabled when\n the Host issues an HCI_LE_Set_Extended_Advertising_Enable command with\n the Enable parameter set to 0x00 (Advertising is disabled), a connection is cre-\n ated using that advertising set, the duration specified in the Duration[i] parame-\n ter expires, or the number of extended advertising events transmitted for the\n set exceeds the Max_Extended_Advertising_Events[i] parameter.\n\n The Duration[i] parameter indicates the duration for which that advertising set\n is enabled. The duration begins at the start of the first advertising event of this\n advertising set. The Controller should not start an extended advertising event\n that it cannot complete within the duration.\n\n If the advertising is high duty cycle connectable directed advertising, then\n Duration[i] shall be less than or equal to 1.28 seconds and shall not be equal to 0.\n\n The Max_Extended_Advertising_Events[i] parameter, if non-zero, indicates the\n maximum number of extended advertising events that shall be sent prior to\n disabling the extended advertising set even if the Duration[i] parameter has not\n expired.\n\n Duration[i] and Max_Extended_Advertising_Events[i] shall be ignored when\n Enable is set to 0x00.\n\n If the HCI_LE_Set_Extended_Advertising_Enable command is sent again for\n an advertising set while that set is enabled, the timer used for the duration and\n the number of events counter are reset and any change to the random address\n shall take effect.\n\n Disabling the advertising set identified by the Advertising_Handle[i] parameter\n does not disable any periodic advertising associated with that set.\n\n Disabling an advertising set that is already disabled has no effect.\n\n If the same advertising set is identified by more than one entry in the\n Advertising_Handle[i] arrayed parameter, then the Controller shall return the\n error code Invalid HCI Command Parameters (0x12).\n\n If the advertising set corresponding to the Advertising_Handle[i] parameter\n does not exist, then the Controller shall return the error code Unknown\n Advertising Identifier (0x42).\n\n The remainder of this section only applies if Enable is set to 0x01.\n\n If Num_Sets is set to 0x00, the Controller shall return the error code Invalid HCI\n Command Parameters (0x12).\n\n If the advertising set contains partial advertising data or partial scan response\n data, the Controller shall return the error code Command Disallowed (0x0C).\n\n If the advertising set uses scannable extended advertising PDUs and no scan\n response data is currently provided, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If the advertising set uses connectable extended advertising PDUs and the\n advertising data in the advertising set will not fit in the AUX_ADV_IND PDU,\n the Controller shall return the error code Invalid HCI Command Parameters\n (0x12).\n\n Note: The maximum amount of data that will fit in the PDU depends on which\n options are selected and on the maximum length of PDU that the Controller is\n able to transmit.\n\n If extended advertising is being used and the length of any advertising data or\n of any scan response data is greater than the maximum that the Controller can\n transmit within the longest possible auxiliary advertising segment consistent\n with the chosen advertising interval, the Controller shall return the error code\n Packet Too Long (0x45). If advertising on the LE Coded PHY, the S=8 coding\n shall be assumed.\n\n If the advertising set's Own_Address_Type parameter is set to 0x00 and the\n device does not have a public address, the Controller should return an error\n code which should be Invalid HCI Command Parameters (0x12).\n\n If the advertising set's Own_Address_Type parameter is set to 0x01 and the\n random address for the advertising set has not been initialized using the\n HCI_LE_Set_Advertising_Set_Random_Address command, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the advertising set's Own_Address_Type parameter is set to 0x02, the\n Controller's resolving list did not contain a matching entry, and the device does\n not have a public address, the Controller should return an error code which\n should be Invalid HCI Command Parameters (0x12).\n\n If the advertising set's Own_Address_Type parameter is set to 0x03, the\n controller's resolving list did not contain a matching entry, and the random\n address for the advertising set has not been initialized using the\n HCI_LE_Set_Advertising_Set_Random_Address command, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Advertising_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n If the Duration[i] parameter is set to a value other than 0x0000, an HCI_LE_-\n Advertising_Set_Terminated event shall be generated when the duration spec-\n ified in the Duration[i] parameter expires. However, if the advertising set is for\n high duty cycle connectable directed advertising and no connection is created\n before the duration expires, an HCI_LE_Connection_Complete or HCI_LE_-\n Enhanced_Connection_Complete event with the Status parameter set to the\n error code Advertising Timeout (0x3C) may be generated instead of or in addi-\n tion to the HCI_LE_Advertising_Set_Terminated event. If the Controller gener-\n ates both events, they may be in either order.\n\n If the Max_Extended_Advertising_Events[i] parameter is set to a value other\n than 0x00, an HCI_LE_Advertising_Set_Terminated event shall be generated\n when the maximum number of extended advertising events has been\n transmitted by the Controller.\n\n If the advertising set is connectable and a connection gets created, an\n HCI_LE_Connection_Complete or HCI_LE_Enhanced_Connection_Complete\n event shall be generated followed by an HCI_LE_Advertising_Set_Terminated\n event with the Status parameter set to 0x00. The Controller should not send\n any other events in between these two events.\n\n Note: If this command is used to disable advertising at about the same time\n that a connection is established or the advertising duration expires, there is a\n possible race condition in that it is possible to receive both an HCI_LE_-\n Connection_Complete, HCI_LE_Enhanced_Connection_Complete, or\n HCI_LE_Advertising_Set_Terminated event and the HCI_Command_-\n Complete event for this command.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_adv_enable(p_params: *const sdc_hci_cmd_le_set_ext_adv_enable_t) -> u8;
}
extern "C" {
    #[doc = "  LE Read Maximum Advertising Data Length.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.57\n\n The HCI_LE_Read_Maximum_Advertising_Data_Length command is used to\n read the maximum length of data supported by the Controller for use as\n advertisement data or scan response data in an advertising event or as\n periodic advertisement data.\n\n Note: The maximum amount may be fragmented across multiple PDUs (see\n [Vol 6] Part B, Section 2.3.4.9).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Maximum_Advertising_Data_Length command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_max_adv_data_length(
        p_return: *mut sdc_hci_cmd_le_read_max_adv_data_length_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Number of Supported Advertising Sets.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.58\n\n The HCI_LE_Read_Number_of_Supported_Advertising_Sets command is\n used to read the maximum number of advertising sets supported by the\n advertising Controller at the same time.\n\n Note: The number of advertising sets that can be supported is not fixed and the\n Controller can change it at any time because the memory used to store\n advertising sets can also be used for other purposes.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Number_of_Supported_Advertising_Sets command\n has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_number_of_supported_adv_sets(
        p_return: *mut sdc_hci_cmd_le_read_number_of_supported_adv_sets_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Remove Advertising Set.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.59\n\n The HCI_LE_Remove_Advertising_Set command is used to remove an\n advertising set from the Controller.\n\n If the advertising set corresponding to the Advertising_Handle parameter does\n not exist, then the Controller shall return the error code Unknown Advertising\n Identifier (0x42). If advertising or periodic advertising on the advertising set is\n enabled, then the Controller shall return the error code Command Disallowed\n (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_Advertising_Set command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_adv_set(p_params: *const sdc_hci_cmd_le_remove_adv_set_t) -> u8;
}
extern "C" {
    #[doc = "  LE Clear Advertising Sets.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.60\n\n The HCI_LE_Clear_Advertising_Sets command is used to remove all existing\n advertising sets from the Controller.\n\n If advertising or periodic advertising is enabled on any advertising set, then the\n Controller shall return the error code Command Disallowed (0x0C).\n\n Note: All advertising sets are cleared on HCI reset.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Clear_Advertising_Sets command has completed, an\n HCI_Command_Complete event shall be generated.\n\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_clear_adv_sets() -> u8;
}
extern "C" {
    #[doc = "  LE Set Periodic Advertising Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.61\n\n The HCI_LE_Set_Periodic_Advertising_Parameters command is used by the\n Host to set the parameters for periodic advertising.\n\n The Advertising_Handle parameter identifies the advertising set whose\n periodic advertising parameters are being configured. If the corresponding\n advertising set does not already exist, then the Controller shall return the error\n code Unknown Advertising Identifier (0x42).\n\n The Periodic_Advertising_Interval_Min parameter shall be less than or equal to\n the Periodic_Advertising_Interval_Max parameter. The Periodic_Advertising_-\n Interval_Min and Periodic_Advertising_Interval_Max parameters should not be\n the same value to enable the Controller to determine the best advertising\n interval given other activities.\n\n The Periodic_Advertising_Properties parameter indicates which fields should\n be included in the advertising packet.\n\n If the advertising set identified by the Advertising_Handle specified scannable,\n connectable, legacy, or anonymous advertising, the Controller shall return the\n error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command when periodic advertising is enabled for the\n specified advertising set, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the Advertising_Handle does not identify an advertising set that is already\n configured for periodic advertising and the Controller is unable to support more\n periodic advertising at present, the Controller shall return the error code\n Memory Capacity Exceeded (0x07).\n\n If the advertising set already contains periodic advertising data and the length\n of the data is greater than the maximum that the Controller can transmit within\n a periodic advertising interval of Periodic_Advertising_Interval_Max, the\n Controller shall return the error code Packet Too Long (0x45). If advertising on\n the LE Coded PHY, the S=8 coding shall be assumed.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_params(p_params: *const sdc_hci_cmd_le_set_periodic_adv_params_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Periodic Advertising Data.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.62\n\n The HCI_LE_Set_Periodic_Advertising_Data command is used to set the data\n used in periodic advertising PDUs. This command may be issued at any time\n after the advertising set identified by the Advertising_Handle parameter has\n been configured for periodic advertising using the HCI_LE_Set_Periodic_-\n Advertising_Parameters command (see Section 7.8.61), regardless of whether\n periodic advertising in that set is enabled or disabled. If the advertising set has\n not been configured for periodic advertising, then the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If periodic advertising is currently enabled for the specified advertising set, the\n Controller shall use the new data in subsequent periodic advertising events for\n this advertising set. If a periodic advertising event is in progress when this\n command is issued, the Controller may use the old or new data for that event.\n\n If periodic advertising is currently disabled for the specified advertising set, the\n data shall be kept by the Controller and used once periodic advertising is\n enabled for that set. The data shall be discarded when the advertising set is\n removed.\n\n Only the significant part of the periodic advertising data should be transmitted\n in the advertising packets as defined in [Vol 3] Part C, Section 11.\n\n The Host may set the periodic advertising data in one or more operations using\n the Operation parameter in the command. If the combined length of the data\n exceeds the capacity of the advertising set identified by the Advertising_-\n Handle parameter (see Section 7.8.57 LE Read Maximum Advertising Data\n Length command) or the amount of memory currently available, all the data\n shall be discarded and the Controller shall return the error code Memory\n Capacity Exceeded (0x07).\n\n If the combined length of the data is greater than the maximum that the Con-\n troller can transmit within the current periodic advertising interval (if periodic\n advertising is currently enabled) or the Periodic_Advertising_Interval_Max for\n the advertising set (if currently disabled), all the data shall be discarded and the\n Controller shall return the error code Packet Too Long (0x45). If advertising on\n the LE Coded PHY, the S=8 coding shall be assumed.\n If Operation indicates the start of new data (values 0x01 or 0x03), then any\n existing partial or complete data shall be discarded.\n\n If Operation is 0x04, then the behavior is the same as if the current periodic\n advertising data had been sent again; this can be used to cause the\n Advertising DID value to be updated (see [Vol 6] Part B, Section 4.4.2.11).\n\n If Operation is 0x04 and:\n • periodic advertising is currently disabled for the advertising set;\n • the periodic advertising set contains no data; or\n • Advertising_Data_Length is not zero;\n\n then the Controller shall return the error code Invalid HCI Command\n Parameters (0x12).\n\n If Operation is not 0x03 or 0x04 and Advertising_Data_Length is zero, then the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the periodic advertising data is discarded by the command or the combined\n length of the data after the command completes is zero, the advertising set will\n have no periodic advertising data.\n\n If periodic advertising is currently enabled for the specified advertising set and\n Operation does not have the value 0x03 or 0x04, then the Controller shall\n return the error code Command Disallowed (0x0C).\n\n If the advertising set corresponding to the Advertising_Handle parameter does\n not exist, then the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Data command has completed,\n an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_data(p_params: *const sdc_hci_cmd_le_set_periodic_adv_data_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Periodic Advertising Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.63\n\n The HCI_LE_Set_Periodic_Advertising_Enable command is used to request\n the Controller to enable or disable the periodic advertising for the advertising\n set specified by the Advertising_Handle parameter (ordinary advertising is not\n affected).\n\n If the advertising set is not currently enabled (see the HCI_LE_Set_Extended_-\n Advertising_Enable command), the periodic advertising is not started until the\n advertising set is enabled. Once the advertising set has been enabled, the\n Controller shall continue periodic advertising until the Host issues an HCI_LE_-\n Set_Periodic_Advertising_Enable command with bit 0 of Enable set to 0 (peri-\n odic advertising is disabled). Disabling the advertising set has no effect on the\n periodic advertising once the advertising set has been enabled.\n\n The Controller manages the timing of advertisements in accordance with the\n advertising parameters given in the HCI_LE_Set_Periodic_Advertising_-\n Parameters command.\n\n If the advertising set corresponding to the Advertising_Handle parameter does\n not exist, the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n If bit 0 of Enable is set to 1 (periodic advertising is enabled) and the advertising\n set contains partial periodic advertising data, the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If bit 0 of Enable is set to 1 and the Host has not issued the HCI_LE_Set_-\n Periodic_Advertising_Parameters command for the advertising set, the Con-\n troller shall either use vendor-specified parameters or return the error code\n Command Disallowed (0x0C).\n\n If bit 0 of Enable is set to 1 and the length of the periodic advertising data is\n greater than the maximum that the Controller can transmit within the chosen\n periodic advertising interval, the Controller shall return the error code Packet\n Too Long (0x45). If advertising on the LE Coded PHY, the S=8 coding shall be\n assumed.\n\n If bit 0 of Enable is set to 1 and the advertising set identified by the\n Advertising_Handle specified scannable, connectable, legacy, or anonymous\n advertising, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n If bit 0 of Enable is set to 0 and the Controller supports the Periodic Advertising\n ADI Support feature, then the Controller shall ignore bit 1.\n\n If bit 1 of Enable is set to 1 and the Controller does not support the Periodic\n Advertising ADI Support feature, the Controller shall return an error which\n should use the error code Unsupported Feature or Parameter Value (0x11).\n\n Enabling periodic advertising when it is already enabled can cause the random\n address to change. Disabling periodic advertising when it is already disabled\n has no effect.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_enable(p_params: *const sdc_hci_cmd_le_set_periodic_adv_enable_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Extended Scan Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.64\n\n The HCI_LE_Set_Extended_Scan_Parameters command is used to set the\n extended scan parameters to be used on the advertising physical channels.\n\n The Scanning_PHYs parameter indicates the PHY(s) on which the advertising\n packets should be received on the primary advertising physical channel. The\n Host may enable one or more scanning PHYs. If the Host specifies a PHY that\n is not supported by the Controller, including a bit that is reserved for future use,\n it should return the error code Unsupported Feature or Parameter Value\n (0x11). The Scan_Type[i], Scan_Interval[i], and Scan_Window[i] parameters\n array elements are ordered in the same order as the set bits in the\n Scanning_PHY parameter, starting from bit 0. The number of array elements is\n determined by the number of bits set in the Scanning_PHY parameter.\n\n The Scan_Type[i] parameter specifies the type of scan to perform.\n\n The Scan_Interval[i] and Scan_Window[i] parameters are recommendations\n from the Host on how long (Scan_Window[i]) and how frequently\n (Scan_Interval[i]) the Controller should scan (see [Vol 6] Part B, Section 4.4.3);\n however the frequency and length of the scan is implementation specific. If the\n requested scan cannot be supported by the implementation, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12).\n\n The Own_Address_Type parameter indicates the type of address being used\n in the scan request packets.\n\n If the Host issues this command when scanning is enabled in the Controller,\n the Controller shall return the error code Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Scan_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_scan_params(p_params: *const sdc_hci_cmd_le_set_ext_scan_params_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Extended Scan Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.65\n\n The HCI_LE_Set_Extended_Scan_Enable command is used to enable or\n disable scanning for both legacy and extended advertising PDUs.\n\n The Enable parameter determines whether scanning is enabled or disabled. If\n it is set to 0x00, the remaining parameters shall be ignored.\n\n If Enable is set to 0x01 and the Host has not issued the HCI_LE_Set_-\n Extended_Scan_Parameters command, the Controller shall either use vendor-\n specified parameters or return the error code Command Disallowed (0x0C).\n\n The Filter_Duplicates parameter controls whether the Link Layer should filter\n out duplicate advertising reports (filtering duplicates enabled) to the Host or if\n the Link Layer should generate advertising reports for each packet received\n (filtering duplicates disabled). See [Vol 6] Part B, Section 4.4.3.5.\n\n If the Filter_Duplicates parameter is set to 0x00, all advertisements received\n from advertisers shall be sent to the Host in advertising report events.\n\n If the Filter_Duplicates parameter is set to 0x01, duplicate advertisements\n should not be sent to the Host in advertising report events until scanning is\n disabled.\n\n If the Filter_Duplicates parameter is set to 0x02, duplicate advertisements in a\n single scan period should not be sent to the Host in advertising report events;\n this setting shall only be used if both Period and Duration are non-zero. If\n Filter_Duplicates is set to 0x02 and either Period or Duration to zero, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Duration parameter is zero or both the Duration parameter and Period\n parameter are non-zero, the Controller shall continue scanning until scanning\n is disabled by the Host issuing an HCI_LE_Set_Extended_Scan_Enable\n command with the Enable parameter set to 0x00 (Scanning is disabled). The\n Period parameter shall be ignored when the Duration parameter is zero.\n\n If the Duration parameter is non-zero and the Period parameter is zero, the\n Controller shall continue scanning until the duration specified in the Duration\n parameter has expired.\n If both the Duration and Period parameters are non-zero and the Duration is\n greater than or equal to the Period, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n When the Duration and Period parameters are non-zero, the Controller shall\n scan for the duration of the Duration parameter within a scan period specified\n by the Period parameter. After the scan period has expired, a new scan period\n shall begin and scanning shall begin again for the duration specified. The scan\n periods continue until the Host disables scanning.\n\n If the HCI_LE_Set_Extended_Scan_Enable command with Enable set to 0x01\n is sent while scanning is already enabled, the timers used for duration and\n period are reset to the new parameter values and a new scan period is started.\n Any change to the Filter_Duplicates setting or the random address shall take\n effect.\n\n Disabling scanning when it is disabled has no effect.\n\n Note: The duration of a scan period refers to the time spent scanning on both\n the primary and secondary advertising physical channels. However, expiry of\n the duration does not prevent the Link Layer from scanning for and receiving\n auxiliary packets of received advertisements.\n\n If Enable is set to 0x01, the scanning parameters' Own_Address_Type\n parameter is set to 0x00 or 0x02, and the device does not have a public\n address, the Controller should return an error code which should be Invalid HCI\n Command Parameters (0x12).\n\n If Enable is set to 0x01, the scanning parameters' Own_Address_Type\n parameter is set to 0x01 or 0x03, and the random address for the device has\n not been initialized using the HCI_LE_Set_Random_Address command, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Extended_Scan_Enable command has completed, an\n HCI_Command_Complete event shall be generated.\n\n Zero or more LE Extended Advertising Reports are generated by the Controller\n based on any advertising packets received and the duplicate filtering in effect.\n More than one advertising packet may be reported in each HCI_LE_-\n Extended_Advertising_Report event.\n\n At the end of a single scan (Duration non-zero but Period zero), an HCI_LE_-\n Scan_Timeout event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_ext_scan_enable(p_params: *const sdc_hci_cmd_le_set_ext_scan_enable_t) -> u8;
}
extern "C" {
    #[doc = "  LE Extended Create Connection.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.66\n\n The HCI_LE_Extended_Create_Connection command is used to create an\n ACL connection, with the local device in the Central role, to a connectable\n advertiser.\n\n If a connection is created with the local device in the Peripheral role while this\n command is pending, then this command remains pending.\n\n The Initiator_Filter_Policy parameter is used to determine whether the Filter\n Accept List is used. If the Filter Accept List is not used, the\n Peer_Address_Type and the Peer_Address parameters specify the address\n type and address of the advertising device to connect to.\n\n The Own_Address_Type parameter indicates the type of address being used\n in the connection request packets.\n\n The Peer_Address_Type parameter indicates the type of address used in the\n connectable advertisement sent by the peer.\n\n The Peer_Address parameter indicates the Peer’s Public Device Address,\n Random (static) Device Address, Non-Resolvable Private Address, or\n Resolvable Private Address depending on the Peer_Address_Type parameter.\n\n The Initiating_PHYs parameter indicates the PHY(s) on which the advertising\n packets should be received on the primary advertising physical channel and\n the PHYs for which connection parameters have been specified. The Host may\n enable one or more initiating PHYs. If the Host specifies a PHY that is not\n supported by the Controller, including a bit that is reserved for future use, the\n latter should return the error code Unsupported Feature or Parameter Value\n (0x11). The array elements of the arrayed parameters are ordered in the same\n order as the set bits in the Initiating_PHYs parameter, starting from bit 0. The\n number of array elements is determined by the number of bits set in the\n Initiating_PHYs parameter. When a connectable advertisement is received and\n a connection request is sent on one PHY, scanning on any other PHYs is\n terminated.\n\n The Scan_Interval[i] and Scan_Window[i] parameters are recommendations\n from the Host on how long (Scan_Window[i]) and how frequently\n (Scan_Interval[i]) the Controller should scan (see [Vol 6] Part B, Section 4.5.3);\n however the frequency and length of the scan is implementation specific. If the\n requested scan cannot be supported by the implementation, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12). If bit 1 is\n set in Initiating_PHYs, the values for the LE 2M PHY shall be ignored.\n\n The Connection_Interval_Min[i] and Connection_Interval_Max[i] parameters\n define the minimum and maximum allowed connection interval. The\n Connection_Interval_Min[i] parameter shall not be greater than the\n Connection_Interval_Max[i] parameter.\n\n The Max_Latency[i] parameter defines the maximum allowed Peripheral\n latency (see [Vol 6] Part B, Section 4.5.1).\n\n The Supervision_Timeout[i] parameter defines the link supervision timeout for\n the connection. The Supervision_Timeout[i] in milliseconds shall be larger than\n (1 + Max_Latency[i]) * Connection_Interval_Max[i] * 2, where Connection_-\n Interval_Max[i] is given in milliseconds (see [Vol 6] Part B, Section 4.5.2).\n\n The Min_CE_Length[i] and Max_CE_Length[i] parameters provide the\n Controller with the expected minimum and maximum length of the connection\n events. The Min_CE_Length[i] parameter shall be less than or equal to the\n Max_CE_Length[i] parameter. The Controller is not required to use these\n values.\n\n Where the connection is made on a PHY whose bit is not set in the Initiating_-\n PHYs parameter, the Controller shall use the Connection_Interval_Min[i],\n Connection_Interval_Max[i], Max_Latency[i], Supervision_Timeout[i],\n Min_CE_Length[i], and Max_CE_Length[i] parameters for an implementation-\n chosen PHY whose bit is set in the Initiating_PHYs parameter.\n\n If the Host issues this command when another HCI_LE_Extended_Create_-\n Connection command is pending in the Controller, the Controller shall return\n the error code Command Disallowed (0x0C).\n\n If the Own_Address_Type parameter is set to 0x00 and the device does not\n have a public address, the Controller should return an error code which should\n be Invalid HCI Command Parameters (0x12).\n If the Own_Address_Type parameter is set to 0x01 and the random address for\n the device has not been initialized using the HCI_LE_Set_Random_Address\n command, the Controller shall return the error code Invalid HCI Command\n Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy\n parameter is set to 0x00, the Controller's resolving list did not contain a\n matching entry, and the device does not have a public address, the Controller\n should return an error code which should be Invalid HCI Command Parameters\n (0x12).\n\n If the Own_Address_Type parameter is set to 0x02, the Initiator_Filter_Policy\n parameter is set to 0x01, and the device does not have a public address, the\n Controller should return an error code which should be Invalid HCI Command\n Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy\n parameter is set to 0x00, the controller's resolving list did not contain a\n matching entry, and the random address for the device has not been initialized\n using the HCI_LE_Set_Random_Address command, the Controller shall return\n the error code Invalid HCI Command Parameters (0x12).\n\n If the Own_Address_Type parameter is set to 0x03, the Initiator_Filter_Policy\n parameter is set to 0x01, and the random address for the device has not been\n initialized using the HCI_LE_Set_Random_Address command, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Initiating_PHYs parameter does not have at least one bit set for a PHY\n allowed for scanning on the primary advertising physical channel, the\n Controller shall return the error code Invalid HCI Command Parameters (0x12).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Extended_Create_Connection com-\n mand, the Controller sends the HCI_Command_Status event to the Host. An\n HCI_LE_Enhanced_Connection_Complete event shall be generated when a\n connection is created because of this command or the connection creation pro-\n cedure is cancelled; until the event is generated, the command is considered\n pending. If a connection is created, this event shall be immediately followed by\n an HCI_LE_Channel_Selection_Algorithm event.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_ext_create_conn(p_params: *const sdc_hci_cmd_le_ext_create_conn_t) -> u8;
}
extern "C" {
    #[doc = "  LE Periodic Advertising Create Sync.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.67\n\n The HCI_LE_Periodic_Advertising_Create_Sync command is used to\n synchronize with a periodic advertising train from an advertiser and begin\n receiving periodic advertising packets.\n\n This command may be issued whether or not scanning is enabled and\n scanning may be enabled and disabled (see the LE Set Extended Scan Enable\n command) while this command is pending. However, synchronization can only\n occur when scanning is enabled. While scanning is disabled, no attempt to\n synchronize will take place.\n\n The Options parameter is used to determine whether the Periodic Advertiser\n List is used, whether HCI_LE_Periodic_Advertising_Report events for this\n periodic advertising train are initially enabled or disabled, and whether\n duplicate reports are filtered or not. If the Periodic Advertiser List is not used,\n the Advertising_SID, Advertiser Address_Type, and Advertiser Address\n parameters specify the periodic advertising device to listen to; otherwise they\n shall be ignored.\n\n The Advertising_SID parameter, if used, specifies the value that must match\n the Advertising SID subfield in the ADI field of the received advertisement for it\n to be used to synchronize.\n\n The Skip parameter specifies the maximum number of consecutive periodic\n advertising events that the receiver may skip after successfully receiving a\n periodic advertising packet.\n\n The Sync_Timeout parameter specifies the maximum permitted time between\n successful receives. If this time is exceeded, synchronization is lost.\n\n The Sync_CTE_Type parameter specifies whether to only synchronize to\n periodic advertising with certain types of Constant Tone Extension (a value of 0\n indicates that the presence or absence of a Constant Tone Extension is\n irrelevant). If the periodic advertising has the wrong type of Constant Tone\n Extension then:\n • If bit 0 of Options is set, the Controller shall ignore this address and SID and\n   continue to search for other periodic advertisements.\n • Otherwise, the Controller shall cancel the synchronization with the error\n   code Unsupported Remote Feature (0x1A).\n\n If the periodic advertiser changes the type of Constant Tone Extension after the\n scanner has synchronized with the periodic advertising, the scanner's Link\n Layer shall remain synchronized.\n\n If the Host sets all the non-reserved bits of the Sync_CTE_Type parameter to\n 1, the Controller shall return the error code Command Disallowed (0x0C).\n\n Irrespective of the value of the Skip parameter, the Controller should stop\n skipping packets before the Sync_Timeout would be exceeded.\n\n If the Host issues this command when another HCI_LE_Periodic_Advertising_-\n Create_Sync command is pending, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If the Host issues this command with bit 0 of Options not set and with\n Advertising_SID, Advertiser_Address_Type, and Advertiser_Address the same\n as those of a periodic advertising train that the Controller is already\n synchronized to, the Controller shall return the error code Connection Already\n Exists (0x0B).\n\n If the Host issues this command and the Controller has insufficient resources to\n handle any more periodic advertising trains, the Controller shall return the error\n code Memory Capacity Exceeded (0x07).\n\n If bit 1 of Options is set to 1 and the Controller supports the Periodic\n Advertising ADI Support feature, then the Controller shall ignore bit 2.\n\n If bit 1 of Options is set to 0, bit 2 is set to 1, and the Controller does not\n support the Periodic Advertising ADI Support feature, then the Controller shall\n return an error which should use the error code Unsupported Feature or\n Parameter Value (0x11).\n\n If bit 1 of the Options parameter is set to 1 and the Controller does not support\n the HCI_LE_Set_Periodic_Advertising_Receive_Enable command, the\n Controller shall return the error code Connection Failed to be Established /\n Synchronization Timeout (0x3E).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Create_Sync command has been\n received, the Controller sends the HCI_Command_Status event to the Host.\n An HCI_LE_Periodic_Advertising_Sync_Established event shall be generated\n when the Controller starts receiving periodic advertising packets.\n\n When the Controller receives periodic advertising packets then, if reporting is\n enabled, it sends HCI_LE_Periodic_Advertising_Report events to the Host.\n\n Note: The HCI_LE_Periodic_Advertising_Sync_Established event can be sent\n as a result of synchronization being canceled by an HCI_LE_Periodic_-\n Advertising_Create_Sync_Cancel command.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_create_sync(p_params: *const sdc_hci_cmd_le_periodic_adv_create_sync_t) -> u8;
}
extern "C" {
    #[doc = "  LE Periodic Advertising Create Sync Cancel.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.68\n\n The HCI_LE_Periodic_Advertising_Create_Sync_Cancel command is used to\n cancel the HCI_LE_Periodic_Advertising_Create_Sync command while it is\n pending.\n\n If the Host issues this command while no HCI_LE_Periodic_Advertising_-\n Create_Sync command is pending, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Create_Sync_Cancel command has\n completed, the Controller sends an HCI_Command_Complete event to the\n Host.\n\n After the HCI_Command_Complete is sent and if the cancellation was\n successful, the Controller sends an HCI_LE_Periodic_Advertising_Sync_-\n Established event to the Host with the error code Operation Cancelled by Host\n (0x44).\n\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_create_sync_cancel() -> u8;
}
extern "C" {
    #[doc = "  LE Periodic Advertising Terminate Sync.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.69\n\n The HCI_LE_Periodic_Advertising_Terminate_Sync command is used to stop\n reception of the periodic advertising train identified by the Sync_Handle\n parameter.\n\n If the periodic advertising train corresponding to the Sync_Handle parameter\n does not exist, then the Controller shall return the error code Unknown\n Advertising Identifier (0x42).\n\n Following successful completion of this command the Sync_Handle is\n destroyed.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Terminate_Sync command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_terminate_sync(
        p_params: *const sdc_hci_cmd_le_periodic_adv_terminate_sync_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Add Device To Periodic Advertiser List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.70\n\n The HCI_LE_Add_Device_To_Periodic_Advertiser_List command is used to\n add an entry, consisting of a single device address and SID, to the Periodic\n Advertiser list stored in the Controller. Any additions to the Periodic Advertiser\n list take effect immediately. If the entry is already on the list, the Controller shall\n return the error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command when an HCI_LE_Periodic_Advertising_-\n Create_Sync command is pending, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n When a Controller cannot add an entry to the Periodic Advertiser list because\n the list is full, the Controller shall return the error code Memory Capacity\n Exceeded (0x07).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Add_Device_To_Periodic_Advertiser_List command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_add_device_to_periodic_adv_list(
        p_params: *const sdc_hci_cmd_le_add_device_to_periodic_adv_list_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Remove Device From Periodic Advertiser List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.71\n\n The HCI_LE_Remove_Device_From_Periodic_Advertiser_List command is\n used to remove one entry from the list of Periodic Advertisers stored in the\n Controller. Removals from the Periodic Advertisers List take effect immediately.\n\n If the Host issues this command when an HCI_LE_Periodic_Advertising_-\n Create_Sync command is pending, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n When a Controller cannot remove an entry from the Periodic Advertiser list\n because it is not found, the Controller shall return the error code Unknown\n Advertising Identifier (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Remove_Device_From_Periodic_Advertiser_List\n command has completed, an HCI_Command_Complete event shall be\n generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_remove_device_from_periodic_adv_list(
        p_params: *const sdc_hci_cmd_le_remove_device_from_periodic_adv_list_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Clear Periodic Advertiser List.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.72\n\n The HCI_LE_Clear_Periodic_Advertiser_List command is used to remove all\n entries from the list of Periodic Advertisers in the Controller.\n\n If this command is used when an HCI_LE_Periodic_Advertising_Create_Sync\n command is pending, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Clear_Periodic_Advertiser_List command has completed,\n an HCI_Command_Complete event shall be generated.\n\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_clear_periodic_adv_list() -> u8;
}
extern "C" {
    #[doc = "  LE Read Periodic Advertiser List Size.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.73\n\n The HCI_LE_Read_Periodic_Advertiser_List_Size command is used to read\n the total number of Periodic Advertiser list entries that can be stored in the\n Controller.\n\n Note: The number of entries that can be stored is not fixed and the Controller\n can change it at any time (e.g., because the memory used to store the list can\n also be used for other purposes).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Periodic_Advertiser_List_Size command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_periodic_adv_list_size(
        p_return: *mut sdc_hci_cmd_le_read_periodic_adv_list_size_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Transmit Power.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.74\n\n The HCI_LE_Read_Transmit_Power command is used to read the minimum\n and maximum transmit powers supported by the Controller across all\n supported PHYs.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read _Transmit_Power command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_transmit_power(p_return: *mut sdc_hci_cmd_le_read_transmit_power_return_t) -> u8;
}
extern "C" {
    #[doc = "  LE Read RF Path Compensation.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.75\n\n The HCI_LE_Read_RF_Path_Compensation command is used to read the RF\n path compensation value parameters used in the Tx power level and RSSI\n calculation.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_RF_Path_Compensation command has completed,\n an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_rf_path_compensation(
        p_return: *mut sdc_hci_cmd_le_read_rf_path_compensation_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Write RF Path Compensation.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.76\n\n The HCI_LE_Write_RF_Path_Compensation command is used to indicate the\n RF path gain or loss between the RF transceiver and the antenna contributed\n by intermediate components. A positive value means a net RF path gain and a\n negative value means a net RF path loss. The RF_TX_Path_Compensation_-\n Value parameter shall be used by the Controller to calculate the radiative Tx\n power level used in HCI commands, HCI events, Advertising physical channel\n PDUs, and Link Layer Control PDUs using the following equation:\n\n Radiative Tx power level = Tx power level at RF transceiver output + RF_TX_-\n Path_Compensation_Value\n\n For example, if the Tx power level is +4 (dBm) at RF transceiver output and the\n RF_TX_Path_Compensation_Value is -1.5 (dB), the radiative Tx power level is\n +4+(-1.5) = 2.5 (dBm).\n\n The RF_RX_Path_Compensation_Value parameter shall be used by the\n Controller to calculate the RSSI value reported to the Host.\n\n The default values for the RF path compensation are vendor-specific.\n\n This command can be issued at any time. If this command is issued during an\n ongoing over-the-air RF activity, the Controller may apply the Tx path\n compensation immediately or after a vendor-specific delay.\n\n The Controller shall apply a change to the Tx path compensation value either\n by leaving the power at the transceiver output unchanged and altering the\n radiative Tx power level or by altering the power at the transceiver output to\n maintain any previously chosen radiative Tx power level.\n\n If the Host needs to maintain a specific radiative transmit power level for an\n advertising set, it should disable that set before issuing this command then,\n after the command completes, reissue the HCI_LE_Set_Extended_-\n Advertising_Parameters command for that set and then re-enable it.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Write_RF_Path_Compensation command has completed,\n an HCI_Command_Complete event shall be generated.\n\n If the command leads to a change in the local radiative transmit power level for\n an LE ACL connection, then the Controller shall generate an HCI_LE_-\n Transmit_Power_Reporting event if local reporting is enabled and initiate a\n Link Layer Power Change Indication procedure if remote reporting is enabled.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_write_rf_path_compensation(
        p_params: *const sdc_hci_cmd_le_write_rf_path_compensation_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Privacy Mode.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.77\n\n The HCI_LE_Set_Privacy_Mode command is used to allow the Host to specify\n the privacy mode to be used for a given entry on the resolving list. The effect of\n this setting is specified in [Vol 6] Part B, Section 4.7.\n\n When an entry on the resolving list is removed, the mode associated with that\n entry shall also be removed.\n\n This command shall not be used when address resolution is enabled in the\n Controller and:\n • Advertising (other than periodic advertising) is enabled,\n • Scanning is enabled, or\n • an HCI_LE_Create_Connection, HCI_LE_Extended_Create_Connection, or\n   HCI_LE_Periodic_Advertising_Create_Sync command is pending.\n\n This command may be used at any time when address resolution is disabled in\n the Controller.\n\n If the device is not on the resolving list, the Controller shall return the error\n code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Privacy_Mode command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_privacy_mode(p_params: *const sdc_hci_cmd_le_set_privacy_mode_t) -> u8;
}
extern "C" {
    #[doc = "  LE Set Connectionless CTE Transmit Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.80\n\n The HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command is\n used to set the type, length, and antenna switching pattern for the transmission\n of Constant Tone Extensions in any periodic advertising on the advertising set\n identified by the Advertising_Handle parameter.\n\n The CTE_Count parameter specifies how many packets with a Constant Tone\n Extension are to be transmitted in each periodic advertising event. If the\n number of packets that would otherwise be transmitted is less than this, the\n Controller shall transmit sufficient AUX_CHAIN_IND PDUs with no AdvData to\n make up the number. However, if a change in circumstances since this\n command was issued means that the Controller can no longer schedule all of\n these packets, it should transmit as many as possible.\n\n If the Host issues this command when Constant Tone Extensions have been\n enabled in the advertising set, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n The Switching_Pattern_Length and Antenna_IDs[i] parameters are only used\n when transmitting an AoD Constant Tone Extension and shall be ignored if\n CTE_Type specifies an AoA Constant Tone Extension.\n\n If the CTE_Length parameter is greater than the maximum length of Constant\n Tone Extension supported, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n If the Host requests a type of Constant Tone Extension that the Controller does\n not support, the Controller shall return the error code Unsupported Feature or\n Parameter Value (0x11).\n\n If the Controller is unable to schedule CTE_Count packets in each event, the\n Controller shall return the error code Unsupported Feature or Parameter Value\n (0x11).\n If the advertising set corresponding to the Advertising_Handle parameter does\n not exist, the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n If Switching_Pattern_Length is greater than the maximum length of switching\n pattern supported by the Controller (see Section 7.8.87), the Controller shall\n return the error code Unsupported Feature or Parameter Value (0x11).\n\n If the Controller determines that any of the Antenna_IDs[i] values do not\n identify an antenna in the device's antenna array, it shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n Note: Some Controllers may be unable to determine which values do or do not\n identify an antenna.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Connectionless_CTE_Transmit_Parameters\n command has completed, an HCI_Command_Complete event shall be\n generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_connless_cte_transmit_params(
        p_params: *const sdc_hci_cmd_le_set_connless_cte_transmit_params_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Connectionless CTE Transmit Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.81\n\n The HCI_LE_Set_Connectionless_CTE_Transmit_Enable command is used to\n request that the Controller enables or disables the use of Constant Tone\n Extensions in any periodic advertising on the advertising set identified by\n Advertising_Handle.\n\n In order to start sending periodic advertisements containing a Constant Tone\n Extension, the Host must also enable periodic advertising using the\n HCI_LE_Set_Periodic_Advertising_Enable command (see Section 7.8.63).\n\n Note: Periodic advertising can only be enabled when advertising is enabled on\n the same advertising set, but can continue after advertising has been disabled.\n\n If the Host issues this command before it has issued the\n HCI_LE_Set_Periodic_Advertising_Parameters command (see Section 7.8.61)\n for the advertising set, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n Once enabled, the Controller shall continue advertising with Constant Tone\n Extensions until either one of the following occurs:\n • The Host issues an HCI_LE_Set_Connectionless_CTE_Transmit_Enable\n   command with CTE_Enable set to 0x00 (disabling Constant Tone\n   Extensions but allowing periodic advertising to continue).\n • The Host issues an HCI_LE_Set_Periodic_Advertising_Enable command\n   (see Section 7.8.63) with Enable set to 0x00 (disabling periodic advertising).\n   If periodic advertising is re-enabled then it shall continue to contain Constant\n   Tone Extensions.\n\n If the Host issues this command before it has issued the\n HCI_LE_Set_Connectionless_CTE_Transmit_Parameters command for the\n advertising set, the Controller shall return the error code Command Disallowed\n (0x0C).\n\n If the periodic advertising is on a PHY that does not allow Constant Tone\n Extensions, the Controller shall return the error code Command Disallowed\n (0x0C).\n If the advertising set corresponding to the Advertising_Handle parameter does\n not exist, the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n The Host may issue this command when advertising or periodic advertising is\n enabled in the advertising set.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Connectionless_CTE_Transmit_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_connless_cte_transmit_enable(
        p_params: *const sdc_hci_cmd_le_set_connless_cte_transmit_enable_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Connection CTE Transmit Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.84\n\n The HCI_LE_Set_Connection_CTE_Transmit_Parameters command is used\n to set the antenna switching pattern and permitted Constant Tone Extension\n types used for transmitting Constant Tone Extensions requested by the peer\n device on the connection identified by the Connection_Handle parameter.\n\n If the Host issues this command when Constant Tone Extension responses\n have been enabled on the connection, the Controller shall return the error code\n Command Disallowed (0x0C).\n\n If the CTE_Types parameter has a bit set for a type of Constant Tone\n Extension that the Controller does not support, the Controller shall return the\n error code Unsupported Feature or Parameter Value (0x11).\n\n The Switching_Pattern_Length and Antenna_IDs[i] parameters are only used\n when transmitting an AoD Constant Tone Extension and shall be ignored when\n CTE_Types does not have a bit set for an AoD Constant Tone Extension; they\n do not affect the transmission of an AoA Constant Tone Extension.\n\n If Switching_Pattern_Length is greater than the maximum length of switching\n pattern supported by the Controller, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n If the Controller determines that any of the Antenna_IDs[i] values do not\n identify an antenna in the device's antenna array, it shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n Note: Some Controllers may be unable to determine which values do or do not\n identify an antenna.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Connection_CTE_Transmit_Parameters command\n has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_conn_cte_transmit_params(
        p_params: *const sdc_hci_cmd_le_set_conn_cte_transmit_params_t,
        p_return: *mut sdc_hci_cmd_le_set_conn_cte_transmit_params_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Connection CTE Response Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.86\n\n The HCI_LE_Connection_CTE_Response_Enable command is used to\n request the Controller to respond to LL_CTE_REQ PDUs with LL_CTE_RSP\n PDUs on the specified connection.\n\n If the Host issues this command before issuing the\n HCI_LE_Set_Connection_CTE_Transmit_Parameters command at least once\n on the connection, the Controller shall return the error code Command\n Disallowed (0x0C).\n\n If the Host issues this command when the transmitter PHY for the connection is\n not a PHY that allows Constant Tone Extensions, the Controller shall return the\n error code Command Disallowed (0x0C).\n\n If the transmitter PHY for the connection changes to a PHY that does not allow\n Constant Tone Extensions, then the Controller shall automatically disable\n Constant Tone Extension responses.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Connection_CTE_Response_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_conn_cte_response_enable(
        p_params: *const sdc_hci_cmd_le_conn_cte_response_enable_t,
        p_return: *mut sdc_hci_cmd_le_conn_cte_response_enable_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Antenna Information.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.87\n\n The HCI_LE_Read_Antenna_Information command allows the Host to read\n the switching rates, the sampling rates, the number of antennae, and the\n maximum length of a transmitted Constant Tone Extension supported by the\n Controller.\n\n If the Controller does not support antenna switching, the value of\n Max_Switching_Pattern_Length shall still be valid but will not be used by the\n Host.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Read_Antenna_Information command has completed, an\n HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_antenna_information(
        p_return: *mut sdc_hci_cmd_le_read_antenna_information_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Periodic Advertising Receive Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.88\n\n The HCI_LE_Set_Periodic_Advertising_Receive_Enable command will enable\n or disable reports for the periodic advertising train identified by the\n Sync_Handle parameter.\n\n The Enable parameter determines whether reporting and duplicate filtering are\n enabled or disabled. If the value is the same as the current state, the command\n has no effect.\n\n If the periodic advertising train corresponding to the Sync_Handle parameter\n does not exist, the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Receive_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_receive_enable(
        p_params: *const sdc_hci_cmd_le_set_periodic_adv_receive_enable_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Periodic Advertising Sync Transfer.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.89\n\n The HCI_LE_Periodic_Advertising_Sync_Transfer command is used to\n instruct the Controller to send synchronization information about the periodic\n advertising train identified by the Sync_Handle parameter to a connected\n device.\n\n The Service_Data parameter is a value provided by the Host for use by the\n Host of the peer device. It is not used by the Controller.\n\n The connected device is identified by the Connection_Handle parameter.\n\n If the periodic advertising train corresponding to the Sync_Handle parameter\n does not exist, the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n If the Connection_Handle parameter does not identify a current connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n If the remote device has not indicated support for the Periodic Advertising Sync\n Transfer - Recipient feature, the Controller shall return the error code\n Unsupported Remote Feature (0x1A).\n\n Note: This command may complete before the periodic advertising\n synchronization information is sent. No indication is given as to how the\n recipient handled the information.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Sync_Transfer command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_sync_transfer(
        p_params: *const sdc_hci_cmd_le_periodic_adv_sync_transfer_t,
        p_return: *mut sdc_hci_cmd_le_periodic_adv_sync_transfer_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Periodic Advertising Set Info Transfer.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.90\n\n The HCI_LE_Periodic_Advertising_Set_Info_Transfer command is used to\n instruct the Controller to send synchronization information about the periodic\n advertising in an advertising set to a connected device.\n\n The Advertising_Handle parameter identifies the advertising set. If the\n parameters in the advertising set have changed since the periodic advertising\n was first enabled, the current parameters – not the original ones – are sent.\n\n The Service_Data parameter is a value provided by the Host to identify the\n periodic advertising train to the peer device. It is not used by the Controller.\n\n The connected device is identified by the Connection_Handle parameter.\n\n If the advertising set corresponding to the Advertising_Handle parameter does\n not exist, the Controller shall return the error code Unknown Advertising\n Identifier (0x42).\n\n If periodic advertising is not currently in progress for the advertising set, the\n Controller shall return the error code Command Disallowed (0x0C).\n\n If the Connection_Handle parameter does not identify a current connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n If the remote device has not indicated support for the Periodic Advertising Sync\n Transfer - Recipient feature, the Controller shall return the error code\n Unsupported Remote Feature (0x1A).\n\n Note: This command may complete before the periodic advertising\n synchronization information is sent. No indication is given as to how the\n recipient handled the information.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Periodic_Advertising_Set_Info_Transfer command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_periodic_adv_set_info_transfer(
        p_params: *const sdc_hci_cmd_le_periodic_adv_set_info_transfer_t,
        p_return: *mut sdc_hci_cmd_le_periodic_adv_set_info_transfer_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Periodic Advertising Sync Transfer Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.91\n\n The HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command\n is used to specify how the Controller will process periodic advertising\n synchronization information received from the device identified by the\n Connection_Handle parameter (the \"transfer mode\").\n\n The Mode parameter specifies the action to be taken when periodic advertising\n synchronization information is received. If Mode is 0x00, the Controller will\n ignore the information. Otherwise it will notify the Host and synchronize to the\n periodic advertising. Mode also specifies whether periodic advertising reports\n are initially enabled or disabled and whether duplicates are filtered.\n\n The Skip parameter specifies the number of consecutive periodic advertising\n packets that the receiver may skip after successfully receiving a periodic\n advertising packet.\n\n The Sync_Timeout parameter specifies the maximum permitted time between\n successful receives. If this time is exceeded, synchronization is lost.\n\n Irrespective of the value of the Skip parameter, the Controller should stop\n skipping packets before the Sync_Timeout would be exceeded.\n\n The CTE_Type parameter specifies whether to only synchronize to periodic\n advertising with certain types of Constant Tone Extension. If the periodic\n advertiser changes the type of the Constant Tone Extension after the Controller\n has synchronized with the periodic advertising, it shall remain synchronized.\n\n Note: A value of 0 (i.e. all bits clear) indicates that the presence or absence of\n a Constant Tone Extension is irrelevant.\n\n This command does not affect any processing of any periodic advertising\n synchronization information already received from the peer device, whether or\n not the Controller has yet synchronized to the periodic advertising train it\n describes.\n\n The parameter values provided by this command override those provided via\n the HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters\n command (Section 7.8.92) or any preferences previously set using the\n HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters command on\n the same connection.\n\n If the Connection_Handle parameter does not identify a current connection, the\n Controller shall return the error code Unknown Connection Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Periodic_Advertising_Sync_Transfer_Parameters\n command has completed, an HCI_Command_Complete event shall be\n generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params(
        p_params: *const sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_t,
        p_return: *mut sdc_hci_cmd_le_set_periodic_adv_sync_transfer_params_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Default Periodic Advertising Sync Transfer Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.92\n\n The HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_Parameters\n command is used to specify the initial value for the mode, skip, timeout, and\n Constant Tone Extension type (set by the HCI_LE_Set_Periodic_Advertising_-\n Sync_Transfer_Parameters command; see Section 7.8.91) to be used for all\n subsequent connections over the LE transport.\n\n The Mode parameter specifies the initial action to be taken. If Mode is 0x00,\n the Controller will ignore the information. Otherwise it will notify the Host and\n synchronize to the periodic advertising. Mode also specifies whether periodic\n advertising reports are initially enabled or disabled and whether duplicates are\n filtered.\n\n The Skip parameter specifies the number of consecutive periodic advertising\n packets that the receiver may skip after successfully receiving a periodic\n advertising packet.\n\n The Sync_Timeout parameter specifies the maximum permitted time between\n successful receives. If this time is exceeded, synchronization is lost.\n\n The CTE_Type parameter specifies whether to only synchronize to periodic\n advertising with certain types of Constant Tone Extension. If the periodic\n advertiser changes the type of the Constant Tone Extension after the Controller\n has synchronized with the periodic advertising, it shall remain synchronized.\n\n Note: A value of 0 (i.e. all bits clear) indicates that the presence or absence of\n a Constant Tone Extension is irrelevant.\n\n This command does not affect any existing connection.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Default_Periodic_Advertising_Sync_Transfer_-\n Parameters command has completed, an HCI_Command_Complete event\n shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params(
        p_params: *const sdc_hci_cmd_le_set_default_periodic_adv_sync_transfer_params_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Enhanced Read Transmit Power Level.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.117\n\n The HCI_LE_Enhanced_Read_Transmit_Power_Level command is used to\n read the current and maximum transmit power levels of the local Controller on\n the ACL connection identified by the Connection_Handle parameter and the\n PHY indicated by the PHY parameter.\n\n If the Host sets PHY to a value that the Controller does not support, including a\n value that is reserved for future use, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n If the Connection_Handle parameter does not identify a current ACL\n connection, the Controller shall return the error code Unknown Connection\n Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Enhanced_Read_Transmit_Power_Level command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_enhanced_read_transmit_power_level(
        p_params: *const sdc_hci_cmd_le_enhanced_read_transmit_power_level_t,
        p_return: *mut sdc_hci_cmd_le_enhanced_read_transmit_power_level_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Read Remote Transmit Power Level.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.118\n\n The HCI_LE_Read_Remote_Transmit_Power_Level command is used to read\n the transmit power level used by the remote Controller on the ACL connection\n that is identified by the Connection_Handle parameter and the PHY indicated\n by the PHY parameter.\n\n The local Controller may use the remote transmit power level value obtained\n from a prior Power Change Indication or Power Control Request procedure\n (see [Vol 6] Part B, Section 5.1.17 and [Vol 6] Part B, Section 5.1.18). If the\n Controller chooses not to use these prior values, or if no prior value is available\n for one or more of the remote transmit power level, maximum transmit power\n level, or minimum transmit power level, the local Controller shall initiate a new\n Power Control Request procedure to obtain the remote transmit power level.\n\n If the Host sets PHY to a value that the Controller does not support, including a\n value that is reserved for future use, the Controller shall return the error code\n Unsupported Feature or Parameter Value (0x11).\n\n If the Connection_Handle parameter does not identify a current ACL\n connection, the Controller shall return the error code Unknown Connection\n Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_LE_Read_Remote_Transmit_Power_-\n Level command, the Controller shall send the HCI_Command_Status event to\n the Host. When the Controller has determined the remote transmit power, it\n shall generate an HCI_LE_Transmit_Power_Reporting event with Reason\n 0x02.\n\n Note: An HCI_Command_Complete event is not sent by the Controller to\n indicate that this command has been completed. Instead, the HCI_LE_-\n Transmit_Power_Reporting event indicates that this command has been\n completed.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_read_remote_transmit_power_level(
        p_params: *const sdc_hci_cmd_le_read_remote_transmit_power_level_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Path Loss Reporting Parameters.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.119\n\n The HCI_LE_Set_Path_Loss_Reporting_Parameters command is used to set\n the path loss threshold reporting parameters for the ACL connection identified\n by the Connection_Handle parameter.\n\n The path loss threshold-based mechanism is described in [Vol 6] Part B,\n Section 4.5.16. For each zone boundary, the upwards boundary shall equal the\n threshold plus the hysteresis and the downwards boundary shall equal the\n threshold minus the hysteresis.\n\n If the Host issues this command with High_Threshold+High_Hysteresis greater\n than 0xFF or with Low_Threshold less than Low_Hysteresis, the Controller\n shall return the error code Invalid HCI Command Parameters (0x12).\n\n If the Host issues this command with Low_Threshold greater than\n High_Threshold or with Low_Threshold+Low_Hysteresis greater than\n High_Threshold–High_Hysteresis, the Controller shall return the error code\n Invalid HCI Command Parameters (0x12).\n\n The Min_Time_Spent parameter indicates the minimum time that the Controller\n shall observe the path loss has crossed the threshold before the Controller\n generates an event for the threshold crossing. The Host should specify a\n suitable value based on the connection interval, subrate factor, and Peripheral\n latency.\n\n If the Host issues this command when path loss monitoring is enabled, the\n Controller shall override the existing path loss threshold reporting parameters\n with the parameters provided in this command.\n\n The High_Threshold and the Low_Threshold parameters are common to all\n PHYs supported by the Controller. However, the Host can reissue this\n command with suitable parameters whenever a PHY switch is detected.\n\n If the Connection_Handle parameter does not identify a current ACL\n connection, the Controller shall return the error code Unknown Connection\n Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Path_Loss_Reporting_Parameters command has\n completed, an HCI_Command_Complete event shall be generated.\n\n If the Host issues this command when path loss monitoring is enabled, and if\n the new parameters mean that the path loss is now in a different zone, an\n HCI_LE_Path_Loss_Threshold event shall be generated as soon as possible\n irrespective of the Min_Time_Spent parameter and the timer shall be reset.\n\n If the Host issues this command with High_Threshold parameter set to 0xFF,\n then the Controller shall not generate an HCI_LE_Path_Loss_Threshold event\n with Zone_Entered set to 0x02.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_path_loss_reporting_params(
        p_params: *const sdc_hci_cmd_le_set_path_loss_reporting_params_t,
        p_return: *mut sdc_hci_cmd_le_set_path_loss_reporting_params_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Path Loss Reporting Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.120\n\n The HCI_LE_Set_Path_Loss_Reporting_Enable command is used to enable\n or disable path loss reporting for the ACL connection identified by the\n Connection_Handle parameter.\n\n If the Enable parameter is set to 0x01 and no prior LE Power Control Request\n procedure has been initiated on the ACL connection, then the Controller may\n need to initiate a new LE Power Control Request procedure on that ACL.\n\n Path loss reporting is disabled when the connection is first created.\n\n If the Host issues this command before it has issued the HCI_LE_Set_Path_-\n Loss_Reporting_Parameters command on this connection, the Controller shall\n return the error code Command Disallowed (0x0C).\n\n If the Connection_Handle parameter does not identify a current ACL\n connection, the Controller shall return the error code Unknown Connection\n Identifier (0x02).\n\n Enabling path loss monitoring when it is already enabled or disabling path loss\n monitoring when it is already disabled has no effect.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Path_Loss_Reporting_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n When reporting is enabled and was previously disabled, the Controller shall\n generate an HCI_LE_Path_Loss_Threshold event as soon as it has a reliable\n measurement of the path loss. If the Controller has to query the remote\n Controller for its transmit power level, then it shall generate this event within\n Tpath_loss_enable from the time it receives a response to its query. Otherwise, the\n Controller shall generate this event within Tpath_loss_enable from the time the\n command is issued. Tpath_loss_enable shall be Min_Time_Spent + 6 connection\n events or, if longer, 2 connection events where the Controller actually receives\n a packet from the peer, where Min_Time_Spent is specified by the\n HCI_LE_Set_Path_Loss_Reporting_Parameters command.\n\n After the initial event on reporting being enabled, the Controller shall generate\n this event each time it determines that the path loss has moved to a different\n zone and stayed in that zone for Min_Time_Spent.As stated in [Vol 6] Part B,\n Section 4.5.16, two consecutive events must not indicate the same zone.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_path_loss_reporting_enable(
        p_params: *const sdc_hci_cmd_le_set_path_loss_reporting_enable_t,
        p_return: *mut sdc_hci_cmd_le_set_path_loss_reporting_enable_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Transmit Power Reporting Enable.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.121\n\n The HCI_LE_Set_Transmit_Power_Reporting_Enable command is used to\n enable or disable the reporting to the local Host of transmit power level\n changes in the local and remote Controllers for the ACL connection identified\n by the Connection_Handle parameter.\n\n If the Remote_Enable parameter is set to 0x01 and no prior LE Power Control\n Request procedure has been initiated on the ACL connection, then the\n Controller shall initiate a new LE Power Control Request procedure on that\n ACL.\n\n Reporting is disabled when the connection is first created.\n\n If the Connection_Handle parameter does not identify a current ACL\n connection, the Controller shall return the error code Unknown Connection\n Identifier (0x02).\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Transmit_Power_Reporting_Enable command has\n completed, an HCI_Command_Complete event shall be generated.\n\n When local reporting is enabled, the Controller shall generate an HCI_LE_-\n Transmit_Power_Reporting event with Reason 0x00 each time the local\n transmit power level is changed.\n\n When remote reporting is enabled, the Controller shall generate an HCI_LE_-\n Transmit_Power_Reporting event with Reason 0x01 each time it becomes\n aware that the remote transmit power level has changed.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_transmit_power_reporting_enable(
        p_params: *const sdc_hci_cmd_le_set_transmit_power_reporting_enable_t,
        p_return: *mut sdc_hci_cmd_le_set_transmit_power_reporting_enable_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  LE Set Data Related Address Changes.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.8.122\n\n The HCI_LE_Set_Data_Related_Address_Changes command specifies\n circumstances when the Controller shall refresh any Resolvable Private\n Address used by the advertising set identified by the Advertising_Handle\n parameter, whether or not the address timeout period has been reached. This\n command may be used while advertising is enabled.\n\n The Change_Reasons parameter specifies the reason(s) for refreshing\n addresses. The default when an advertising set is created, or if legacy\n advertising commands (see Section 3.1.1) are used, is for all bits to be clear.\n\n If extended advertising commands (see Section 3.1.1) are being used and the\n advertising set corresponding to the Advertising_Handle parameter does not\n exist, or if no command specified in Table 3.2 has been used, then the\n Controller shall return the error code Unknown Advertising Identifier (0x42).\n\n If legacy advertising commands are being used, the Controller shall ignore the\n Advertising_Handle parameter.\n\n Event(s) generated (unless masked away):\n When the HCI_LE_Set_Data_Related_Address_Changes command has\n completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_le_set_data_related_address_changes(
        p_params: *const sdc_hci_cmd_le_set_data_related_address_changes_t,
    ) -> u8;
}
#[doc = "  See @ref sdc_hci_cmd_lc_disconnect()."]
pub const sdc_hci_opcode_lc_SDC_HCI_OPCODE_CMD_LC_DISCONNECT: sdc_hci_opcode_lc = 1030;
#[doc = "  See @ref sdc_hci_cmd_lc_read_remote_version_information()."]
pub const sdc_hci_opcode_lc_SDC_HCI_OPCODE_CMD_LC_READ_REMOTE_VERSION_INFORMATION: sdc_hci_opcode_lc = 1053;
#[doc = "  HCI LC OpCode Field values."]
pub type sdc_hci_opcode_lc = crate::ctypes::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_lc_disconnect_t {
    pub conn_handle: u16,
    pub reason: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_lc_disconnect_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_lc_disconnect_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_lc_disconnect_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_lc_disconnect_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_lc_disconnect_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_lc_disconnect_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_lc_disconnect_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reason) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_lc_disconnect_t),
            "::",
            stringify!(reason)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_lc_read_remote_version_information_t {
    pub conn_handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_lc_read_remote_version_information_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_lc_read_remote_version_information_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_lc_read_remote_version_information_t>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_lc_read_remote_version_information_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_lc_read_remote_version_information_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_lc_read_remote_version_information_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_lc_read_remote_version_information_t),
            "::",
            stringify!(conn_handle)
        )
    );
}
extern "C" {
    #[doc = " @defgroup HCI_VS_API API\n @{\n/\n/** @brief Disconnect.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.1.6\n\n The HCI_Disconnect command is used to terminate an existing connection.\n The Connection_Handle command parameter indicates which connection is to\n be disconnected. The Reason command parameter indicates the reason for\n ending the connection and is copied into the error code field of the\n LMP_DETACH PDU on a BR/EDR connection or the error code field of the\n LL_TERMINATE_IND or LL_CIS_TERMINATE_IND PDU on an LE\n connection. All SCO, eSCO, and CIS connections on a physical link should be\n disconnected before the ACL connection on the same physical connection is\n disconnected. If it does not, they will be implicitly disconnected as part of the\n ACL disconnection.\n\n If, on the Central, the Host issues this command before issuing the\n HCI_LE_Create_CIS command for the same CIS, then the Controller shall\n return the error code Command Disallowed (0x0C).\n\n If, on the Peripheral, the Host issues this command before the Controller has\n generated the HCI_LE_CIS_Established event for that CIS, then the Controller\n shall return the error code Command Disallowed (0x0C).\n\n Note: As specified in Section 7.7.5, on the Central, the handle for a CIS\n remains valid even after disconnection and, therefore, the Host can recreate a\n disconnected CIS at a later point in time using the same connection handle.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_Disconnect command, it shall send the\n HCI_Command_Status event to the Host. The HCI_Disconnection_Complete\n event will occur at each Host when the termination of the connection has\n completed, and on the local Host also indicates that this command has been\n completed. The Reason event parameter in the event on the local Host shall be\n set to the value Connection Terminated by Local Host (0x16), while that on the\n remote Host shall be set to the value of the Reason command parameter.\n However, if the termination procedure completes because a timer expires and,\n therefore, the local Controller cannot determine whether or not the Reason\n command parameter was received by the remote Controller, the Reason event\n parameter on the local Host should instead be set to the value LMP Response\n Timeout / LL Response Timeout (0x22).\n\n If this command is issued for a CIS on the Central and the CIS is successfully\n terminated before being established, then an HCI_LE_CIS_Established event\n shall also be sent for this CIS with the Status Operation Cancelled by Host\n (0x44).\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_lc_disconnect(p_params: *const sdc_hci_cmd_lc_disconnect_t) -> u8;
}
extern "C" {
    #[doc = "  Read Remote Version Information.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.1.23\n\n This command will obtain the values for the version information for the remote\n device identified by the Connection_Handle parameter. The\n Connection_Handle shall be a Connection_Handle for an ACL-U or LE-U\n logical link.\n\n Event(s) generated (unless masked away):\n When the Controller receives the HCI_Read_Remote_Version_Information\n command, the Controller shall send the HCI_Command_Status event to the\n Host. When the Link Manager or Link Layer has completed the sequence to\n determine the remote version information, the local Controller shall send an\n HCI_Read_Remote_Version_Information_Complete event to the Host. The\n HCI_Read_Remote_Version_Information_Complete event contains the status\n of this command, and parameters describing the version and subversion of the\n LMP or Link Layer used by the remote device.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_lc_read_remote_version_information(
        p_params: *const sdc_hci_cmd_lc_read_remote_version_information_t,
    ) -> u8;
}
#[doc = "  See @ref sdc_hci_cmd_sp_read_rssi()."]
pub const sdc_hci_opcode_sp_SDC_HCI_OPCODE_CMD_SP_READ_RSSI: sdc_hci_opcode_sp = 5125;
#[doc = "  HCI SP OpCode Field values."]
pub type sdc_hci_opcode_sp = crate::ctypes::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_sp_read_rssi_t {
    pub handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_sp_read_rssi_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_sp_read_rssi_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_sp_read_rssi_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_sp_read_rssi_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_sp_read_rssi_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_sp_read_rssi_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_sp_read_rssi_t),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_sp_read_rssi_return_t {
    pub handle: u16,
    pub rssi: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_sp_read_rssi_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_sp_read_rssi_return_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_sp_read_rssi_return_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_sp_read_rssi_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_sp_read_rssi_return_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_sp_read_rssi_return_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_sp_read_rssi_return_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rssi) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_sp_read_rssi_return_t),
            "::",
            stringify!(rssi)
        )
    );
}
extern "C" {
    #[doc = " @defgroup HCI_VS_API API\n @{\n/\n/** @brief Read RSSI.\n\n The description below is extracted from Core_v5.3,\n Vol 4, Part E, Section 7.5.4\n\n This command reads the Received Signal Strength Indication (RSSI) value\n from a Controller.\n\n For a BR/EDR Controller, the RSSI parameter returns the difference between\n the measured Received Signal Strength Indication (RSSI) and the limits of the\n Golden Receive Power Range for a Connection_Handle to another BR/EDR\n Controller. Any positive RSSI value returned by the Controller indicates how\n many dB the RSSI is above the upper limit, any negative value indicates how\n many dB the RSSI is below the lower limit. The value zero indicates that the\n RSSI is inside the Golden Receive Power Range.\n\n Note: How accurate the dB values will be depends on the Bluetooth hardware.\n The only requirements for the hardware are that the BR/EDR Controller is able\n to tell whether the RSSI is inside, above or below the Golden Device Power\n Range.\n\n The RSSI measurement compares the received signal power with two\n threshold levels, which define the Golden Receive Power Range. The lower\n threshold level corresponds to a received power between -56 dBm and 6 dB\n above the actual sensitivity of the receiver. The upper threshold level is 20 dB\n above the lower threshold level to an accuracy of ±6 dB.\n\n For an LE transport, the RSSI parameter returns the absolute receiver signal\n strength value in dBm to ±6 dB accuracy. If the RSSI cannot be read, the RSSI\n metric shall be set to 127.\n\n Event(s) generated (unless masked away):\n When the HCI_Read_RSSI command has completed, an HCI_Command_-\n Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_sp_read_rssi(
        p_params: *const sdc_hci_cmd_sp_read_rssi_t,
        p_return: *mut sdc_hci_cmd_sp_read_rssi_return_t,
    ) -> u8;
}
pub const sdc_hci_msg_type_t_SDC_HCI_MSG_TYPE_DATA: sdc_hci_msg_type_t = 2;
pub const sdc_hci_msg_type_t_SDC_HCI_MSG_TYPE_EVT: sdc_hci_msg_type_t = 4;
pub type sdc_hci_msg_type_t = crate::ctypes::c_uint;
extern "C" {
    #[doc = "  Send an HCI command packet to the SoftDevice Controller.\n\n * `p_cmd_in` - HCI Command packet. The first byte in the buffer should correspond to\n                      OpCode, as specified by the Bluetooth Core Specification.\n\n Returns 0              Success\n Returns -NRF_EINVAL    Invalid input"]
    pub fn sdc_hci_cmd_put(p_cmd_in: *const u8) -> i32;
}
extern "C" {
    #[doc = "  Send an HCI data packet to the SoftDevice Controller.\n\n * `p_data_in` - HCI Data packet. The first byte in the buffer should correspond to\n                       Handle, as specified by the Bluetooth Core Specification.\n\n Returns 0              Success\n Returns -NRF_EINVAL    Invalid input"]
    pub fn sdc_hci_data_put(p_data_in: *const u8) -> i32;
}
extern "C" {
    #[doc = "  Retrieve an HCI packet from the SoftDevice Controller.\n\n This API is non-blocking.\n\n @note The application should ensure that the size of the provided buffer is at least\n       @ref HCI_MSG_BUFFER_MAX_SIZE bytes.\n\n * `p_packet_out` - Buffer where the HCI packet will be stored.\n                             If an event is retrieved, the first byte corresponds to the Event Code.\n                             If a data packet is retrieved, the first byte corresponds to the Handle.\n * `p_msg_type_out` - Enum indicating the type of HCI packet produced by the controller.\n\n Returns 0            Success\n Returns -NRF_EAGAIN  No event available\n Returns -NRF_EINVAL  Invalid input"]
    pub fn sdc_hci_get(p_packet_out: *mut u8, p_msg_type_out: *mut sdc_hci_msg_type_t) -> i32;
}
#[doc = "  See @ref sdc_hci_cmd_vs_zephyr_read_version_info()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_VERSION_INFO: sdc_hci_opcode_vs = 64513;
#[doc = "  See @ref sdc_hci_cmd_vs_zephyr_read_supported_commands()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_SUPPORTED_COMMANDS: sdc_hci_opcode_vs = 64514;
#[doc = "  See @ref sdc_hci_cmd_vs_zephyr_write_bd_addr()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_ZEPHYR_WRITE_BD_ADDR: sdc_hci_opcode_vs = 64518;
#[doc = "  See @ref sdc_hci_cmd_vs_zephyr_read_static_addresses()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_STATIC_ADDRESSES: sdc_hci_opcode_vs = 64521;
#[doc = "  See @ref sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_KEY_HIERARCHY_ROOTS: sdc_hci_opcode_vs = 64522;
#[doc = "  See @ref sdc_hci_cmd_vs_zephyr_read_chip_temp()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_CHIP_TEMP: sdc_hci_opcode_vs = 64523;
#[doc = "  See @ref sdc_hci_cmd_vs_zephyr_write_tx_power()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_ZEPHYR_WRITE_TX_POWER: sdc_hci_opcode_vs = 64526;
#[doc = "  See @ref sdc_hci_cmd_vs_zephyr_read_tx_power()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_ZEPHYR_READ_TX_POWER: sdc_hci_opcode_vs = 64527;
#[doc = "  See @ref sdc_hci_cmd_vs_read_supported_vs_commands()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_READ_SUPPORTED_VS_COMMANDS: sdc_hci_opcode_vs = 64768;
#[doc = "  See @ref sdc_hci_cmd_vs_llpm_mode_set()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_LLPM_MODE_SET: sdc_hci_opcode_vs = 64769;
#[doc = "  See @ref sdc_hci_cmd_vs_conn_update()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_CONN_UPDATE: sdc_hci_opcode_vs = 64770;
#[doc = "  See @ref sdc_hci_cmd_vs_conn_event_extend()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_CONN_EVENT_EXTEND: sdc_hci_opcode_vs = 64771;
#[doc = "  See @ref sdc_hci_cmd_vs_qos_conn_event_report_enable()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_QOS_CONN_EVENT_REPORT_ENABLE: sdc_hci_opcode_vs = 64772;
#[doc = "  See @ref sdc_hci_cmd_vs_event_length_set()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_EVENT_LENGTH_SET: sdc_hci_opcode_vs = 64773;
#[doc = "  See @ref sdc_hci_cmd_vs_periodic_adv_event_length_set()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_PERIODIC_ADV_EVENT_LENGTH_SET: sdc_hci_opcode_vs = 64774;
#[doc = "  See @ref sdc_hci_cmd_vs_coex_scan_mode_config()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_COEX_SCAN_MODE_CONFIG: sdc_hci_opcode_vs = 64775;
#[doc = "  See @ref sdc_hci_cmd_vs_coex_priority_config()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_COEX_PRIORITY_CONFIG: sdc_hci_opcode_vs = 64776;
#[doc = "  See @ref sdc_hci_cmd_vs_peripheral_latency_mode_set()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_PERIPHERAL_LATENCY_MODE_SET: sdc_hci_opcode_vs = 64777;
#[doc = "  See @ref sdc_hci_cmd_vs_write_remote_tx_power()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_WRITE_REMOTE_TX_POWER: sdc_hci_opcode_vs = 64778;
#[doc = "  See @ref sdc_hci_cmd_vs_set_rssi_golden_range()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_SET_RSSI_GOLDEN_RANGE: sdc_hci_opcode_vs = 64779;
#[doc = "  See @ref sdc_hci_cmd_vs_set_adv_randomness()."]
pub const sdc_hci_opcode_vs_SDC_HCI_OPCODE_CMD_VS_SET_ADV_RANDOMNESS: sdc_hci_opcode_vs = 64780;
#[doc = "  HCI VS OpCode Field values."]
pub type sdc_hci_opcode_vs = crate::ctypes::c_uint;
#[doc = "  See @ref sdc_hci_subevent_vs_qos_conn_event_report_t."]
pub const sdc_hci_subevent_vs_SDC_HCI_SUBEVENT_VS_QOS_CONN_EVENT_REPORT: sdc_hci_subevent_vs = 128;
#[doc = "  VS subevent Code values."]
pub type sdc_hci_subevent_vs = crate::ctypes::c_uint;
pub const sdc_hci_vs_coex_bt_role_SDC_HCI_VS_COEX_BT_ROLE_ADVERTISER: sdc_hci_vs_coex_bt_role = 0;
pub const sdc_hci_vs_coex_bt_role_SDC_HCI_VS_COEX_BT_ROLE_SCANNER: sdc_hci_vs_coex_bt_role = 1;
pub const sdc_hci_vs_coex_bt_role_SDC_HCI_VS_COEX_BT_ROLE_CENTRAL: sdc_hci_vs_coex_bt_role = 2;
pub const sdc_hci_vs_coex_bt_role_SDC_HCI_VS_COEX_BT_ROLE_PERIPHERAL: sdc_hci_vs_coex_bt_role = 3;
#[doc = "  Bluetooth roles that are recognized by the coexistence interface."]
pub type sdc_hci_vs_coex_bt_role = crate::ctypes::c_uint;
#[doc = "  Request after receiving a valid access address."]
pub const sdc_hci_vs_coex_scan_mode_SDC_HCI_VS_COEX_SCAN_MODE_REQUEST_ON_AA: sdc_hci_vs_coex_scan_mode = 0;
#[doc = "  Request before transmitting."]
pub const sdc_hci_vs_coex_scan_mode_SDC_HCI_VS_COEX_SCAN_MODE_REQUEST_ON_TX: sdc_hci_vs_coex_scan_mode = 1;
#[doc = "  Scanner coexistence session request modes."]
pub type sdc_hci_vs_coex_scan_mode = crate::ctypes::c_uint;
#[doc = "  Peripheral latency enable."]
pub const sdc_hci_vs_peripheral_latency_mode_SDC_HCI_VS_PERIPHERAL_LATENCY_MODE_ENABLE:
    sdc_hci_vs_peripheral_latency_mode = 0;
#[doc = "  Peripheral latency disable."]
pub const sdc_hci_vs_peripheral_latency_mode_SDC_HCI_VS_PERIPHERAL_LATENCY_MODE_DISABLE:
    sdc_hci_vs_peripheral_latency_mode = 1;
#[doc = "  Peripheral latency wait for ack."]
pub const sdc_hci_vs_peripheral_latency_mode_SDC_HCI_VS_PERIPHERAL_LATENCY_MODE_WAIT_FOR_ACK:
    sdc_hci_vs_peripheral_latency_mode = 2;
#[doc = "  Peripheral latency disable/enable modes."]
pub type sdc_hci_vs_peripheral_latency_mode = crate::ctypes::c_uint;
#[doc = "  Handle of type Advertiser."]
pub const sdc_hci_vs_tx_power_handle_type_SDC_HCI_VS_TX_POWER_HANDLE_TYPE_ADV: sdc_hci_vs_tx_power_handle_type = 0;
#[doc = "  Handle of type Scanner or Initiator."]
pub const sdc_hci_vs_tx_power_handle_type_SDC_HCI_VS_TX_POWER_HANDLE_TYPE_SCAN_INIT: sdc_hci_vs_tx_power_handle_type =
    1;
#[doc = "  Handle of type Connection."]
pub const sdc_hci_vs_tx_power_handle_type_SDC_HCI_VS_TX_POWER_HANDLE_TYPE_CONN: sdc_hci_vs_tx_power_handle_type = 2;
#[doc = "  TX power handle type."]
pub type sdc_hci_vs_tx_power_handle_type = crate::ctypes::c_uint;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_vs_supported_vs_commands_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_vs_supported_vs_commands_t() {
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_vs_supported_vs_commands_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_vs_supported_vs_commands_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_vs_supported_vs_commands_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_vs_supported_vs_commands_t))
    );
}
impl sdc_hci_vs_supported_vs_commands_t {
    #[inline]
    pub fn read_supported_vs_commands(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_supported_vs_commands(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn llpm_mode_set(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_llpm_mode_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conn_update(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_conn_update(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn conn_event_extend(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_conn_event_extend(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn qos_conn_event_report_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_qos_conn_event_report_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn event_length_set(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_event_length_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn periodic_adv_event_length_set(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_periodic_adv_event_length_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn coex_priority_config(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_coex_priority_config(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn coex_scan_mode_config(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_coex_scan_mode_config(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn peripheral_latency_mode_set(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_peripheral_latency_mode_set(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_remote_tx_power(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_remote_tx_power(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_rssi_golden_range(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_set_rssi_golden_range(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_adv_randomness(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_set_adv_randomness(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_supported_vs_commands: u8,
        llpm_mode_set: u8,
        conn_update: u8,
        conn_event_extend: u8,
        qos_conn_event_report_enable: u8,
        event_length_set: u8,
        periodic_adv_event_length_set: u8,
        coex_priority_config: u8,
        coex_scan_mode_config: u8,
        peripheral_latency_mode_set: u8,
        write_remote_tx_power: u8,
        set_rssi_golden_range: u8,
        set_adv_randomness: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read_supported_vs_commands: u8 = unsafe { ::core::mem::transmute(read_supported_vs_commands) };
            read_supported_vs_commands as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let llpm_mode_set: u8 = unsafe { ::core::mem::transmute(llpm_mode_set) };
            llpm_mode_set as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let conn_update: u8 = unsafe { ::core::mem::transmute(conn_update) };
            conn_update as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let conn_event_extend: u8 = unsafe { ::core::mem::transmute(conn_event_extend) };
            conn_event_extend as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let qos_conn_event_report_enable: u8 = unsafe { ::core::mem::transmute(qos_conn_event_report_enable) };
            qos_conn_event_report_enable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let event_length_set: u8 = unsafe { ::core::mem::transmute(event_length_set) };
            event_length_set as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let periodic_adv_event_length_set: u8 = unsafe { ::core::mem::transmute(periodic_adv_event_length_set) };
            periodic_adv_event_length_set as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let coex_priority_config: u8 = unsafe { ::core::mem::transmute(coex_priority_config) };
            coex_priority_config as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let coex_scan_mode_config: u8 = unsafe { ::core::mem::transmute(coex_scan_mode_config) };
            coex_scan_mode_config as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let peripheral_latency_mode_set: u8 = unsafe { ::core::mem::transmute(peripheral_latency_mode_set) };
            peripheral_latency_mode_set as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let write_remote_tx_power: u8 = unsafe { ::core::mem::transmute(write_remote_tx_power) };
            write_remote_tx_power as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let set_rssi_golden_range: u8 = unsafe { ::core::mem::transmute(set_rssi_golden_range) };
            set_rssi_golden_range as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let set_adv_randomness: u8 = unsafe { ::core::mem::transmute(set_adv_randomness) };
            set_adv_randomness as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_vs_zephyr_static_address_t {
    #[doc = "  Static device address."]
    pub address: [u8; 6usize],
    #[doc = "  Identity root key (IR) for static device address. All zero parameter value indicates\n         missing identity root key."]
    pub identity_root: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_vs_zephyr_static_address_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_vs_zephyr_static_address_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_vs_zephyr_static_address_t>(),
        22usize,
        concat!("Size of: ", stringify!(sdc_hci_vs_zephyr_static_address_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_vs_zephyr_static_address_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_vs_zephyr_static_address_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_vs_zephyr_static_address_t),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).identity_root) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_vs_zephyr_static_address_t),
            "::",
            stringify!(identity_root)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_vs_zephyr_supported_commands_t {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_vs_zephyr_supported_commands_t() {
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_vs_zephyr_supported_commands_t>(),
        2usize,
        concat!("Size of: ", stringify!(sdc_hci_vs_zephyr_supported_commands_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_vs_zephyr_supported_commands_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_vs_zephyr_supported_commands_t))
    );
}
impl sdc_hci_vs_zephyr_supported_commands_t {
    #[inline]
    pub fn read_version_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_version_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_supported_commands(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_supported_commands(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_supported_features(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_supported_features(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_event_mask(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_set_event_mask(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reset(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_reset(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_bd_addr(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_bd_addr(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_trace_enable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_set_trace_enable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_build_info(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_build_info(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_static_addresses(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_static_addresses(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_key_hierarchy_roots(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_key_hierarchy_roots(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_chip_temperature(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_chip_temperature(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_host_stack_commands(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_host_stack_commands(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn set_scan_request_reports(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_set_scan_request_reports(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn write_tx_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_write_tx_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn read_tx_power_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_read_tx_power_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        read_version_info: u8,
        read_supported_commands: u8,
        read_supported_features: u8,
        set_event_mask: u8,
        reset: u8,
        write_bd_addr: u8,
        set_trace_enable: u8,
        read_build_info: u8,
        read_static_addresses: u8,
        read_key_hierarchy_roots: u8,
        read_chip_temperature: u8,
        read_host_stack_commands: u8,
        set_scan_request_reports: u8,
        write_tx_power_level: u8,
        read_tx_power_level: u8,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let read_version_info: u8 = unsafe { ::core::mem::transmute(read_version_info) };
            read_version_info as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let read_supported_commands: u8 = unsafe { ::core::mem::transmute(read_supported_commands) };
            read_supported_commands as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let read_supported_features: u8 = unsafe { ::core::mem::transmute(read_supported_features) };
            read_supported_features as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let set_event_mask: u8 = unsafe { ::core::mem::transmute(set_event_mask) };
            set_event_mask as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let reset: u8 = unsafe { ::core::mem::transmute(reset) };
            reset as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let write_bd_addr: u8 = unsafe { ::core::mem::transmute(write_bd_addr) };
            write_bd_addr as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let set_trace_enable: u8 = unsafe { ::core::mem::transmute(set_trace_enable) };
            set_trace_enable as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let read_build_info: u8 = unsafe { ::core::mem::transmute(read_build_info) };
            read_build_info as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let read_static_addresses: u8 = unsafe { ::core::mem::transmute(read_static_addresses) };
            read_static_addresses as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let read_key_hierarchy_roots: u8 = unsafe { ::core::mem::transmute(read_key_hierarchy_roots) };
            read_key_hierarchy_roots as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let read_chip_temperature: u8 = unsafe { ::core::mem::transmute(read_chip_temperature) };
            read_chip_temperature as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let read_host_stack_commands: u8 = unsafe { ::core::mem::transmute(read_host_stack_commands) };
            read_host_stack_commands as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let set_scan_request_reports: u8 = unsafe { ::core::mem::transmute(set_scan_request_reports) };
            set_scan_request_reports as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let write_tx_power_level: u8 = unsafe { ::core::mem::transmute(write_tx_power_level) };
            write_tx_power_level as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let read_tx_power_level: u8 = unsafe { ::core::mem::transmute(read_tx_power_level) };
            read_tx_power_level as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_subevent_vs_qos_conn_event_report_t {
    #[doc = "  Connnection handle corresponding to the connection event report."]
    pub conn_handle: u16,
    #[doc = "  Connection event counter corresponding to the connection event report."]
    pub event_counter: u16,
    #[doc = "  Data Channel Index used during the connection event (0-36)."]
    pub channel_index: u8,
    #[doc = "  Number of packets received with good CRC during the connection event."]
    pub crc_ok_count: u16,
    #[doc = "  Number of packets received with bad CRC during the connection event."]
    pub crc_error_count: u16,
    #[doc = "  Number of received Negative Acknowledges from the peer during the connection event."]
    pub nak_count: u16,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_sdc_hci_subevent_vs_qos_conn_event_report_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_subevent_vs_qos_conn_event_report_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_subevent_vs_qos_conn_event_report_t>(),
        12usize,
        concat!("Size of: ", stringify!(sdc_hci_subevent_vs_qos_conn_event_report_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_subevent_vs_qos_conn_event_report_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_subevent_vs_qos_conn_event_report_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_subevent_vs_qos_conn_event_report_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_counter) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_subevent_vs_qos_conn_event_report_t),
            "::",
            stringify!(event_counter)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channel_index) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_subevent_vs_qos_conn_event_report_t),
            "::",
            stringify!(channel_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crc_ok_count) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_subevent_vs_qos_conn_event_report_t),
            "::",
            stringify!(crc_ok_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).crc_error_count) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_subevent_vs_qos_conn_event_report_t),
            "::",
            stringify!(crc_error_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nak_count) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_subevent_vs_qos_conn_event_report_t),
            "::",
            stringify!(nak_count)
        )
    );
}
impl sdc_hci_subevent_vs_qos_conn_event_report_t {
    #[inline]
    pub fn rx_timeout(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rx_timeout(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(rx_timeout: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let rx_timeout: u8 = unsafe { ::core::mem::transmute(rx_timeout) };
            rx_timeout as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_version_info_return_t {
    #[doc = "  Assigned hardware manufacturer. Always 0x0002 indicating Nordic Semiconductor."]
    pub hw_platform: u16,
    #[doc = "  Assigned platform specific value. Set to 0x2 for nRF52, 0x3 for nRF53."]
    pub hw_variant: u16,
    #[doc = "  Firmware Variant. 0 indicates a standard Bluetooth controller."]
    pub fw_variant: u8,
    #[doc = "  Firmware Version."]
    pub fw_version: u8,
    #[doc = "  Firmware Revision."]
    pub fw_revision: u16,
    #[doc = "  Firware build revision."]
    pub fw_build: u32,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_read_version_info_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_read_version_info_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_version_info_return_t>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_version_info_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_platform) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t),
            "::",
            stringify!(hw_platform)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw_variant) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t),
            "::",
            stringify!(hw_variant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_variant) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t),
            "::",
            stringify!(fw_variant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_version) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t),
            "::",
            stringify!(fw_version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_revision) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t),
            "::",
            stringify!(fw_revision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw_build) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_version_info_return_t),
            "::",
            stringify!(fw_build)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t {
    #[doc = "  Bit mask for each vendor command. If a bit is 1, the Controller supports the\n         corresponding command and the features required for the command, unsupported or\n         undefined commands shall be set to 0."]
    pub params: sdc_hci_vs_zephyr_supported_commands_t,
    pub raw: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_write_bd_addr_t {
    #[doc = "  BD_ADDR of the Device."]
    pub bd_addr: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_write_bd_addr_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_write_bd_addr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_write_bd_addr_t>(),
        6usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_zephyr_write_bd_addr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_write_bd_addr_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_zephyr_write_bd_addr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bd_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_write_bd_addr_t),
            "::",
            stringify!(bd_addr)
        )
    );
}
#[repr(C, packed)]
pub struct sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t {
    #[doc = "  Number of static device addresses."]
    pub num_addresses: u8,
    #[doc = "  Zephyr Static Addresses. The number of addresses is specified in num_addresses."]
    pub addresses: __IncompleteArrayField<sdc_hci_vs_zephyr_static_address_t>,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_addresses) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t),
            "::",
            stringify!(num_addresses)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addresses) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t),
            "::",
            stringify!(addresses)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t {
    #[doc = "  Zephyr Identity Root Key."]
    pub ir: [u8; 16usize],
    #[doc = "  Zephyr Encryption Root Key."]
    pub er: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ir) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t),
            "::",
            stringify!(ir)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).er) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t),
            "::",
            stringify!(er)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t {
    #[doc = "  The measured temperature in degrees Celsius."]
    pub temp: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).temp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t),
            "::",
            stringify!(temp)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_write_tx_power_t {
    #[doc = "  Handle type. See @ref sdc_hci_vs_tx_power_handle_type."]
    pub handle_type: u8,
    #[doc = "  Handle of the selected handle_type that identifies the instance to set the power of.\n         In case of Extended Advertising, the handle specifies the advertising set. In case of\n         a connection, it specifies a Connection Handle. Otherwise this parameter is ignored."]
    pub handle: u16,
    #[doc = "  The desired Tx_Power_Level at the antenna in dBm in signed 1 octet integer format. If\n         set to 127, this indicates that the controller shall revert to using its default\n         setting for Tx power. If the selected power level is not supported, an error is\n         returned."]
    pub tx_power_level: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_write_tx_power_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_write_tx_power_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_write_tx_power_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_write_tx_power_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_t),
            "::",
            stringify!(handle_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_power_level) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_t),
            "::",
            stringify!(tx_power_level)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_write_tx_power_return_t {
    #[doc = "  Handle type. See @ref sdc_hci_vs_tx_power_handle_type."]
    pub handle_type: u8,
    #[doc = "  See @ref sdc_hci_cmd_vs_zephyr_write_tx_power_t."]
    pub handle: u16,
    #[doc = "  The selected Tx Power in dBm."]
    pub selected_tx_power: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_write_tx_power_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_write_tx_power_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_write_tx_power_return_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_write_tx_power_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_return_t),
            "::",
            stringify!(handle_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_return_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selected_tx_power) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_write_tx_power_return_t),
            "::",
            stringify!(selected_tx_power)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_tx_power_t {
    #[doc = "  Handle type. See @ref sdc_hci_vs_tx_power_handle_type."]
    pub handle_type: u8,
    #[doc = "  Handle of the selected handle_type that identifies the instance to set the power of.\n         In case of Extended Advertising, the handle specifies the advertising set. In case of\n         a connection, it specifies a Connection Handle. Otherwise this parameter is ignored."]
    pub handle: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_read_tx_power_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_read_tx_power_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_tx_power_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_tx_power_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_t),
            "::",
            stringify!(handle_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_t),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_zephyr_read_tx_power_return_t {
    #[doc = "  Handle type. See @ref sdc_hci_vs_tx_power_handle_type."]
    pub handle_type: u8,
    #[doc = "  See @ref sdc_hci_cmd_vs_zephyr_read_tx_power_t."]
    pub handle: u16,
    #[doc = "  The selected Tx Power in dBm."]
    pub selected_tx_power: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_zephyr_read_tx_power_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_zephyr_read_tx_power_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_zephyr_read_tx_power_return_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_return_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_zephyr_read_tx_power_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_return_t),
            "::",
            stringify!(handle_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_return_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).selected_tx_power) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_zephyr_read_tx_power_return_t),
            "::",
            stringify!(selected_tx_power)
        )
    );
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union sdc_hci_cmd_vs_read_supported_vs_commands_return_t {
    pub params: sdc_hci_vs_supported_vs_commands_t,
    pub raw: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_read_supported_vs_commands_return_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_read_supported_vs_commands_return_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_read_supported_vs_commands_return_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(sdc_hci_cmd_vs_read_supported_vs_commands_return_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_read_supported_vs_commands_return_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_read_supported_vs_commands_return_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_read_supported_vs_commands_return_t),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).raw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_read_supported_vs_commands_return_t),
            "::",
            stringify!(raw)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_llpm_mode_set_t {
    #[doc = "  Set to 1 to enable LLPM."]
    pub enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_llpm_mode_set_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_llpm_mode_set_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_llpm_mode_set_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_llpm_mode_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_llpm_mode_set_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_llpm_mode_set_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_llpm_mode_set_t),
            "::",
            stringify!(enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_conn_update_t {
    #[doc = "  Connection Handle."]
    pub connection_handle: u16,
    #[doc = "  Connection Interval in microseconds. Valid range is 7,500 us to 4,000,000 us in 1,250\n         us steps. If LLPM mode is enabled, parameters in the range 1,000 us to 7,000 us in\n         1,000 us steps are also accepted."]
    pub conn_interval_us: u32,
    #[doc = "  Slave latency for the connection in number of connection events."]
    pub conn_latency: u16,
    #[doc = "  Supervision timeout for the LE Link in 10 ms units. Range 100 ms to 32 s."]
    pub supervision_timeout: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_conn_update_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_conn_update_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_conn_update_t>(),
        10usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_conn_update_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_conn_update_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_conn_update_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).connection_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_conn_update_t),
            "::",
            stringify!(connection_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_interval_us) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_conn_update_t),
            "::",
            stringify!(conn_interval_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_latency) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_conn_update_t),
            "::",
            stringify!(conn_latency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).supervision_timeout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_conn_update_t),
            "::",
            stringify!(supervision_timeout)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_conn_event_extend_t {
    #[doc = "  Set to 0 for disabling, 1 for enabling, all other values are RFU."]
    pub enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_conn_event_extend_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_conn_event_extend_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_conn_event_extend_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_conn_event_extend_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_conn_event_extend_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_conn_event_extend_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_conn_event_extend_t),
            "::",
            stringify!(enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_qos_conn_event_report_enable_t {
    #[doc = "  Set to 0 for disabling, 1 for enabling, all other values are RFU."]
    pub enable: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_qos_conn_event_report_enable_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_qos_conn_event_report_enable_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_qos_conn_event_report_enable_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_qos_conn_event_report_enable_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_qos_conn_event_report_enable_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_qos_conn_event_report_enable_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_qos_conn_event_report_enable_t),
            "::",
            stringify!(enable)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_event_length_set_t {
    #[doc = "  Allocated event length in microseconds."]
    pub event_length_us: u32,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_event_length_set_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_event_length_set_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_event_length_set_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_event_length_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_event_length_set_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_event_length_set_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_length_us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_event_length_set_t),
            "::",
            stringify!(event_length_us)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_periodic_adv_event_length_set_t {
    #[doc = "  Allocated periodic advertising event length in microseconds."]
    pub event_length_us: u32,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_periodic_adv_event_length_set_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_periodic_adv_event_length_set_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_periodic_adv_event_length_set_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_periodic_adv_event_length_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_periodic_adv_event_length_set_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_periodic_adv_event_length_set_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_length_us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_periodic_adv_event_length_set_t),
            "::",
            stringify!(event_length_us)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_coex_scan_mode_config_t {
    #[doc = "  Scanner request mode. See @ref sdc_hci_vs_coex_scan_mode."]
    pub mode: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_coex_scan_mode_config_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_coex_scan_mode_config_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_coex_scan_mode_config_t>(),
        1usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_coex_scan_mode_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_coex_scan_mode_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_coex_scan_mode_config_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_coex_scan_mode_config_t),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_coex_priority_config_t {
    #[doc = "  Current Bluetooth device role, see @ref sdc_hci_vs_coex_bt_role."]
    pub role: u8,
    #[doc = "  @ref MPSL_COEX_PRIORITY_HIGH or @ref MPSL_COEX_PRIORITY_LOW priority."]
    pub priority: u8,
    #[doc = "  When the number of denied requests to the PTA controller is larger than the\n         escalation threshold, the priority will be escalated. The threshold is handled only\n         if priority is @ref MPSL_COEX_PRIORITY_LOW. The priority will be reset to @ref\n         MPSL_COEX_PRIORITY_LOW after the end of the current radio activity. This means after\n         the end of the advertising event, scan window, or connection event. If an escalation\n         is not required then use @ref MPSL_COEX_ESCALATION_THRESHOLD_OFF."]
    pub escalation_threshold: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_coex_priority_config_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_coex_priority_config_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_coex_priority_config_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_coex_priority_config_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_coex_priority_config_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_coex_priority_config_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_coex_priority_config_t),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_coex_priority_config_t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).escalation_threshold) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_coex_priority_config_t),
            "::",
            stringify!(escalation_threshold)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_peripheral_latency_mode_set_t {
    #[doc = "  Connection handle."]
    pub conn_handle: u16,
    #[doc = "  Peripheral latency mode. See @ref sdc_hci_vs_peripheral_latency_mode."]
    pub mode: u8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_peripheral_latency_mode_set_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_peripheral_latency_mode_set_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_peripheral_latency_mode_set_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_peripheral_latency_mode_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_peripheral_latency_mode_set_t>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(sdc_hci_cmd_vs_peripheral_latency_mode_set_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_peripheral_latency_mode_set_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_peripheral_latency_mode_set_t),
            "::",
            stringify!(mode)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_write_remote_tx_power_t {
    pub conn_handle: u16,
    #[doc = "  Phy value to apply transmit power level adjustment."]
    pub phy: u8,
    #[doc = "  The transmit power level adjustment to request in dBm unit."]
    pub delta: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_write_remote_tx_power_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_write_remote_tx_power_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_write_remote_tx_power_t>(),
        4usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_write_remote_tx_power_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_write_remote_tx_power_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_write_remote_tx_power_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).conn_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_write_remote_tx_power_t),
            "::",
            stringify!(conn_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_write_remote_tx_power_t),
            "::",
            stringify!(phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_write_remote_tx_power_t),
            "::",
            stringify!(delta)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_set_rssi_golden_range_t {
    #[doc = "  Phy value to set RSSI golden range values."]
    pub phy: u8,
    #[doc = "  The RSSI golden range lower limit in dBm units."]
    pub lower_limit: i8,
    #[doc = "  The RSSI golden range upper limit in dBm units."]
    pub upper_limit: i8,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_set_rssi_golden_range_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_set_rssi_golden_range_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_set_rssi_golden_range_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_set_rssi_golden_range_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_set_rssi_golden_range_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_set_rssi_golden_range_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_set_rssi_golden_range_t),
            "::",
            stringify!(phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lower_limit) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_set_rssi_golden_range_t),
            "::",
            stringify!(lower_limit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upper_limit) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_set_rssi_golden_range_t),
            "::",
            stringify!(upper_limit)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_hci_cmd_vs_set_adv_randomness_t {
    #[doc = "  Advertising Handle or 0xFF to set the behavior for the very first advertising event."]
    pub adv_handle: u8,
    #[doc = "  Maximum random delay in microseconds, 0 to disable randomness."]
    pub rand_us: u16,
}
#[test]
fn bindgen_test_layout_sdc_hci_cmd_vs_set_adv_randomness_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_hci_cmd_vs_set_adv_randomness_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_hci_cmd_vs_set_adv_randomness_t>(),
        3usize,
        concat!("Size of: ", stringify!(sdc_hci_cmd_vs_set_adv_randomness_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_hci_cmd_vs_set_adv_randomness_t>(),
        1usize,
        concat!("Alignment of ", stringify!(sdc_hci_cmd_vs_set_adv_randomness_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adv_handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_set_adv_randomness_t),
            "::",
            stringify!(adv_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_us) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_hci_cmd_vs_set_adv_randomness_t),
            "::",
            stringify!(rand_us)
        )
    );
}
extern "C" {
    #[doc = " @defgroup HCI_VS_API API\n @{\n/\n/** @brief Zephyr Read Version Information.\n\n Reads the values for the vendor version information for the local Controller.\n\n The Hardware_Platform information defines the hardware manufacturer\n information. The Hardware_Variant is manufacturer specific and defines the\n hardware platform from that manufacturer.\n\n The Firmware_Variant defines the type of firmware. It is possible to provide\n HCI firmware with limited functionality for example for bootloader operation.\n The Firmware_Version and Firmware_Revision define version information of the\n Firmware_Variant that is currently active. The Firmware_Build defines an\n additional counter for incremental builds.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_version_info(
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_version_info_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Zephyr Read Supported Commands.\n\n This command reads the list of vendor commands supported for the local Controller.\n\n This command shall return the Supported_Commands configuration parameter. It is\n implied that if a command is listed as supported, the feature underlying that\n command is also supported.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_supported_commands(
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_supported_commands_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Zephyr Write BD ADDR.\n\n This command writes the BD_ADDR (Bluetooth public device address) value\n to the volatile memory. The address does not change during an HCI Reset but is\n reset during a System Reset.\n The address can be read out using the Read_BD_ADDR command.\n\n When the Write_BD_ADDR command has completed, a Command Complete event shall\n be generated.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_write_bd_addr(p_params: *const sdc_hci_cmd_vs_zephyr_write_bd_addr_t) -> u8;
}
extern "C" {
    #[doc = "  Zephyr Read Static Addresses.\n\n This commands reads the controller specific static addresses.\n\n This command shall return the static addresses programmed by the vendor at\n manufacturing time.\n\n Each returned static address shall confirm to the Static Device Address\n definition. The two most significant bits of the address shall be equal to 1.\n At least one bit of the random part of the address shall be 0. At least one bit\n of the random part of the address shall be 1.\n\n The Identity_Root parameter may be all zeros to indicate no identity root key\n being available for a given static address. The identity root key returned from\n Read_Key_Hierarchy_Roots command shall not be returned from this command.\n\n Note: If no public address is provided and a static address is available, then\n it is recommended to return an identity root key (if available) from this\n command. In case a public address is provided, then it is recommended to use\n the Read_Key_Hierarchy_Roots command to return the identity root key (if only\n one is available).\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_static_addresses(
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_static_addresses_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Zephyr Read KEY Hierarchy Roots.\n\n This commands reads the controller specific identify and encryption root keys.\n\n This command shall return the identity root key and encryption root key\n programmed by the vendor at manufacturing time. If a key is set to all zeros,\n then the associated key is not available and it should not be used in the key\n hierarchy.\n\n The identity root key and encryption root key may be used for the controllers\n public device address or a static random address generated by the host. It\n shall not be used for static addresses returned by Read_Static_Addresses\n command that have its dedicated identity root key assigned.\n\n Note: For addresses returned by Read_Static_Addresses with an all zeros\n identity root key, the returned Identity_Root value may be used. It is however\n important that it only gets assigned to a single address (either public or\n static random).\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots(
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_key_hierarchy_roots_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Zephyr Read Chip Temperature.\n\n This commands reads the controller chip temperature.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_chip_temp(p_return: *mut sdc_hci_cmd_vs_zephyr_read_chip_temp_return_t) -> u8;
}
extern "C" {
    #[doc = "  Zephyr Write Tx Power Level (per Role/Connection).\n\n This command dynamically modifies Bluetooth LE Tx power level at the antenna given a handle and a\n handle type (advertiser, scanner, connection).\n\n The Tx power of the Bluetooth LE radio interface is modified for any low-level link by\n the controller with a high degree of flexibility. The Bluetooth LE link whose power is\n set is identified based on a handle type (advertiser, scanner, connection) and\n handle pair.\n\n The role/state defining input parameter is the Handle_Type, whereas its\n corresponding handle is provided by the Handle input parameter. Note that\n for Advertisements, the Handle input parameter is ignored in the case that\n Advertising Extensions are not configured, whereas Advertising Sets are to be\n identified by their corresponding Handle in case Advertising Extensions are\n enabled.\n\n The desired transmitter power level for the selected link instance is inputted\n as Tx_Power_Level. This value represents the actual power level fed to the antenna.\n When a Front-End Module is used, gain values for the SoC and FEM are calculated\n automatically to guarantee closest possible match to the value requested by the user\n at the RF output. The power setup and control can be performed dynamically\n without the need of restarting the advertiser and scanner role/states. In case\n of connections, the Tx power changes take effect only if the connections are\n in a connected state.\n\n The inputs Handle_Type and Handle are passed through as outputs to aid the\n asynchronous service of the command as well. In addition, the command returns\n also with the Selected_Tx_Power by the controller which addresses and corrects\n the possible mismatches between the desired Tx_Power_Level and the achievable\n Tx powers given each individual controller capabilities.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_write_tx_power(
        p_params: *const sdc_hci_cmd_vs_zephyr_write_tx_power_t,
        p_return: *mut sdc_hci_cmd_vs_zephyr_write_tx_power_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Zephyr Read Tx Power Level (per Role/Connection) Command.\n\n This command reads the BLE Tx power level.\n\n In contrast to the standardized HCI command, i.e. Read_Transmit_Power_Level,\n which returns the transmitted power level only for a specified connection handle,\n this command operates for both connected and unconnected states.\n It gets the BLE Tx power level for any given handle type (advertiser, scanner, connection) and\n handle.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_zephyr_read_tx_power(
        p_params: *const sdc_hci_cmd_vs_zephyr_read_tx_power_t,
        p_return: *mut sdc_hci_cmd_vs_zephyr_read_tx_power_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Read Supported Vendor Specific Commands.\n\n This command reads the list of vendor specific HCI commands supported\n for the local Controller.\n\n This command shall return a bitmap of the supported vendor specific\n commands.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_return` - Extra return parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_read_supported_vs_commands(
        p_return: *mut sdc_hci_cmd_vs_read_supported_vs_commands_return_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Set Low Latency Packet Mode.\n\n This command enables or disables Low Latency Packet Mode support.\n When Low Latency Packet Mode is enabled, it is possible to switch to connection intervals in the\n range 1-7 ms. Switch to short connection intervals by calling @ref sdc_hci_cmd_vs_conn_update().\n\n After HCI Reset, this feature is disabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_llpm_mode_set(p_params: *const sdc_hci_cmd_vs_llpm_mode_set_t) -> u8;
}
extern "C" {
    #[doc = "  Connection Update.\n\n This vendor specific command is used to change the Link Layer Connection parameters of a\n connection.\n This command may be issued by the master only.\n\n The Supervision_Timeout in milliseconds shall be larger than (1 + Conn_Latency) *\n Conn_Interval_Max * 2,\n where Conn_Interval_Max is given in milliseconds.\n\n Event(s) generated (unless masked away):\n When the Controller receives the command, the Controller sends the HCI_Command_Complete\n event to the Host. The HCI_LE_Connection_Update_Complete event shall be generated after\n the connection parameters have been applied by the Controller or if the command\n subsequently fails.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_conn_update(p_params: *const sdc_hci_cmd_vs_conn_update_t) -> u8;
}
extern "C" {
    #[doc = "  Enable or Disable Extended Connection Events.\n\n When Extended Connection Events are disabled, the maximum connection event length is set\n by @ref sdc_hci_cmd_vs_event_length_set(). When Extended Connection Events are enabled, the\n controller\n will extend the connection event as much as possible, if:\n - Either of the peers has more data to send.\n   See also: Core v5.1, Vol 6, Part B, Section 4.5.6\n - There are no conflicts with other concurrent links.\n\n A connection event can not be extended beyond the connection interval.\n\n By default, that is after an HCI Reset, Extended Connection Events are enabled.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_conn_event_extend(p_params: *const sdc_hci_cmd_vs_conn_event_extend_t) -> u8;
}
extern "C" {
    #[doc = "  QoS Connection Event Reports enable.\n\n This vendor specific command is used to enable or disable generation of QoS Connection event\n reports.\n See @ref sdc_hci_subevent_vs_qos_conn_event_report_t. When enabled, one report will be generated\n every connection event.\n\n @note If the application does not pull a report in time, it will be overwritten.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_qos_conn_event_report_enable(
        p_params: *const sdc_hci_cmd_vs_qos_conn_event_report_enable_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Set event length for connections.\n\n Set the event length for new connections. This API must be called before starting a connectable\n advertiser or starting an initiator for the event length to applied to the connection once\n established.\n\n The SoftDevice Controller will ensure that the anchor points of master link connections are\n spaced\n event_length_us apart.\n\n The default event length is @ref SDC_DEFAULT_EVENT_LENGTH_US.\n\n See also @ref sdc_hci_cmd_vs_conn_event_extend().\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_event_length_set(p_params: *const sdc_hci_cmd_vs_event_length_set_t) -> u8;
}
extern "C" {
    #[doc = "  Set event length for periodic advertisers.\n\n Set the allocated event length for new periodic advertisers.\n The SoftDevice Controller will ensure that the anchor points of periodic advertising events are\n spaced\n event_length_us apart. If the advertiser requires less time to transmit all the data, the\n distance to\n the next scheduling activity will still be equal to the configured event length. If the\n advertiser\n requires more time to transmit all the data, scheduling conflicts may occur.\n\n This API must be called before configuring a periodic advertiser for the event length to be\n applied.\n\n The default event length is @ref SDC_DEFAULT_EVENT_LENGTH_US.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_periodic_adv_event_length_set(
        p_params: *const sdc_hci_cmd_vs_periodic_adv_event_length_set_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Configure Coexistence Scan Request Mode.\n\n This vendor specific command is used to configure the way the scanner requests a coexistence\n session.\n Either the scanner requests a coex session as soon as it has received a valid access address, or\n it\n only requests before transmitting.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_coex_scan_mode_config(p_params: *const sdc_hci_cmd_vs_coex_scan_mode_config_t) -> u8;
}
extern "C" {
    #[doc = "  Configure Coexistence Per-Role Priority.\n\n This vendor specific command is used to configure the external radio coexistence\n priorities depending on the Bluetooth device role.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_coex_priority_config(p_params: *const sdc_hci_cmd_vs_coex_priority_config_t) -> u8;
}
extern "C" {
    #[doc = "  Set peripheral latency mode.\n\n This vendor specific command is used to disable/enable peripheral latency.\n Three modes of disable/enable are supported.\n\n In enable mode, the peripheral will wake up every time it has data to send,\n and/or every peripheral latency number of connection events.\n\n In disable mode, the peripheral will wake up on every connection event\n regardless of the requested peripheral latency. This option consumes the most power.\n\n In wait_for_ack mode, the peripheral will wake up on every connection event if\n it has not received an ACK from the master for at least peripheral latency events.\n This configuration may increase the power consumption in environments with a lot of radio\n activity.\n\n @note Shall only be called on peripheral links.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_peripheral_latency_mode_set(
        p_params: *const sdc_hci_cmd_vs_peripheral_latency_mode_set_t,
    ) -> u8;
}
extern "C" {
    #[doc = "  Write remote transmit power level.\n\n This command requests adjustment of radio transmit power level for a connected peer device.\n\n When this command is issued, the controller initiates Power Control Request procedure\n (Core_v5.3, Vol 6, Part B, Section 5.1.17) to request the change from the peer. The\n peer responds with the actual transmit power level change and the controller reports\n the change to the host with an event.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Status event shall be generated.\n When the controller has completed the power control request and if the request has resulted\n in a change in the peer's transmit power level, an HCI_LE_Transmit_Power_Reporting event shall\n be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_write_remote_tx_power(p_params: *const sdc_hci_cmd_vs_write_remote_tx_power_t) -> u8;
}
extern "C" {
    #[doc = "  Set RSSI golden range.\n\n This command sets RSSI golden range that is explained in Core_v5.3, Vol 6, Part B,\n Section 5.1.17.1.\n\n When this command is issued, the controller stores the golden range values per PHY.\n These values can be used to keep RSSI (Received Signal Strength Indication) value\n to be in the golden range.\n\n Event(s) generated (unless masked away):\n When the command has completed, an HCI_Command_Complete event shall be generated.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_set_rssi_golden_range(p_params: *const sdc_hci_cmd_vs_set_rssi_golden_range_t) -> u8;
}
extern "C" {
    #[doc = "  Set advertising randomness.\n\n This vendor specific command is used to change the randomness of advertisers.\n The setting applies to all subsequent advertising events of a given set.\n\n Event(s) generated (unless masked away):\n When the Controller receives the command, the Controller sends the HCI_Command_Complete\n event to the Host.\n\n * `p_params` - Input parameters.\n\n Returns 0 if success.\n Returns Returns value between 0x01-0xFF in case of error.\n         See Vol 2, Part D, Error for a list of error codes and descriptions."]
    pub fn sdc_hci_cmd_vs_set_adv_randomness(p_params: *const sdc_hci_cmd_vs_set_adv_randomness_t) -> u8;
}
pub const sdc_soc_flash_cmd_status_SDC_SOC_FLASH_CMD_STATUS_SUCCESS: sdc_soc_flash_cmd_status = 0;
pub const sdc_soc_flash_cmd_status_SDC_SOC_FLASH_CMD_STATUS_TIMEOUT: sdc_soc_flash_cmd_status = 1;
#[doc = "  Flash command status."]
pub type sdc_soc_flash_cmd_status = crate::ctypes::c_uint;
#[doc = "  Flash command callback.\n\n The flash command callback will be called when a flash operation is completed.\n It will be executed in the same execution priority as @ref mpsl_low_priority_process.\n\n * `status` - The status of the flash operation. @sa SDC_SOC_FLASH_CMD_STATUS."]
pub type sdc_soc_flash_callback_t = ::core::option::Option<unsafe extern "C" fn(status: u32)>;
extern "C" {
    #[doc = "  Write data to flash.\n\n This asynchronous API will ensure that the flash operation will not interfere with radio activity.\n The completion will be communicated to the application through the provided callback function.\n\n @note The data in the p_src buffer should not be modified before the completion callback has\n       been executed.\n\n * `addr` - Flash location to be written.\n * `p_src` - Pointer to buffer with data to be written.\n * `size` - Number of 32-bit words to write. Maximum size is the number of words in one\n                         flash page. See the device's Product Specification for details.\n * `on_complete` - Callback to be called when flash is written.\n                         The callback will be executed in the context as\n                         @ref mpsl_low_priority_process.\n\n Returns 0                   Success\n Returns -NRF_EINVAL         Either:\n                                - Tried to write to a non existing flash address\n                                - addr or p_src was not word aligned\n                                - Size was 0, or higher than the maximum allowed size\n Returns -NRF_EINPROGRESS    Previous flash operation is not yet completed"]
    pub fn sdc_soc_flash_write_async(
        addr: u32,
        p_src: *const crate::ctypes::c_void,
        size: u32,
        on_complete: sdc_soc_flash_callback_t,
    ) -> i32;
}
extern "C" {
    #[doc = "  Erase a flash page.\n\n This asynchronous API will ensure that the flash operation will not interfere with radio activity.\n The completion will be communicated to the application through the provided callback function.\n\n * `addr` - Start address of the flash page to be erased.\n                         If the address is not aligned with the start of flash page,\n                         the page containing this address will be erased.\n * `on_complete` - Function to be called when page is erased.\n                         The callback will be executed in the context as\n                         @ref mpsl_low_priority_process.\n\n Returns 0                   Success\n Returns -NRF_EINVAL         Tried to erase a non existing flash page.\n Returns -NRF_EINPROGRESS    Previous flash operation is not yet completed"]
    pub fn sdc_soc_flash_page_erase_async(addr: u32, on_complete: sdc_soc_flash_callback_t) -> i32;
}
extern "C" {
    #[doc = "  Encrypt a block according to the specified parameters.\n\n The SoftDevice Controller will use NRF_ECB encrypt the block. The encryption type is 128-bit AES.\n\n @note The application may set the SEVONPEND bit in the SCR to 1 to make the SoftDevice Controller sleep\n       while the ECB is running. The SEVONPEND bit must not be cleared (set to 0) from a function\n       running in an interrupt priority level higher (lower numerical value) than the execution priority\n       level this function was called from.\n\n * `key` - Encryption key\n * `cleartext` - Cleartext data\n * `ciphertext` - Encrypted data\n\n Returns 0 Success"]
    pub fn sdc_soc_ecb_block_encrypt(key: *const u8, cleartext: *const u8, ciphertext: *mut u8) -> i32;
}
#[doc = "  Functions used by the SoftDevice Controller to obtain random numbers.\n\n These functions are used for several different purposes,\n including private address generation so they are expected to conform to:\n BLUETOOTH CORE SPECIFICATION Version 5.2 | Vol 2, Part H, Section 2."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdc_rand_source_t {
    #[doc = "  Function used by the controller to obtain random numbers in a low priority context.\n  The function will be executed in the same context as mpsl_low_priority_process and should not block.\n\n * `p_buff` - The destination buffer for the random numbers\n * `length` - The requested number of random bytes and the maximum length of the destination buffer\n  Returns              The number of bytes written to p_buff"]
    pub rand_prio_low_get: ::core::option::Option<unsafe extern "C" fn(p_buff: *mut u8, length: u8) -> u8>,
    #[doc = "  Function used by the controller to obtain random numbers in a high priority context.\n  This function will be called in an ISR context and should not block.\n\n * `p_buff` - The destination buffer for the random numbers\n * `length` - The requested number of random bytes and the maximum length of the destination buffer\n  Returns              The number of bytes written to p_buff"]
    pub rand_prio_high_get: ::core::option::Option<unsafe extern "C" fn(p_buff: *mut u8, length: u8) -> u8>,
    #[doc = "  Function used by the controller to obtain random numbers.\n  This function must block until length bytes of random numbers were written to p_buff.\n  The function will be executed in the same context as mpsl_low_priority_process.\n\n * `p_buff` - The destination buffer for the random numbers\n * `length` - The requested number of random bytes and the maximum length of the destination buffer"]
    pub rand_poll: ::core::option::Option<unsafe extern "C" fn(p_buff: *mut u8, length: u8)>,
}
#[test]
fn bindgen_test_layout_sdc_rand_source_t() {
    const UNINIT: ::core::mem::MaybeUninit<sdc_rand_source_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sdc_rand_source_t>(),
        12usize,
        concat!("Size of: ", stringify!(sdc_rand_source_t))
    );
    assert_eq!(
        ::core::mem::align_of::<sdc_rand_source_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sdc_rand_source_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_prio_low_get) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_rand_source_t),
            "::",
            stringify!(rand_prio_low_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_prio_high_get) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_rand_source_t),
            "::",
            stringify!(rand_prio_high_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rand_poll) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdc_rand_source_t),
            "::",
            stringify!(rand_poll)
        )
    );
}
extern "C" {
    #[doc = "  Pass a source of randomness to the SoftDevice Controller\n\n The SoftDevice Controller will use the function pointers provided in this function call to get random numbers.\n\n * `rand_source` - A table of function pointers to obtain random numbers\n\n Returns 0 Success"]
    pub fn sdc_rand_source_register(rand_source: *const sdc_rand_source_t) -> i32;
}
#[doc = "< LFCLK RC oscillator."]
pub const MPSL_CLOCK_LF_SRC_MPSL_CLOCK_LF_SRC_RC: MPSL_CLOCK_LF_SRC = 0;
#[doc = "< LFCLK crystal oscillator."]
pub const MPSL_CLOCK_LF_SRC_MPSL_CLOCK_LF_SRC_XTAL: MPSL_CLOCK_LF_SRC = 1;
#[doc = "< LFCLK Synthesized from HFCLK."]
pub const MPSL_CLOCK_LF_SRC_MPSL_CLOCK_LF_SRC_SYNTH: MPSL_CLOCK_LF_SRC = 2;
#[doc = "  Low frequency clock source."]
pub type MPSL_CLOCK_LF_SRC = crate::ctypes::c_uint;
#[doc = "  Type representing LFCLK oscillator source."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_clock_lfclk_cfg_t {
    #[doc = " LF oscillator clock source, see @ref MPSL_CLOCK_LF_SRC."]
    pub source: u8,
    #[doc = " Only for ::MPSL_CLOCK_LF_SRC_RC.\n  Calibration timer interval in 1/4 second units.\n\n  @note To avoid excessive clock drift, 0.5 degrees Celsius is\n        the maximum temperature change allowed in one calibration timer interval.\n        The interval should be selected to ensure this.\n\n  @note Must be 0 if source is not ::MPSL_CLOCK_LF_SRC_RC."]
    pub rc_ctiv: u8,
    #[doc = " Only for ::MPSL_CLOCK_LF_SRC_RC.\n  How often (in number of calibration intervals) the RC oscillator shall be\n  calibrated if the temperature hasn't changed.\n  * 0: Always calibrate even if the temperature hasn't changed.\n  * 1-33: Check the temperature and only calibrate if it has changed,\n          however calibration will take place every rc_temp_ctiv intervals in any case.\n\n  @note Must be 0 if source is not ::MPSL_CLOCK_LF_SRC_RC.\n\n  @note The application must ensure calibration at least\n        once every 8 seconds to ensure +/-500 ppm clock stability.\n        The recommended configuration for ::MPSL_CLOCK_LF_SRC_RC\n        is given by @ref MPSL_RECOMMENDED_RC_CTIV and\n        @ref MPSL_RECOMMENDED_RC_TEMP_CTIV.\n        This sets the calibration interval to 4 seconds\n        and guarantees clock calibration every second calibration interval.\n        That is, the clock will be calibrated every 8 seconds.\n        If the temperature changes more that 0.5 every 4 seconds,\n        the clock will be calibrated every 4 seconds.\n        See the Product Specification for more information."]
    pub rc_temp_ctiv: u8,
    #[doc = " Accuracy of the low frequency clock in parts per million (ppm).\n  Default value is @ref MPSL_DEFAULT_CLOCK_ACCURACY_PPM."]
    pub accuracy_ppm: u16,
    #[doc = " Determines whether MPSL waits for the low frequency clock to start\n  during initialization or not.\n  If it is set to true, MPSL will wait for the low frequency clock later,\n  before the low frequency clock is used for the first time.\n  Default value is @ref MPSL_DEFAULT_SKIP_WAIT_LFCLK_STARTED.\n\n @note If this option is set to true and the application writes to\n       NRF_CLOCK->TASKS_LFCLKSTART before mpsl_init() is called,\n       the application shall either:\n       - Write to NRF_CLOCK->TASKS_LFCLKSTOP.\n       - Keep NRF_CLOCK->EVENTS_LFCLKSTARTED untouched."]
    pub skip_wait_lfclk_started: bool_,
}
#[test]
fn bindgen_test_layout_mpsl_clock_lfclk_cfg_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_clock_lfclk_cfg_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_clock_lfclk_cfg_t>(),
        8usize,
        concat!("Size of: ", stringify!(mpsl_clock_lfclk_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_clock_lfclk_cfg_t>(),
        2usize,
        concat!("Alignment of ", stringify!(mpsl_clock_lfclk_cfg_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).source) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_clock_lfclk_cfg_t),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rc_ctiv) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_clock_lfclk_cfg_t),
            "::",
            stringify!(rc_ctiv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rc_temp_ctiv) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_clock_lfclk_cfg_t),
            "::",
            stringify!(rc_temp_ctiv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).accuracy_ppm) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_clock_lfclk_cfg_t),
            "::",
            stringify!(accuracy_ppm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).skip_wait_lfclk_started) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_clock_lfclk_cfg_t),
            "::",
            stringify!(skip_wait_lfclk_started)
        )
    );
}
pub const mpsl_clock_hfclk_latency_config_t_MPSL_CLOCK_HF_LATENCY_BEST: mpsl_clock_hfclk_latency_config_t = 396;
pub const mpsl_clock_hfclk_latency_config_t_MPSL_CLOCK_HF_LATENCY_TYPICAL: mpsl_clock_hfclk_latency_config_t = 854;
pub const mpsl_clock_hfclk_latency_config_t_MPSL_CLOCK_HF_LATENCY_WORST_CASE: mpsl_clock_hfclk_latency_config_t = 1525;
pub type mpsl_clock_hfclk_latency_config_t = crate::ctypes::c_uint;
#[doc = "  High frequency clock callback.\n\n This callback will be called when the high frequency clock is started.\n It will be executed in the same execution priority as @ref mpsl_low_priority_process."]
pub type mpsl_clock_hfclk_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = "  Request the high frequency crystal oscillator.\n\n Will start the high frequency crystal oscillator, the startup time of the crystal varies\n and the ::mpsl_clock_hfclk_is_running function can be polled to check if it has started.\n\n @see mpsl_clock_hfclk_is_running\n @see mpsl_clock_hfclk_release\n\n * `hfclk_started_callback` - Function to be called when the high frequency clock is started.\n                                   The callback will be executed in the context as\n                                   @ref mpsl_low_priority_process.\n Returns 0  Success"]
    pub fn mpsl_clock_hfclk_request(hfclk_started_callback: mpsl_clock_hfclk_callback_t) -> i32;
}
extern "C" {
    #[doc = "  Releases the high frequency crystal oscillator.\n\n Indicates that the high frequency crystal oscillator is not needed by the application.\n MPSL may continue to use the high frequency clock if it is requested by protocol stacks.\n MPSL will automatically turn it off when it is no longer needed.\n\n @see mpsl_clock_hfclk_is_running\n @see mpsl_clock_hfclk_request\n\n Returns 0  Success"]
    pub fn mpsl_clock_hfclk_release() -> i32;
}
extern "C" {
    #[doc = "  Checks if the high frequency crystal oscillator is running.\n\n @see mpsl_clock_hfclk_request\n @see mpsl_clock_hfclk_release\n\n * `p_is_running` - 1 if the external crystal oscillator is running, 0 if not.\n\n Returns 0  Success"]
    pub fn mpsl_clock_hfclk_is_running(p_is_running: *mut u32) -> i32;
}
extern "C" {
    #[doc = "  Informs MPSL about the actual ramp-up time of the high-frequency crystal oscillator.\n\n * `mpsl_clock_hfclk_latency_config` - Setting for the time it takes for the HFCLK to ramp up.\n\n Returns 0  Success"]
    pub fn mpsl_clock_hfclk_latency_set(mpsl_clock_hfclk_latency_config: mpsl_clock_hfclk_latency_config_t) -> i32;
}
#[doc = "< Low priority for the related coexistence interface event."]
pub const MPSL_COEX_PRIORITY_MPSL_COEX_PRIORITY_LOW: MPSL_COEX_PRIORITY = 0;
#[doc = "< High priority for the related coexistence interface event."]
pub const MPSL_COEX_PRIORITY_MPSL_COEX_PRIORITY_HIGH: MPSL_COEX_PRIORITY = 1;
#[doc = "< Number of priorities in the coexistence interface."]
pub const MPSL_COEX_PRIORITY_MPSL_COEX_PRIORITY_NUMBER: MPSL_COEX_PRIORITY = 2;
#[doc = "  Possible priorities to handle related BLE event."]
pub type MPSL_COEX_PRIORITY = crate::ctypes::c_uint;
#[doc = "< 3-wire GPIO coexistence interface\nbased on IEEE 802.15.2-2003, subclause 6.\nTo support this interface,\n@ref mpsl_coex_support_802152_3wire_gpiote_if()\nmust be called."]
pub const mpsl_coex_if_id_t_MPSL_COEX_802152_3WIRE_GPIOTE_ID: mpsl_coex_if_id_t = 0;
#[doc = "< 1-wire GPIO coexistence interface.\nTo support this interface,\n@ref mpsl_coex_support_1wire_gpiote_if()\nmust be called."]
pub const mpsl_coex_if_id_t_MPSL_COEX_1WIRE_GPIOTE_ID: mpsl_coex_if_id_t = 1;
#[doc = "  Ids of the supported coexistence interfaces."]
pub type mpsl_coex_if_id_t = crate::ctypes::c_uint;
#[doc = "  Configuration parameters for one wire of the 3-wire coexistence interface GPIOTE based interface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_coex_gpiote_cfg_t {
    #[doc = "< The GPIO pin number."]
    pub gpio_pin: u8,
    #[doc = "< Active pin level: 1 - high level, 0 - low level."]
    pub active_high: u8,
    #[doc = "< PPI channel number."]
    pub ppi_ch_id: u8,
    #[doc = "< GPIOTE channel number."]
    pub gpiote_ch_id: u8,
}
#[test]
fn bindgen_test_layout_mpsl_coex_gpiote_cfg_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_coex_gpiote_cfg_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_coex_gpiote_cfg_t>(),
        4usize,
        concat!("Size of: ", stringify!(mpsl_coex_gpiote_cfg_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_coex_gpiote_cfg_t>(),
        1usize,
        concat!("Alignment of ", stringify!(mpsl_coex_gpiote_cfg_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpio_pin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_gpiote_cfg_t),
            "::",
            stringify!(gpio_pin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).active_high) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_gpiote_cfg_t),
            "::",
            stringify!(active_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ppi_ch_id) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_gpiote_cfg_t),
            "::",
            stringify!(ppi_ch_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gpiote_ch_id) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_gpiote_cfg_t),
            "::",
            stringify!(gpiote_ch_id)
        )
    );
}
#[doc = "  GPIOs configuration for 3-wire coexistence arbitrator.\n\n 3-wire coexistence protocol applies the packet traffic arbitration recommendation\n based on IEEE Std 802.15.2-2003, subclause 6.\n 3-wire interface is exposed by following signals:\n REQUEST  -   Asserted whenever the user of MPSL wants to transmit or receive.\n              The signal must remain asserted till the end of TX/RX or the request is rejected by PTA controller.\n PRI_STATUS - Asserted to indicate the priority (high or low) of the intended\n              traffic immediately following REQUEST. After that, it is changed to indicate TX or RX.\n GRANT      - Asserted to indicate whether the request is granted or rejected.\n\n The request is made at  * `type_delay_us` -  +  * `radio_delay_us` -  before the radio activity starts. The Priority and Status line will\n first indicate the priority of the request, then after  * `type_delay_us` - , it'll switch to showing the type of transaction (RX/TX).\n The radio will start transmitting or receiving  * `radio_delay_us` -  after this.\n Sum of  * `type_delay_us` -  +  * `radio_delay_us` -  cannot be more than 40us due to radio ramp-up time."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_coex_802152_3wire_gpiote_if_t {
    #[doc = "< Request line configuration."]
    pub request_cfg: mpsl_coex_gpiote_cfg_t,
    #[doc = "< Priority and Status line configuration."]
    pub priority_cfg: mpsl_coex_gpiote_cfg_t,
    #[doc = "< Grant line configuration."]
    pub grant_cfg: mpsl_coex_gpiote_cfg_t,
    #[doc = "< PPI channel used to set the priority level at the correct time.\nSince Priority and Status are combined functional, it requires separate PPI channel to handle both."]
    pub additional_ppi_ch_id: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    #[doc = "< Delay in us from the request pin is raised until the Priority and Status line shows the type of transaction (RX/TX)."]
    pub type_delay_us: u32,
    #[doc = "< Delay in us from the Priority and Status line shows the type of transaction, to the radio starts its on-air activity."]
    pub radio_delay_us: u32,
    #[doc = "< Pointer to a timer instance. Timer should not be shared with any other functionality."]
    pub p_timer_instance: *mut crate::ctypes::c_void,
}
#[test]
fn bindgen_test_layout_mpsl_coex_802152_3wire_gpiote_if_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_coex_802152_3wire_gpiote_if_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_coex_802152_3wire_gpiote_if_t>(),
        28usize,
        concat!("Size of: ", stringify!(mpsl_coex_802152_3wire_gpiote_if_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_coex_802152_3wire_gpiote_if_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_coex_802152_3wire_gpiote_if_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request_cfg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_802152_3wire_gpiote_if_t),
            "::",
            stringify!(request_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority_cfg) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_802152_3wire_gpiote_if_t),
            "::",
            stringify!(priority_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grant_cfg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_802152_3wire_gpiote_if_t),
            "::",
            stringify!(grant_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).additional_ppi_ch_id) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_802152_3wire_gpiote_if_t),
            "::",
            stringify!(additional_ppi_ch_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_delay_us) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_802152_3wire_gpiote_if_t),
            "::",
            stringify!(type_delay_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).radio_delay_us) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_802152_3wire_gpiote_if_t),
            "::",
            stringify!(radio_delay_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_timer_instance) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_802152_3wire_gpiote_if_t),
            "::",
            stringify!(p_timer_instance)
        )
    );
}
impl mpsl_coex_802152_3wire_gpiote_if_t {
    #[inline]
    pub fn is_rx_active_level(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_is_rx_active_level(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_rx_active_level: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_rx_active_level: u8 = unsafe { ::core::mem::transmute(is_rx_active_level) };
            is_rx_active_level as u64
        });
        __bindgen_bitfield_unit
    }
}
#[doc = "< 1-wire configuration to allow no concurrency with the external modem."]
pub const mpsl_coex_1wire_concurrency_mode_t_MPSL_COEX_1WIRE_CONCURRENCY_NONE: mpsl_coex_1wire_concurrency_mode_t = 0;
#[doc = "< 1-wire configuration to allow RX only concurrency with the external modem."]
pub const mpsl_coex_1wire_concurrency_mode_t_MPSL_COEX_1WIRE_CONCURRENCY_RX_ONLY: mpsl_coex_1wire_concurrency_mode_t =
    1;
#[doc = "  Concurrency mode with the external modem supported by 1-wire coexistence."]
pub type mpsl_coex_1wire_concurrency_mode_t = crate::ctypes::c_uint;
#[doc = "  GPIOs configuration for 1-wire coexistence arbitrator.\n\n 1-wire interface is exposed by following signals:\n GRANT - Asserted to indicate whether the external modem is active.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_coex_1wire_gpiote_if_t {
    #[doc = "< Grant line configuration."]
    pub grant_cfg: mpsl_coex_gpiote_cfg_t,
    #[doc = "< Concurrency mode configuration."]
    pub concurrency_mode: mpsl_coex_1wire_concurrency_mode_t,
}
#[test]
fn bindgen_test_layout_mpsl_coex_1wire_gpiote_if_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_coex_1wire_gpiote_if_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_coex_1wire_gpiote_if_t>(),
        8usize,
        concat!("Size of: ", stringify!(mpsl_coex_1wire_gpiote_if_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_coex_1wire_gpiote_if_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_coex_1wire_gpiote_if_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grant_cfg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_1wire_gpiote_if_t),
            "::",
            stringify!(grant_cfg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).concurrency_mode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_1wire_gpiote_if_t),
            "::",
            stringify!(concurrency_mode)
        )
    );
}
#[doc = "  Configuration of the coexistence interface.\n\n This option configures MPSL to support interface for requesting and granting access to the media\n and status notification in case of coexistence with another wireless standard."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpsl_coex_if_t {
    #[doc = "<  Identification number of configured interface."]
    pub if_id: mpsl_coex_if_id_t,
    #[doc = "<  Union with supported coexistence interfaces."]
    pub interfaces: mpsl_coex_if_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpsl_coex_if_t__bindgen_ty_1 {
    #[doc = "<  Configuration parameters of 3-wire GPIO based coexistence."]
    pub coex_3wire_gpiote: mpsl_coex_802152_3wire_gpiote_if_t,
    #[doc = "<  Configuration parameters of 1-wire GPIO based coexistence."]
    pub coex_1wire_gpiote: mpsl_coex_1wire_gpiote_if_t,
}
#[test]
fn bindgen_test_layout_mpsl_coex_if_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_coex_if_t__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_coex_if_t__bindgen_ty_1>(),
        28usize,
        concat!("Size of: ", stringify!(mpsl_coex_if_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_coex_if_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_coex_if_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coex_3wire_gpiote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_if_t__bindgen_ty_1),
            "::",
            stringify!(coex_3wire_gpiote)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).coex_1wire_gpiote) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_if_t__bindgen_ty_1),
            "::",
            stringify!(coex_1wire_gpiote)
        )
    );
}
#[test]
fn bindgen_test_layout_mpsl_coex_if_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_coex_if_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_coex_if_t>(),
        32usize,
        concat!("Size of: ", stringify!(mpsl_coex_if_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_coex_if_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_coex_if_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).if_id) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mpsl_coex_if_t), "::", stringify!(if_id))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interfaces) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_coex_if_t),
            "::",
            stringify!(interfaces)
        )
    );
}
#[doc = "  Type of callback invoked from coexistence interface upon completion\n         of enable or disable procedure.\n The callback must accept calls in both high- and low-priority threads."]
pub type mpsl_coex_on_complete_callback_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = "  Enable support for the 802.15.2 3-Wire coexistence interface.\n\n After this API is called, it is possible to configure MPSL with the coexistence interface\n @ref MPSL_COEX_802152_3WIRE_GPIOTE_ID."]
    pub fn mpsl_coex_support_802152_3wire_gpiote_if();
}
extern "C" {
    #[doc = "  Enable support for the 1-Wire coexistence interface.\n\n After this API is called, it is possible to configure MPSL with the coexistence interface\n @ref MPSL_COEX_1WIRE_GPIOTE_ID."]
    pub fn mpsl_coex_support_1wire_gpiote_if();
}
extern "C" {
    #[doc = "  Configures and enables the coexistence interface.\n\n  @note The function configures the interface and maps\n        the other interface functions on exact coexistence implementation\n\n  @param[in] p_cfg\n      Pointer to coexistence interface configuration structure. Any\n      configuration with if_id set to MPSL_COEX_IDS_NUMBER is invalid.\n  @param[in] enable_complete_callback\n      Callback to be invoked when the coexistence interface completes the\n      enabling procedure. The callback must accept calls in both high- and\n      low-priority threads.\n\n  Returns  0              The configuration for the coexistence interface was\n                          successfully set and the enabling procedure operation\n                          was initiated. The supplied callback will be called\n                          when the enabling procedure is completed.\n  Returns -NRF_EINVAL     Invalid configuration or NULL callback provided.\n  Returns -NRF_EAGAIN     Enabling was not allowed at the time because the\n                          coexistence interface was already enabled or in an\n                          ongoing enable or disable procedure. The call aborted\n                          without any effect.\n  Returns -NRF_EOPNOTSUPP The provided interface is not supported.\n                          All interfaces must be explicitly enabled. See @ref mpsl_coex_if_id_t."]
    pub fn mpsl_coex_enable(
        p_cfg: *const mpsl_coex_if_t,
        enable_complete_callback: mpsl_coex_on_complete_callback_t,
    ) -> i32;
}
extern "C" {
    #[doc = "  Disables the coexistence interface.\n\n  This releases all peripherals supplied to @ref mpsl_coex_enable for\n  application use. The released GPIOs will be reset to high-impedance mode\n  with no pull.\n\n @param[in] disable_complete_callback\n      Callback to be invoked when coexistence interface completes the\n      disabling procedure. The callback must accept calls in both high- and\n      low-priority threads.\n\n Returns 0            The disabling procedure for the coexistence interface\n                      was initiated. The supplied callback will be called when\n                      the disable procedure is completed.\n Returns -NRF_EAGAIN  Disabling was not allowed at the time because the\n                      coexistence interface was already disabled or in an\n                      ongoing enable or disable procedure. The call aborted\n                      without any effect.\n Returns -NRF_EINVAL  Invalid NULL callback provided."]
    pub fn mpsl_coex_disable(disable_complete_callback: mpsl_coex_on_complete_callback_t) -> i32;
}
#[doc = " Listening for asynchronous transmissions"]
pub const mpsl_cx_op_t_MPSL_CX_OP_IDLE_LISTEN: mpsl_cx_op_t = 1;
#[doc = " Active reception\n\n This value may be used to indicate:\n * RX window:\n   * in BLE connection event\n   * 802.15.4 CSL\n   * ...\n * Detected a frame transmitted asynchronously:\n   * during BLE scanning\n   * during 802.15.4 idle listening\n   * ..."]
pub const mpsl_cx_op_t_MPSL_CX_OP_RX: mpsl_cx_op_t = 2;
#[doc = " Active transmission"]
pub const mpsl_cx_op_t_MPSL_CX_OP_TX: mpsl_cx_op_t = 4;
#[doc = "  Radio operations which may be requested from or granted by PTA."]
pub type mpsl_cx_op_t = crate::ctypes::c_uint;
#[doc = "  Bitmap representing a list of radio operations.\n\n Logical OR of radio operations defined in @ref mpsl_cx_op_t."]
pub type mpsl_cx_op_map_t = u8;
#[doc = "  Priority of given radio operation.\n\n This numerical value is translated by given PTA interface driver to appropriate signal.\n The straightforward translation would be <= UINT8_MAX/2 is low priority, while > UINT8_MAX/2\n is high priority. More complicated PTAs support more than 2 priority levels and valid matching\n must be implemented for such devices.\n\n Priority values must be aligned between all users of this API in given system. When multiple\n radio protocols are enabled (like Bluetooth LE and IEEE 802.15.4), all protocols must use\n aligned values (Bluetooth low priority operations must use numerically lower value than\n IEEE 802.15.4 high priority operations)."]
pub type mpsl_cx_prio_t = u8;
#[doc = "< Request is triggered instantly, during @ref mpsl_cx_request call"]
pub const mpsl_cx_req_trig_t_MPSL_CX_REQ_TRIG_INSTANT: mpsl_cx_req_trig_t = 0;
#[doc = "  Coexistence request signal triggers."]
pub type mpsl_cx_req_trig_t = crate::ctypes::c_uint;
#[doc = "  Structure with parameters describing next coexistence request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_cx_request_t {
    #[doc = "< List of requested radio operations"]
    pub ops: mpsl_cx_op_map_t,
    #[doc = "< Priority of requested radio operation"]
    pub prio: mpsl_cx_prio_t,
    #[doc = "< When request is to be triggered"]
    pub trigger: mpsl_cx_req_trig_t,
}
#[test]
fn bindgen_test_layout_mpsl_cx_request_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_cx_request_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_cx_request_t>(),
        8usize,
        concat!("Size of: ", stringify!(mpsl_cx_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_cx_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_cx_request_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ops) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_cx_request_t),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prio) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_cx_request_t),
            "::",
            stringify!(prio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trigger) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_cx_request_t),
            "::",
            stringify!(trigger)
        )
    );
}
#[doc = "  Callback used to notify radio protocol about changes of granted radio operations.\n\n * `granted_ops` - List of all operations currently allowed by PTA."]
pub type mpsl_cx_cb_t = ::core::option::Option<unsafe extern "C" fn(granted_ops: mpsl_cx_op_map_t)>;
extern "C" {
    #[doc = "  Request radio operation from PTA\n\n This function is to be called before transceiver is enabled to inform PTA about planned radio\n operation which is about to start and about the priority of this operation.\n\n Each call of this function overrides the last request.\n\n This function is usually called shortly before scheduled radio operations, or just after\n detection of asynchronous events indicating radio operations.\n\n Call to this function cannot preempt a call to @ref mpsl_cx_release. It is responsibility of\n user of this interface to prevent such preemption.\n\n * `p_req_params` - Pointer to a structure containing parameters of given request.\n\n Returns 0         Requested radio operation from PTA\n Returns -EINVAL   Incorrect value of any field in  * `p_req_params` -  or  * `p_req_params` -  is NULL."]
    pub fn mpsl_cx_request(p_req_params: *const mpsl_cx_request_t) -> i32;
}
extern "C" {
    #[doc = "  Release last radio operation requested from PTA\n\n This function is to be called after transceiver is disabled to inform PTA that any previously\n requested operations by @ref mpsl_cx_request are not requested anymore.\n\n This function releases requested radio operations immediately.\n\n Call to this function cannot preempt a call to @ref mpsl_cx_request. It is responsibility of\n user of this interface to prevent such preemption.\n\n Returns 0          Last request is released.\n Returns -EALREADY  There was no request to release."]
    pub fn mpsl_cx_release() -> i32;
}
extern "C" {
    #[doc = "  Get list of radio operations currently granted by PTA.\n\n @note PTA may change granted radio operations list at any time. It is possible that value\n       returned by this function is outdated before the function ends its execution.\n\n * `p_granted_ops` - Map of granted radio operations.\n\n Returns 0        List of granted radio operations is stored in the passed memory address.\n Returns -EINVAL   * `granted_ops` -  is NULL pointer."]
    pub fn mpsl_cx_granted_ops_get(p_granted_ops: *mut mpsl_cx_op_map_t) -> i32;
}
extern "C" {
    #[doc = "  Get time PTA needs to respond with grant signal to request signal.\n\n There are three ways to manage the grant signal by PTA:\n 1. Keep grant signal in denied state by default and provide grant only after request.\n    The maximum delay between request and grant signal is known.\n 2. Keep grant signal in approved state by default and deny only if given request cannot be\n    accepted. Radio is not allowed to start any operation for known time after the request signal\n    is set. After this delay the grant signal can indicate denial anytime to prevent or to abort\n    radio operation.\n 3. Manage the granted signal constantly, even if there is no request from given radio.\n\n This function is to be used to verify how long the user of this interface should wait from\n calling @ref mpsl_cx_request (return from function) to @ref mpsl_cx_granted_ops_get (call\n to function) to prevent getting false results while PTA is responding to the last request.\n\n Returns >0 Minimal delay from setting the request signal to the time grant signal gets\n            meaningful value. In microseconds, rounded up\n Returns 0  Grant signal has always meaningful value. Can be checked before, during, or after\n            setting the request signal."]
    pub fn mpsl_cx_req_grant_delay_get() -> u32;
}
extern "C" {
    #[doc = "  Register callback function called when radio operations granted by PTA change.\n\n This function is used by radio protocols that require CPU processing when list of granted\n operations changes. One example is a protocol waiting with asynchronous transmission until TX\n operation is granted.\n\n When radio protocol stops using Coexistence interface to hand it over to another protocol,\n it shall reset callback by calling this function with NULL value passed in  * `cb` - .\n\n * `cb` - Pointer to a callback function called when radio operations granted by PTA\n                change. If NULL, callback function is reset and nothing is called when\n                granted radio operations change.\n\n Returns 0  Successfully set or reset callback function."]
    pub fn mpsl_cx_register_callback(cb: mpsl_cx_cb_t) -> i32;
}
#[doc = "  Set of pointers to functions in MPSL Coexistence interface.\n\n This structure defines a set of pointers to functions which correspond the Public Protocol API defined in the\n @ref mpsl_cx_protocol_api.h file."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_cx_interface_t {
    #[doc = " Pointer to a function called when @ref mpsl_cx_request is called"]
    pub p_request: ::core::option::Option<unsafe extern "C" fn(p_req_params: *const mpsl_cx_request_t) -> i32>,
    #[doc = " Pointer to a function called when @ref mpsl_cx_release is called"]
    pub p_release: ::core::option::Option<unsafe extern "C" fn() -> i32>,
    #[doc = " Pointer to a function called when @ref mpsl_cx_granted_ops_get is called"]
    pub p_granted_ops_get: ::core::option::Option<unsafe extern "C" fn(p_granted_ops: *mut mpsl_cx_op_map_t) -> i32>,
    #[doc = " Pointer to a function called when @ref mpsl_cx_req_grant_delay_get is called"]
    pub p_req_grant_delay_get: ::core::option::Option<unsafe extern "C" fn() -> u32>,
    #[doc = " Pointer to a function called when @ref mpsl_cx_register_callback is called"]
    pub p_register_callback: ::core::option::Option<unsafe extern "C" fn(cb: mpsl_cx_cb_t) -> i32>,
}
#[test]
fn bindgen_test_layout_mpsl_cx_interface_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_cx_interface_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_cx_interface_t>(),
        20usize,
        concat!("Size of: ", stringify!(mpsl_cx_interface_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_cx_interface_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_cx_interface_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_cx_interface_t),
            "::",
            stringify!(p_request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_release) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_cx_interface_t),
            "::",
            stringify!(p_release)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_granted_ops_get) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_cx_interface_t),
            "::",
            stringify!(p_granted_ops_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_req_grant_delay_get) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_cx_interface_t),
            "::",
            stringify!(p_req_grant_delay_get)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_register_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_cx_interface_t),
            "::",
            stringify!(p_register_callback)
        )
    );
}
extern "C" {
    #[doc = "  Connects to one of Coexistence PTA client implementation\n\n * `p_methods` - Pointer to structure of pointers.\n\n @note This must be used by Coexistence implementation \"constructor\" and this is the only case\n       in which it can be used.\n\n Returns   0               The \"link\" was successfuly created.\n Returns   -NRF_EPERM      Some error occured (e.g. null pointer was passed)."]
    pub fn mpsl_cx_interface_set(p_methods: *const mpsl_cx_interface_t) -> i32;
}
#[doc = "     Function prototype for the assert handler.\n\n @note      If an internal assert occurs this function is called. It is supposed to log the assert and stop execution.\n\n * `file` - The filename where the assertion occurred.\n * `line` - The line number where the assertion occurred."]
pub type mpsl_assert_handler_t =
    ::core::option::Option<unsafe extern "C" fn(file: *const crate::ctypes::c_char, line: u32)>;
extern "C" {
    #[doc = "      MPSL initialization\n\n * `p_clock_config` - Clock configuration.\nIf NULL the LF clock will be configured as an RC source with rc_ctiv =\n@ref MPSL_RECOMMENDED_RC_CTIV, .rc_temp_ctiv =\n@ref MPSL_RECOMMENDED_RC_TEMP_CTIV, and .accuracy_ppm = @ref MPSL_DEFAULT_CLOCK_ACCURACY_PPM.\n * `low_prio_irq` - IRQ to pend when low priority processing should be executed. The application\n                               shall call @ref mpsl_low_priority_process after this IRQ has occurred.\n * `p_assert_handler` - Pointer to MPSL assert handler.\n\n @note If `CONFIG_SYSTEM_CLOCK_NO_WAIT` is set to 0,\n       never modify the SEVONPEND flag in the SCR register,\n       while this function is executing.\n       Doing so might lead to a deadlock.\n\n @note If only Front End Module functionality is needed, @ref mpsl_fem_init can be called instead.\n\n Returns  0               MPSL is successfully initialized.\n Returns  -NRF_EPERM      MPSL is already initialized.\n Returns  -NRF_EINVAL     Invalid parameters supplied."]
    pub fn mpsl_init(
        p_clock_config: *const mpsl_clock_lfclk_cfg_t,
        low_prio_irq: u32,
        p_assert_handler: mpsl_assert_handler_t,
    ) -> i32;
}
extern "C" {
    #[doc = "       Uninitialize MPSL. Stops clocks and scheduler. This will release all peripherals and\n             reduce power usage.\n\n @note       This function assumes no protocol stacks are running, and no timeslots are requested.\n             All initialized protocol stacks need to be stopped before calling this function.\n             Failing to do so will lead to undefined behavior."]
    pub fn mpsl_uninit();
}
extern "C" {
    #[doc = "       Returns true if MPSL is already initialized, false otherwise.\n\n  @returns    True if initialized, false if not."]
    pub fn mpsl_is_initialized() -> bool_;
}
extern "C" {
    #[doc = "  Obtain build revision\n\n The application must provide a buffer that is at least @ref MPSL_BUILD_REVISION_SIZE\n bytes long. MPSL will copy the build revision to the provided buffer.\n\n * `p_build_revision` - Build revision.\n\n Returns 0              Success\n Returns -NRF_EINVAL    Invalid argument provided"]
    pub fn mpsl_build_revision_get(p_build_revision: *mut u8) -> i32;
}
extern "C" {
    #[doc = "       RADIO interrupt handler\n\n @note       This handler should be placed in the interrupt vector table.\n             The interrupt priority level should be priority 0."]
    pub fn MPSL_IRQ_RADIO_Handler();
}
extern "C" {
    #[doc = "       RTC0 interrupt handler\n\n @note       This handler should be placed in the interrupt vector table.\n             The interrupt priority level should be priority 0"]
    pub fn MPSL_IRQ_RTC0_Handler();
}
extern "C" {
    #[doc = "       TIMER0 interrupt handler.\n\n @note       This handler should be placed in the interrupt vector table.\n             The interrupt priority level should be priority 0"]
    pub fn MPSL_IRQ_TIMER0_Handler();
}
extern "C" {
    #[doc = "       POWER_CLOCK interrupt handler\n\n @note       This handler should be placed in the interrupt vector table.\n             The interrupt priority level should be lower than priority 0."]
    pub fn MPSL_IRQ_CLOCK_Handler();
}
extern "C" {
    #[doc = "  MPSL low priority processing handler.\n\n @note This handler should be called when MPSL signals low priority processing should be executed\n       (via low_prio_irq provided to @ref mpsl_init) within reasonable time (a at least a few\n       100 ms). The caller is responsible to ensure this function is not called concurrently with\n       any other low priority MPSL API functions, for more information see thread safety in the\n       MPSL documentation."]
    pub fn mpsl_low_priority_process();
}
extern "C" {
    #[doc = "  Get the temperature measured on the chip\n\n This function will block until the temperature measurement is done.\n It takes around 50 us from call to return.\n\n Returns Result of temperature measurement. Die temperature in 0.25 degrees Celsius."]
    pub fn mpsl_temperature_get() -> i32;
}
#[doc = "  The timeslot session id type"]
pub type mpsl_timeslot_session_id_t = u8;
#[doc = "< This signal indicates the start of the timeslot.\nThe signal will be executed in the same context as\n@ref MPSL_IRQ_TIMER0_Handler."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_START: MPSL_TIMESLOT_SIGNAL = 0;
#[doc = "< This signal indicates the TIMER0 interrupt.\nThe signal will be executed in the same context as\n@ref MPSL_IRQ_TIMER0_Handler."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_TIMER0: MPSL_TIMESLOT_SIGNAL = 1;
#[doc = "< This signal indicates the RADIO interrupt.\nThe signal will be executed in the same context as\n@ref MPSL_IRQ_RADIO_Handler."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_RADIO: MPSL_TIMESLOT_SIGNAL = 2;
#[doc = "< This signal indicates extend action failed.\nThe signal will be executed in the same context as\nthe previous signal."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_EXTEND_FAILED: MPSL_TIMESLOT_SIGNAL = 3;
#[doc = "< This signal indicates extend action succeeded.\nThe signal will be executed in the same context as\nthe previous signal."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_EXTEND_SUCCEEDED: MPSL_TIMESLOT_SIGNAL = 4;
#[doc = "< The previous request was blocked. The signal will\nbe executed in the same context as\n@ref mpsl_low_priority_process."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_BLOCKED: MPSL_TIMESLOT_SIGNAL = 5;
#[doc = "< The previous request was cancelled. The signal will\nbe executed in the same context as\n@ref mpsl_low_priority_process."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_CANCELLED: MPSL_TIMESLOT_SIGNAL = 6;
#[doc = "< The timeslot session has no more pending requests.\nThe signal will be executed in the same context as\n@ref mpsl_low_priority_process."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_SESSION_IDLE: MPSL_TIMESLOT_SIGNAL = 7;
#[doc = "< The previous timeslot callback return value was invalid.\nThe signal will be executed in the same context as\nthe previous signal which had an invalid return value.\nThe application should avoid to continuously provide\ninvalid return values. Doing so, will lead to an\ninfinite loop."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_INVALID_RETURN: MPSL_TIMESLOT_SIGNAL = 8;
#[doc = "< The session has been closed."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_SESSION_CLOSED: MPSL_TIMESLOT_SIGNAL = 9;
#[doc = "< The timeslot event was closed too late.\nAn assert will be triggered after the processing\nof this signal completes."]
pub const MPSL_TIMESLOT_SIGNAL_MPSL_TIMESLOT_SIGNAL_OVERSTAYED: MPSL_TIMESLOT_SIGNAL = 10;
#[doc = "  The timeslot signal types."]
pub type MPSL_TIMESLOT_SIGNAL = crate::ctypes::c_uint;
#[doc = "< Return without action."]
pub const MPSL_TIMESLOT_SIGNAL_ACTION_MPSL_TIMESLOT_SIGNAL_ACTION_NONE: MPSL_TIMESLOT_SIGNAL_ACTION = 0;
#[doc = "< Request an extension of the current\ntimeslot event.\nMaximum execution time for this action:\n@ref MPSL_TIMESLOT_EXTENSION_PROCESSING_TIME_MAX_US.\nThis action must be started at least\n@ref MPSL_TIMESLOT_EXTENSION_MARGIN_MIN_US before\nthe end of a timeslot event.\n@note This signal action may only be used from\nwithin a timeslot event."]
pub const MPSL_TIMESLOT_SIGNAL_ACTION_MPSL_TIMESLOT_SIGNAL_ACTION_EXTEND: MPSL_TIMESLOT_SIGNAL_ACTION = 1;
#[doc = "< End the current timeslot event.\n@note This signal action may only be called\nfrom within a timeslot event."]
pub const MPSL_TIMESLOT_SIGNAL_ACTION_MPSL_TIMESLOT_SIGNAL_ACTION_END: MPSL_TIMESLOT_SIGNAL_ACTION = 2;
#[doc = "< Request a new timeslot event.\n@note If this signal action is used from within\na timeslot, the current timeslot event is closed."]
pub const MPSL_TIMESLOT_SIGNAL_ACTION_MPSL_TIMESLOT_SIGNAL_ACTION_REQUEST: MPSL_TIMESLOT_SIGNAL_ACTION = 3;
#[doc = "  The actions requested by the signal callback.\n\n This code gives instructions about what action to take when the signal callback has\n returned.\n\n @note For signals executed in low priority returning any action other than\n       MPSL_TIMESLOT_SIGNAL_ACTION_NONE will result in an assert."]
pub type MPSL_TIMESLOT_SIGNAL_ACTION = crate::ctypes::c_uint;
#[doc = "< The high frequency clock source is the external crystal\nfor the whole duration of the timeslot. This should be the\npreferred option for events that use the radio or\nrequire high timing accuracy.\n@note The external crystal will automatically be\nturned on and off at the beginning and end of the\ntimeslot."]
pub const MPSL_TIMESLOT_HFCLK_CFG_MPSL_TIMESLOT_HFCLK_CFG_XTAL_GUARANTEED: MPSL_TIMESLOT_HFCLK_CFG = 0;
#[doc = "< This configuration allows for earlier and tighter\nscheduling of timeslots. The RC oscillator may be\nthe clock source in part or for the whole duration\nof the timeslot. The RC oscillator's accuracy must\ntherefore be taken into consideration.\n@note If the application will use the radio peripheral\nin timeslots with this configuration, it must ensure\nthat the crystal is running and stable before\nstarting the radio."]
pub const MPSL_TIMESLOT_HFCLK_CFG_MPSL_TIMESLOT_HFCLK_CFG_NO_GUARANTEE: MPSL_TIMESLOT_HFCLK_CFG = 1;
#[doc = "  Timeslot high frequency clock source configuration."]
pub type MPSL_TIMESLOT_HFCLK_CFG = crate::ctypes::c_uint;
#[doc = "< High priority."]
pub const MPSL_TIMESLOT_PRIORITY_MPSL_TIMESLOT_PRIORITY_HIGH: MPSL_TIMESLOT_PRIORITY = 0;
#[doc = "< Low priority."]
pub const MPSL_TIMESLOT_PRIORITY_MPSL_TIMESLOT_PRIORITY_NORMAL: MPSL_TIMESLOT_PRIORITY = 1;
#[doc = "  Timeslot event priorities."]
pub type MPSL_TIMESLOT_PRIORITY = crate::ctypes::c_uint;
#[doc = "< Request timeslot as early as possible.\nThis should always be used for the first request\nin a session.\n@note It is not permitted to request an earliest\ntimeslot from within a timeslot."]
pub const MPSL_TIMESLOT_REQUEST_TYPE_MPSL_TIMESLOT_REQ_TYPE_EARLIEST: MPSL_TIMESLOT_REQUEST_TYPE = 0;
#[doc = "< Normal timeslot request."]
pub const MPSL_TIMESLOT_REQUEST_TYPE_MPSL_TIMESLOT_REQ_TYPE_NORMAL: MPSL_TIMESLOT_REQUEST_TYPE = 1;
#[doc = "  Timeslot request type."]
pub type MPSL_TIMESLOT_REQUEST_TYPE = crate::ctypes::c_uint;
#[doc = "  Parameters for a request for a timeslot as early as possible."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_timeslot_request_earliest_t {
    #[doc = "< High frequency clock source, see @ref MPSL_TIMESLOT_HFCLK_CFG."]
    pub hfclk: u8,
    #[doc = "< The timeslot priority, see @ref MPSL_TIMESLOT_PRIORITY."]
    pub priority: u8,
    #[doc = "< The timeslot length, @sa @ref MPSL_TIMESLOT_LENGTH_MIN_US,\n@sa @ref MPSL_TIMESLOT_LENGTH_MAX_US."]
    pub length_us: u32,
    #[doc = "< Longest acceptable delay until the start of the requested\ntimeslot, up to @ref MPSL_TIMESLOT_EARLIEST_TIMEOUT_MAX_US\nmicroseconds."]
    pub timeout_us: u32,
}
#[test]
fn bindgen_test_layout_mpsl_timeslot_request_earliest_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_timeslot_request_earliest_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_timeslot_request_earliest_t>(),
        12usize,
        concat!("Size of: ", stringify!(mpsl_timeslot_request_earliest_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_timeslot_request_earliest_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_timeslot_request_earliest_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hfclk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_earliest_t),
            "::",
            stringify!(hfclk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_earliest_t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length_us) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_earliest_t),
            "::",
            stringify!(length_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout_us) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_earliest_t),
            "::",
            stringify!(timeout_us)
        )
    );
}
#[doc = "  Parameters for a normal timeslot request."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_timeslot_request_normal_t {
    #[doc = "< High frequency clock source, see @ref MPSL_TIMESLOT_HFCLK_CFG."]
    pub hfclk: u8,
    #[doc = "< The timeslot priority, see @ref MPSL_TIMESLOT_PRIORITY."]
    pub priority: u8,
    #[doc = "< Distance from the start of the previous timeslot\nup to @ref MPSL_TIMESLOT_DISTANCE_MAX_US microseconds."]
    pub distance_us: u32,
    #[doc = "< The timeslot length, @sa @ref MPSL_TIMESLOT_LENGTH_MIN_US,\n@sa @ref MPSL_TIMESLOT_LENGTH_MAX_US."]
    pub length_us: u32,
}
#[test]
fn bindgen_test_layout_mpsl_timeslot_request_normal_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_timeslot_request_normal_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_timeslot_request_normal_t>(),
        12usize,
        concat!("Size of: ", stringify!(mpsl_timeslot_request_normal_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_timeslot_request_normal_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_timeslot_request_normal_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hfclk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_normal_t),
            "::",
            stringify!(hfclk)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).priority) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_normal_t),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).distance_us) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_normal_t),
            "::",
            stringify!(distance_us)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length_us) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_normal_t),
            "::",
            stringify!(length_us)
        )
    );
}
#[doc = " Timeslot request parameters."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpsl_timeslot_request_t {
    #[doc = "< Type of request, see @ref MPSL_TIMESLOT_REQUEST_TYPE."]
    pub request_type: u8,
    #[doc = "< Union containing parameters for the request specified."]
    pub params: mpsl_timeslot_request_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpsl_timeslot_request_t__bindgen_ty_1 {
    #[doc = "< Parameters for requesting a timeslot as\nearly as possible."]
    pub earliest: mpsl_timeslot_request_earliest_t,
    #[doc = "< Parameters for requesting a normal timeslot."]
    pub normal: mpsl_timeslot_request_normal_t,
}
#[test]
fn bindgen_test_layout_mpsl_timeslot_request_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_timeslot_request_t__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_timeslot_request_t__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(mpsl_timeslot_request_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_timeslot_request_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_timeslot_request_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).earliest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_t__bindgen_ty_1),
            "::",
            stringify!(earliest)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).normal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_t__bindgen_ty_1),
            "::",
            stringify!(normal)
        )
    );
}
#[test]
fn bindgen_test_layout_mpsl_timeslot_request_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_timeslot_request_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_timeslot_request_t>(),
        16usize,
        concat!("Size of: ", stringify!(mpsl_timeslot_request_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_timeslot_request_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_timeslot_request_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_t),
            "::",
            stringify!(request_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_request_t),
            "::",
            stringify!(params)
        )
    );
}
#[doc = "  Return parameters of the timeslot signal callback."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpsl_timeslot_signal_return_param_t {
    #[doc = "< The action requested by the application when\nreturning from the signal callback, see\n@ref MPSL_TIMESLOT_SIGNAL_ACTION."]
    pub callback_action: u8,
    #[doc = "< Parameter union."]
    pub params: mpsl_timeslot_signal_return_param_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpsl_timeslot_signal_return_param_t__bindgen_ty_1 {
    #[doc = "< Additional parameters for return_code\n@ref MPSL_TIMESLOT_SIGNAL_ACTION_REQUEST."]
    pub request: mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1,
    #[doc = "< Additional parameters for return_code\n@ref MPSL_TIMESLOT_SIGNAL_ACTION_EXTEND."]
    pub extend: mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< The request parameters for the next timeslot."]
    pub p_next: *mut mpsl_timeslot_request_t,
}
#[test]
fn bindgen_test_layout_mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(p_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Requested extension of the timeslot duration.\nThe minimum time is\n@ref MPSL_TIMESLOT_EXTENSION_TIME_MIN_US)."]
    pub length_us: u32,
}
#[test]
fn bindgen_test_layout_mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length_us) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(length_us)
        )
    );
}
#[test]
fn bindgen_test_layout_mpsl_timeslot_signal_return_param_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_timeslot_signal_return_param_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_timeslot_signal_return_param_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1),
            "::",
            stringify!(request)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).extend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_signal_return_param_t__bindgen_ty_1),
            "::",
            stringify!(extend)
        )
    );
}
#[test]
fn bindgen_test_layout_mpsl_timeslot_signal_return_param_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_timeslot_signal_return_param_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_timeslot_signal_return_param_t>(),
        8usize,
        concat!("Size of: ", stringify!(mpsl_timeslot_signal_return_param_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_timeslot_signal_return_param_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_timeslot_signal_return_param_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback_action) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_signal_return_param_t),
            "::",
            stringify!(callback_action)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_timeslot_signal_return_param_t),
            "::",
            stringify!(params)
        )
    );
}
#[doc = "  The timeslot signal callback type.\n\n @note In case of invalid return parameters, the timeslot will automatically end\n       immediately after returning from the signal callback and the\n       @ref MPSL_TIMESLOT_SIGNAL_INVALID_RETURN event will be sent.\n @note The returned struct pointer must remain valid after the signal callback\n       function returns. For instance, this means that it must not point to a stack variable.\n\n * `session_id` - Session id as returned by @ref mpsl_timeslot_session_open.\n * `signal` - Type of signal, see @ref MPSL_TIMESLOT_SIGNAL.\n\n Returns Pointer to structure containing action requested by the application."]
pub type mpsl_timeslot_callback_t = ::core::option::Option<
    unsafe extern "C" fn(
        session_id: mpsl_timeslot_session_id_t,
        signal: u32,
    ) -> *mut mpsl_timeslot_signal_return_param_t,
>;
extern "C" {
    #[doc = "  Set or update the MPSL timeslot configuration.\n\n @note Resource configuration can only be performed when all timeslots are closed.\n\n * `p_mem` - Pointer to a memory location for timeslot sessions.\n                       The size of the memory block needs to be at least\n                       n_sessions * @ref MPSL_TIMESLOT_CONTEXT_SIZE bytes.\n                       The memory needs to reside in RAM.\n                       The pointer needs to be aligned to a 4-byte boundary.\n * `n_sessions` - Number of timeslot sessions.\n                       Maximum number of supported timeslot sessions is @ref MPSL_TIMESLOT_CONTEXT_COUNT_MAX.\n\n Returns  0            The configuration was applied successfully.\n Returns  -NRF_EPERM   Timeslots need to be configured when no timeslots are open.\n Returns  -NRF_EINVAL  Invalid argument provided.\n Returns  -NRF_EFAULT  The memory is not aligned to a 4-byte boundary."]
    pub fn mpsl_timeslot_session_count_set(p_mem: *mut crate::ctypes::c_void, n_sessions: u8) -> i32;
}
extern "C" {
    #[doc = "  Opens a session for timeslot requests.\n\n @note Only one session can be open at a time.\n @note mpsl_timeslot_signal_callback(@ref MPSL_TIMESLOT_SIGNAL_START) will be called when the timeslot\n       starts. From this point the RADIO, TIMER0, AAR, and CCM peripherals can be freely accessed\n       by the application.\n @note mpsl_timeslot_signal_callback(@ref MPSL_TIMESLOT_SIGNAL_TIMER0) is called whenever\n       the TIMER0 interrupt occurs.\n @note mpsl_timeslot_signal_callback(@ref MPSL_TIMESLOT_SIGNAL_RADIO) is called whenever the RADIO\n       interrupt occurs.\n @note If the low frequency clock is not running when this function is called,\n       the function will wait until the low frequency clock has started.\n       See @ref mpsl_clock_lfclk_cfg_t::skip_wait_lfclk_started.\n\n * `mpsl_timeslot_signal_callback` - The signal callback.\n * `p_session_id` - Pointer to the id of the session that was opened.\n\n Returns  0             Request was successful.\n Returns  -NRF_ENOMEM   All sessions are already open."]
    pub fn mpsl_timeslot_session_open(
        mpsl_timeslot_signal_callback: mpsl_timeslot_callback_t,
        p_session_id: *mut mpsl_timeslot_session_id_t,
    ) -> i32;
}
extern "C" {
    #[doc = "  Closes a session for timeslot requests.\n\n @note Any current timeslot will be finished before the session is closed.\n @note If a timeslot is scheduled when the session is closed, it will be canceled.\n\n * `session_id` - The session identifier as returned by @ref mpsl_timeslot_session_open.\n\n Returns 0              Success\n Returns  -NRF_EAGAIN   Session already closed"]
    pub fn mpsl_timeslot_session_close(session_id: mpsl_timeslot_session_id_t) -> i32;
}
extern "C" {
    #[doc = "  Requests a timeslot.\n\n @note The first request in a session must always be of type @ref MPSL_TIMESLOT_REQ_TYPE_EARLIEST.\n\n @note Successful requests will result in mpsl_timeslot_signal_callback_t(@ref MPSL_TIMESLOT_SIGNAL_START).\n       Unsuccessful requests will result in a @ref MPSL_TIMESLOT_SIGNAL_BLOCKED event.\n @note The jitter in the start time of the timeslots is +/- @ref MPSL_TIMESLOT_START_JITTER_US us.\n @note The mpsl_timeslot_signal_callback_t(@ref MPSL_TIMESLOT_SIGNAL_START) call has a latency relative to the\n       specified timeslot start, but this does not affect the actual start time of the timeslot.\n @note TIMER0 is reset at the start of the timeslot, and is clocked at 1MHz from the high frequency\n       (16 MHz) clock source\n @note No stack will neither access the RADIO peripheral nor the TIMER0 peripheral\n       during the timeslot.\n\n * `session_id` - The session identifier as returned by @ref mpsl_timeslot_session_open.\n * `p_request` - Pointer to the request parameters.\n\n Returns 0              Success\n Returns  -NRF_EINVAL   The parameters of p_request are not valid\n Returns  -NRF_ENOENT   The session is not open.\n Returns  -NRF_EAGAIN   The session is not IDLE."]
    pub fn mpsl_timeslot_request(
        session_id: mpsl_timeslot_session_id_t,
        p_request: *const mpsl_timeslot_request_t,
    ) -> i32;
}
pub const mpsl_phy_t_MPSL_PHY_BLE_1M: mpsl_phy_t = 0;
pub const mpsl_phy_t_MPSL_PHY_BLE_2M: mpsl_phy_t = 1;
pub const mpsl_phy_t_MPSL_PHY_BLE_LR125Kbit: mpsl_phy_t = 2;
pub const mpsl_phy_t_MPSL_PHY_BLE_LR500Kbit: mpsl_phy_t = 3;
pub const mpsl_phy_t_MPSL_PHY_Ieee802154_250Kbit: mpsl_phy_t = 4;
#[doc = "  PHYs supported for limiting channel TX power"]
pub type mpsl_phy_t = crate::ctypes::c_uint;
#[doc = " TX power, dBm."]
pub type mpsl_tx_power_t = i8;
#[doc = "  Max TX power envelope. It is up to the application to allocate memory for an envelope."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpsl_tx_power_envelope_t {
    #[doc = "< The PHY that this envelope applies to."]
    pub phy: mpsl_phy_t,
    #[doc = "< Array of maximum TX power value per channel. From 11 to 26 for 802.15.4 protocol.\nFrom 0 to 40 for Bluetooth LE protocol."]
    pub envelope: mpsl_tx_power_envelope_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union mpsl_tx_power_envelope_t__bindgen_ty_1 {
    #[doc = " Tx power per channel when @ref mpsl_tx_power_envelope_t::phy is a Bluetooth LE PHY."]
    pub tx_power_ble: [mpsl_tx_power_t; 40usize],
    #[doc = " Tx power per channel when @ref mpsl_tx_power_envelope_t::phy is a 802.15.4 PHY."]
    pub tx_power_802154: [mpsl_tx_power_t; 16usize],
}
#[test]
fn bindgen_test_layout_mpsl_tx_power_envelope_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_tx_power_envelope_t__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_tx_power_envelope_t__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(mpsl_tx_power_envelope_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_tx_power_envelope_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(mpsl_tx_power_envelope_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_power_ble) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_tx_power_envelope_t__bindgen_ty_1),
            "::",
            stringify!(tx_power_ble)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_power_802154) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_tx_power_envelope_t__bindgen_ty_1),
            "::",
            stringify!(tx_power_802154)
        )
    );
}
#[test]
fn bindgen_test_layout_mpsl_tx_power_envelope_t() {
    const UNINIT: ::core::mem::MaybeUninit<mpsl_tx_power_envelope_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<mpsl_tx_power_envelope_t>(),
        44usize,
        concat!("Size of: ", stringify!(mpsl_tx_power_envelope_t))
    );
    assert_eq!(
        ::core::mem::align_of::<mpsl_tx_power_envelope_t>(),
        4usize,
        concat!("Alignment of ", stringify!(mpsl_tx_power_envelope_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_tx_power_envelope_t),
            "::",
            stringify!(phy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).envelope) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mpsl_tx_power_envelope_t),
            "::",
            stringify!(envelope)
        )
    );
}
extern "C" {
    #[doc = "  Sets maximum TX power envelope. If the PHY already has an envelope configured, it will be over-written.\n\n @note Calling this function while an envelope is being used to limit current TX Power\n       may lead to undefined behavior.\n\n @note The memory for the provided envelope is not copied and must be valid until it is replaced\n       with another envelope for the same PHY.\n\n * `p_envelope` - The pointer to an envelope, if NULL the envelopes for all PHYs are reset to\n                       maximum power possible.\n\n Returns  0              TX power channel successfully set.\n Returns  -NRF_EINVAL   Invalid parameter provided."]
    pub fn mpsl_tx_power_channel_map_set(p_envelope: *const mpsl_tx_power_envelope_t) -> i32;
}
extern "C" {
    #[doc = "  Adjusts TX power to a value supported by the RADIO peripheral.\n\n * `req_radio_power` - Requested TX power desired for RADIO peripheral.\n\n  Returns RADIO TX power that is supported by the RADIO peripheral.\n          If  * `req_radio_power` -  is less than the minimum TX power supported, the minimum\n          supported TX power is returned. Otherwise, closest supported value that is less\n          or equal to  * `req_radio_power` -  returned."]
    pub fn mpsl_tx_power_radio_supported_power_adjust(req_radio_power: mpsl_tx_power_t) -> mpsl_tx_power_t;
}
